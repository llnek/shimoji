!function(t,e,s){var i,r=256,n="random",o=s.pow(r,6),h=s.pow(2,52),l=2*h,a=255;function c(a,c,p){function m(){for(var t=w.g(6),e=o,s=0;t<h;)t=(t+s)*r,e*=r,s=w.g(1);for(;l<=t;)t/=2,e/=2,s>>>=1;return(t+s)/e}var y=[],v=f(function t(e,s){var i,r=[],n=typeof e;if(s&&"object"==n)for(i in e)try{r.push(t(e[i],s-1))}catch(t){}return r.length?r:"string"==n?e:e+"\0"}((c=1==c?{entropy:!0}:c||{}).entropy?[a,g(e)]:null==a?function(){try{var s;return i&&(s=i.randomBytes)?s=s(r):(s=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(s)),g(s)}catch(s){var n=t.navigator,o=n&&n.plugins;return[+new Date,t,o,t.screen,g(e)]}}():a,3),y),w=new u(y);return m.int32=function(){return 0|w.g(4)},m.quick=function(){return w.g(4)/4294967296},m.double=m,f(g(w.S),e),(c.pass||p||function(t,e,i,r){return r&&(r.S&&d(r,w),t.state=function(){return d(w,{})}),i?(s[n]=t,e):t})(m,v,"global"in c?c.global:this==s,c.state)}function u(t){var e,s=t.length,i=this,n=0,o=i.i=i.j=0,h=i.S=[];for(s||(t=[s++]);n<r;)h[n]=n++;for(n=0;n<r;n++)h[n]=h[o=a&o+t[n%s]+(e=h[n])],h[o]=e;(i.g=function(t){for(var e,s=0,n=i.i,o=i.j,h=i.S;t--;)e=h[n=a&n+1],s=s*r+h[a&(h[n]=h[o=a&o+e])+(h[o]=e)];return i.i=n,i.j=o,s})(r)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){for(var s,i=t+"",r=0;r<i.length;)e[a&r]=a&(s^=19*e[a&r])+i.charCodeAt(r++);return g(e)}function g(t){return String.fromCharCode.apply(0,t)}if(f(s.random(),e),"object"==typeof module&&module.exports){module.exports=c;try{i=require("crypto")}catch(c){}}else"function"==typeof define&&define.amd?define((function(){return c})):s["seed"+n]=c}("undefined"!=typeof self?self:this,[],Math),function(t,e,s,i){"use strict";function r(){const r=t,n=Math.floor,o=Array.prototype.slice,h=Object.prototype.toString;function l(t){return"[object Object]"==h.call(t)}function a(t){return l(t)}function c(t){return"[object Function]"==h.call(t)}function u(t){return"[object Array]"==h.call(t)}function d(t){return"[object Map]"==h.call(t)}function f(t){return"[object Set]"==h.call(t)}function g(t){return"[object String]"==h.call(t)}function p(t){return"[object Number]"==h.call(t)}function m(t){return"[object Boolean]"==h.call(t)}function y(t){return(t<0?-t:t)%2==0}function v(t){return void 0===t}function w(t){return u(t)||d(t)||l(t)}const x=1.6180339887,_=s?s():Math.seedrandom?new Math.seedrandom:function(){return Math.random()};function N(t,e){return t.forEach((t=>{if(!t[0](t[1]))throw new TypeError(`wanted ${e}`)})),!0}function b(t,e){for(let e,s=0;s<t.length;++s)if(e=t[s],e[0](e[1]))return!0;throw new TypeError(`wanted ${e}`)}function k(t,e,s){if(!t(e))throw new TypeError(`wanted ${s}`);return!0}const E=/(\/|\\\\)([^(\/|\\\\)]+)$/g,M=/(\.[^\.\/\?\\]*)(\?.*)?$/;function T(t,e){let s=M.exec(t);return s&&s[1]?(s=s[1].toLowerCase(),e||(s=s.substring(1))):s="",s}function S(t,e,s){const i=t(e);switch(s.length){case 0:return i;case 1:return i&&t(s[0]);case 2:return i&&t(s[0])&&t(s[1]);case 3:return i&&t(s[0])&&t(s[1])&&t(s[2]);default:return i&&s.every((e=>t(e)))}}const q=1e-10;let I=0;const O={},A={fun:(t,...e)=>S(c,t,e),str:(t,...e)=>S(g,t,e),undef:(t,...e)=>S(v,t,e),map:(t,...e)=>S(d,t,e),set:(t,...e)=>S(f,t,e),num:(t,...e)=>S(p,t,e),bool:(t,...e)=>S(m,t,e),pos:t=>p(t)&&t>0,neg:t=>p(t)&&t<0,vec:(t,...e)=>S(u,t,e),obj:(t,...e)=>S(l,t,e),notEmpty:t=>z.size(t)>0,isEmpty:t=>0==z.size(t),own:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},z={error(...t){console.error(...t)},log(...t){console.log(...t)},feq0:t=>t>=-1e-10&&t<=q,feq:(t,e,s=1e-10)=>t>=e-s&&t<=e+s,hexToBin(t){const e={0:"0000",1:"0001",2:"0010",3:"0011",4:"0100",5:"0101",6:"0110",7:"0111",8:"1000",9:"1001",a:"1010",b:"1011",c:"1100",d:"1101",e:"1110",f:"1111",A:"1010",B:"1011",C:"1100",D:"1101",E:"1110",F:"1111"};let s="";for(let r,n=0;n<t.length;++n)(r=e[t[n]])?s+=r:(n=1/0,s=i);return s},pack:t=>JSON.stringify(t),unpack:t=>JSON.parse(t),v2:(t=0,e=0)=>[t,e],p2:(t=0,e=0)=>({x:t,y:e}),numOrZero:t=>isNaN(t)?0:t,setVec:(t,...e)=>(e.forEach(((e,s)=>t[s]=e)),t),evenN:(t,e)=>y(t=n(t))?t:e?t+1:t-1,nichts:t=>null==t,echt:t=>null!=t,nor:(t,e)=>null==t?e:t,or:(t,e)=>void 0===t?e:t,toNum(t,e){const s=parseFloat(t);return isNaN(s)&&p(e)?e:s},percentRemain:(t,e,s)=>(t>e&&(t=s?t%e:e),Math.max(0,e-t)/e),splitVerStr(t){const e=(""+(t||"")).split(".").filter((t=>t.length>0));return[this.toNum(e[0],0),this.toNum(e[1],0),this.toNum(e[2],0)]},cmpVerStrs(t,e){let s=this.splitVerStr(""+t),i=this.splitVerStr(""+e);return s[0]>i[0]?1:s[0]<i[0]?-1:s[1]>i[1]?1:s[1]<i[1]?-1:s[2]>i[2]?1:s[2]<i[2]?-1:0},pdef:t=>(t.configurable=!0)&&(t.enumerable=!0)&&t,findFiles:(t,e)=>t.filter((t=>e.indexOf(T(t,1))>-1)),zipMap(t,e,s){let i,r=Math.min(t.length,e.length),n=s||new Map;for(i=0;i<r;++i)n.set(t[i],e[i]);return n},zip(t,e,s){return this.zipMap(t,e,s)},zipObj(t,e,s){let i,r=Math.min(t.length,e.length),n=s||{};for(i=0;i<r;++i)n[t[i]]=e[i];return n},partition(t,e){const s=[];for(let i,r,n=0;;){for(i=[],r=0;r<t;++r){if(!(n<e.length)){r=-1;break}i.push(e[n++])}if(i.length>0&&s.push(i),r<0)break}return s},keys:t=>d(t)?Array.from(t.keys()):l(t)?Object.keys(t):[],selectNotKeys(t,e){b([[d,t],[l,t]],"map/object");const s=d(t)?new Map:{};return e=this.seq(e),this.doseq(t,((t,i)=>!e.includes(i)&&this.assoc(s,i,t))),s},selectKeys(t,e){b([[d,t],[l,t]],"map/object");const s=d(t)?new Map:{};return this.seq(e).forEach((e=>{d(t)?t.has(e)&&s.set(e,t.get(e)):A.own(t,e)&&(s[e]=t[e])})),s},copyKeys(t,e,s){return b([[d,t],[l,t]],"map/object"),e instanceof Map&&z.assert(t instanceof Map,"expected Map"),this.seq(s).forEach((s=>{d(e)?e.has(s)&&t.set(s,e.get(s)):(A.own(e,s)||void 0!==e[s])&&(t[s]=e[s])})),t},setManyKeys(t,e,s){return b([[d,t],[l,t]],"map/object"),this.seq(e).forEach((e=>{d(t)?t.set(e,s):t[e]=s})),t},clearKeys(t,e){return b([[d,t],[l,t]],"map/object"),this.seq(e).forEach((e=>{d(t)?t.delete(e):delete t[e]})),t},assertNot(t,...e){return this.assert(!t,...e)},assert(t,...e){if(!t)throw 0==e.length?"Assertion!":e.join("");return!0},noSuchKeys(t,e){return!this.some(this.seq(t),(t=>this.has(e,t)?t:null))},randInt2:(t,e)=>t+n(_()*(e-t+1)),randFloat2:(t,e)=>t+_()*(e-t),randMinus1To1:()=>2*(_()-.5),randInt:t=>n(_()*t),rand:(t=!1)=>t?Math.random():_(),randGaussian(t=6){let e,s=0;for(e=0;e<t;++e)s+=this.rand();return s/t},randSign:()=>_()>.5?-1:1,toGoldenRatio(t){let e=t/x,s=e/x;return[this.rounded(e),this.rounded(s)]},inst:(t,e)=>e instanceof t,hashCode(t){let e,s=0;for(e=0;e<t.length;++e)s=Math.imul(31,s)+t.charCodeAt(e);return s},cls(t){try{t.length=0}catch(t){}return t},randSample(t,e=1){let s,i;return 1==e?i=[this.randItem(t)]:0==e?i=[]:e>0&&(s=this.shuffle(t,!1),i=e>=s.length?s:s.slice(0,e)),i},randItem(t,e=!1){let s,i=-1;if(t)switch(t.length){case 0:case 1:s=t[i=0];break;case 2:s=t[i=this.randSign()>0?1:0];break;default:s=t[i=n(_()*t.length)]}return e?[s,i]:s},isPerc:t=>g(t)&&t.match(/^([0-9])(\.?[0-9]+|[0-9]*)%$/),isEven:t=>y(t),jsMap(...t){k(y,t.length,"even n# of args");let e,s=new Map;for(e=0;e<t.length;)s.set(t[e],t[e+1]),e+=2;return s},jsObj(...t){k(y,t.length,"even n# of args");let e,s={};for(e=0;e<t.length;)s[t[e]]=t[e+1],e+=2;return s},jsVec:(...t)=>0==t.length?[]:t.slice(),lastIndex:t=>u(t)&&t.length>0?t.length-1:-1,first(t){if(u(t)&&t.length>0)return t[0]},last(t){if(u(t)&&t.length>0)return t[t.length-1]},head(t){return this.first(t)},tail(t){return this.last(t)},floor:t=>Math.floor(t),ceil:t=>Math.ceil(t),abs:t=>Math.abs(t),sqrt:t=>Math.sqrt(t),min:(...t)=>Math.min(...t),max:(...t)=>Math.max(...t),slice:(t,e)=>o.call(t,e),every(t,e){k(u,t,"array");for(let s=0;s<t.length;++s)if(c(e)){if(!e(t[s]))return!1}else if(t[s]!=e)return!1;return t.length>0},notAny(t,e){k(u,t,"array");for(let s=0;s<t.length;++s)if(c(e)){if(e(t[s]))return!1}else if(t[s]===e)return!1;return t.length>0},copy(t,e=[]){N([[u,t],[u,e]],"arrays");let s,i=Math.min(t.length,e.length);for(s=0;s<i;++s)t[s]=e[s];return t},append(t,e=[],s=!1){N([[u,t],[u,e]],"arrays"),s&&(t.length=0);for(let s=0;s<e.length;++s)t.push(e[s]);return t},fill(t,e,...s){if(p(t)&&(t=new Array(t)),u(t))for(let i=0;i<t.length;++i)t[i]=c(e)?e(i,...s):e;return t},size(t){return u(t)||g(t)?t.length:f(t)||d(t)?t.size:t?this.keys(t).length:0},nextId:()=>++I,now:()=>Date.now(),fileExt:t=>T(t),fileBase(t){let e,s,i=t.indexOf("?");return i>0&&(t=t.substring(0,i)),t=t.replace(/(\/|\\\\)$/,""),s=E.exec(t),e="",s&&(e=s[2],i=e.lastIndexOf("."),i>0&&(e=e.substring(0,i))),e},range(t,e,s=1){1==arguments.length&&(e=t,t=0,s=1);let i=(e-t)/s;const r=[];i=Math.ceil(i),i=Math.max(0,i),r.length=i;for(let e=0;e<i;++e)r[e]=t,t+=s;return r},shuffle(t,e=!0){k(u,t,"array");const s=o.call(t,0);switch(s.length){case 0:case 1:break;case 2:if(this.randSign()>0){let t=s[0];s[0]=s[1],s[1]=t}break;default:for(let t,e,i=s.length-1;i>0;--i)e=n(_()*(i+1)),t=s[i],s[i]=s[e],s[e]=t}return e?this.copy(t,s):s},shuffle2(t,e=!0){k(u,t,"array");const s=o.call(t,0);switch(s.length){case 0:case 1:break;case 2:if(this.randSign()>0){let t=s[0];s[0]=s[1],s[1]=t}break;default:for(let t,e,i=0,r=s.length;i<r;++i)e=i+n(_()*(r-i)),t=s[e],s[e]=s[i],s[i]=t}return e?this.copy(t,s):s},shuffle3(t,e=!0){return(e?t:o.call(t,0)).sort(((t,e)=>this.rand()>.5?-1:this.rand()>.5?1:0))},uniq:t=>(k(u,t,"array"),Array.from(new Set(t))),map(t,e,s){if(k(w,t,"array/map/object"),u(t))return t.map(e,s);{const i=d(t)?new Map:{};return this.doseq(t,((r,n)=>{this.assoc(i,n,e.call(s,r,n,t))})),i}},find(t,e,s){let i,r=!0,n=o.call(arguments,3);return this.doseq(t,((t,o)=>{r&&e.apply(s,[t,o].concat(n))&&(i=[o,t],r=!1)})),i},some(t,e,s){let i,r=!0,n=o.call(arguments,3);return this.doseq(t,((t,o)=>{r&&(i=e.apply(s,[t,o].concat(n)),i?r=!1:i=void 0)})),i},equals(t,e){if(a(t)&&a(e)){let s,i,r=Object.keys(t),n=Object.keys(e);if(r.length==n.length){for(let o=0;o<r.length;++o)if(s=r[o],i=n[o],!this.equals(s,i)||!this.equals(t[s],e[i]))return!1;return!0}return!1}if(u(t)&&u(e)){if(t.length==e.length){for(let s=0;s<t.length;++s)if(!this.equals(t[s],e[s]))return!1;return!0}return!1}if(p(t)&&p(e))return t==e;if(g(t)&&g(e))return t==e;if(m(t)&&m(e))return t==e;if(null===t&&null===e)return!0;if(void 0===t&&void 0===e)return!0;throw Error("cant call equals for these types")},invoke(t,e){let s=o.call(arguments,2);u(t)&&t.forEach((t=>t[e].apply(t,s)))},delay:(t,e)=>setTimeout(e,t),timer:(t,e=0,s=!1)=>({repeat:!!s,id:s?setInterval(t,e):setTimeout(t,e)}),clear(t){t&&t.id?(t.repeat?clearInterval(t.id):clearTimeout(t.id),t.id=0):A.pos(t)&&clearTimeout(t)},dotimes(t,e,s,...i){for(let r=0;r<t;++r)e.call(s,r,...i)},rseq(t,e,s){if(k(u,t,"array"),t.length>0)for(let i=t.length-1;i>=0;--i)e.call(s,t[i],i,t)},doseq(t,e,s){u(t)?t.forEach(e,s):d(t)?t.forEach(((i,r)=>e.call(s,i,r,t))):l(t)&&Object.keys(t).forEach((i=>e.call(s,t[i],i,t)))},doseqEx(t,e,s){this.doseq(t,((i,r)=>null!=i&&e.call(s,i,r,t)))},dissoc(t,e){if(arguments.length>2){let e,s=1;for(;s<arguments.length;++s)e=this.dissoc(t,arguments[s]);return e}{let s;return d(t)?(s=t.get(e),t.delete(e)):l(t)&&(s=t[e],delete t[e]),s}},get(t,e){if(void 0!==e){if(d(t))return t.get(e);if(t)return t[e]}},assoc(t,e,s){if(arguments.length>3){if((arguments.length-1)%2!=0)throw"wanted even count of args";let e,s=1;for(;s<arguments.length;)e=this.assoc(t,arguments[s],arguments[s+1]),s+=2;return e}{let i;return d(t)?(i=t.get(e),t.set(e,s)):t&&(i=t[e],t[e]=s),i}},disj(t,e){const s=t?t.indexOf(e):-1;return s>-1&&t.splice(s,1),s>-1},conj:(t,...e)=>(t&&e.forEach((e=>t.push(e))),t),seq:(t,e=/[,; \t\n]+/)=>("string"==typeof t&&(t=t.split(e).map((t=>t.trim())).filter((t=>t.length>0))),u(t)||(t=[t]),t),has(t,e){return 1!=arguments.length&&(d(t)?t.has(e):u(t)?-1!=t.indexOf(e):!!l(t)&&A.own(t,e))},patch(t,e){return k(l,t=t||{},"object"),e&&Object.keys(e).forEach((s=>{this.has(t,s)||(t[s]=e[s])})),t},clone(t){return t?this.unpack(this.pack(t)):t},inject:(t,...e)=>(t=t||{},e.forEach((e=>e&&function(t,e){let s=Object.keys(e).reduce(((t,s)=>(t[s]=Object.getOwnPropertyDescriptor(e,s),t)),{});return Object.getOwnPropertySymbols(e).forEach((t=>{let i=Object.getOwnPropertyDescriptor(e,t);i.enumerable&&(s[t]=i)})),Object.defineProperties(t,s)}(t,e))),t),deepCopyArray(t){k(u,t,"array");let e,s,i=[];for(e=0,s=t.length;e<s;++e)i[e]=u(t[e])?this.deepCopyArray(t[e]):t[e];return i},mergeEx(t,e){return this.merge(this.merge({},t),e)},merge(t,e){let s;return Object.keys(e).forEach((i=>{s=e[i],"object"==typeof s&&null!==s&&t[i]?("object"!=typeof t[i]&&(t[i]=s instanceof Array?[]:{}),this.merge(t[i],s)):t[i]=s})),t},throttle(t,e,s){let i=!0,r=!0;if("function"!=typeof t)throw new TypeError("Expected a function");return l(s)&&(i="leading"in s?!!s.leading:i,r="trailing"in s?!!s.trailing:r),this.debounce(t,e,{leading:i,trailing:r,maxWait:e})},debounce(t,e,s){let i,n,o,h,l,c,u=0,d=!1,f=!1,g=!0;const p=!e&&0!==e&&"function"==typeof r.requestAnimationFrame;if("function"!=typeof t)throw new TypeError("Expected a function");function m(e){const s=i,r=n;return i=n=void 0,u=e,h=t.apply(r,s),h}function y(t,e){return p?(r.cancelAnimationFrame(l),r.requestAnimationFrame(t)):setTimeout(t,e)}function v(t){const s=t-c;return void 0===c||s>=e||s<0||f&&t-u>=o}function w(){const t=Date.now();if(v(t))return x(t);l=y(w,function(t){const s=t-u,i=e-(t-c);return f?Math.min(i,o-s):i}(t))}function x(t){return l=void 0,g&&i?m(t):(i=n=void 0,h)}function _(...t){const s=Date.now(),r=v(s);if(i=t,n=this,c=s,r){if(void 0===l)return function(t){return u=t,l=y(w,e),d?m(t):h}(c);if(f)return l=y(w,e),m(c)}return void 0===l&&(l=y(w,e)),h}return e=+e||0,a(s)&&(d=!!s.leading,f="maxWait"in s,o=f?Math.max(+s.maxWait||0,e):o,g="trailing"in s?!!s.trailing:g),_.cancel=function(){void 0!==l&&function(t){if(p)return r.cancelAnimationFrame(t);clearTimeout(t)}(l),u=0,i=c=n=l=void 0},_.flush=function(){return void 0===l?h:x(Date.now())},_.pending=function(){return void 0!==l},_},negate:t=>(k(c,t,"function"),function(...e){return!t.apply(this,e)}),strPadRight:(t,e,s)=>(e-=t.length)>0?t+new Array(Math.ceil(e/s.length)+1).join(s).substr(0,e):t,strPadLeft:(t,e,s)=>(e-=t.length)>0?new Array(Math.ceil(e/s.length)+1).join(s).substr(0,e)+t:t,safeSplit:(t,e)=>(t||"").trim().split(e).filter((t=>t.length>0)),capitalize:t=>t.charAt(0).toUpperCase()+t.slice(1),prettyNumber(t,e=2,s="0"){return this.strPadLeft(Number(t).toString(),e,s)},prettyMillis(t){let e,s,i=n(t/1e3);s=n(i/60),t-=1e3*i,i-=60*s,e=n(s/60),s-=60*e;let r=[];return r.push(`${i}.${t} secs`),(s>0||e>0)&&r.push(`${s} mins, `),e>0&&r.push(`${e} hrs, `),r.reverse().join("")},swap(t,e,s){let i=t[e];return t[e]=t[s],t[s]=i,t},listIndexesOf(t,e){let s=z.fill(t.length,(t=>t));return e?this.shuffle(s):s},dropArgs:(t,e)=>t.length>e?o.call(t,e):[],isSSL:()=>t&&t.location&&t.location.protocol.indexOf("https")>=0,isMobile:t=>t&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(t.userAgent),isSafari:t=>t&&/Safari/.test(t.userAgent)&&/Apple Computer/.test(t.vendor),isCrossOrigin(e){let s=t;if(2==arguments.length&&911==arguments[1].hack&&(s=arguments[1]),s&&s.location&&e){const t=e.indexOf("://");if(t>0){let i=e.indexOf("/",t+3);return(i<0?e:e.substring(0,i))!=s.location.origin}}},addEvent(t,e,s,i){u(t)&&1==arguments.length?t.forEach((t=>this.addEvent.apply(this,t))):e.addEventListener(t,s,i)},delEvent(t,e,s,i){u(t)&&1==arguments.length?t.forEach((t=>this.delEvent.apply(this,t))):e.removeEventListener(t,s,i)},rounded(t){return this.roundUnderOffset(t,.5)},roundUnderOffset(t,e){const s=n(t);return t-s<e?s:s+1}},C={qSelector:t=>e.querySelectorAll(t),qId:t=>e.getElementById(t),parent(t){if(t)return t.parentNode},conj:(t,e)=>t.appendChild(e),byTag:(t,s)=>g(s)?e.getElementsByTagNameNS(s,t):e.getElementsByTagName(id),attrs(t,e){return!l(e)&&e?(arguments.length>2&&t.setAttribute(e,arguments[2]),t.getAttribute(e)):(e&&z.doseq(e,((e,s)=>t.setAttribute(s,e))),t)},css(t,e){return!l(e)&&e?(arguments.length>2&&(t.style[e]=arguments[2]),t.style[e]):(e&&z.doseq(e,((e,s)=>t.style[s]=e)),t)},wrap(t,e){const s=t.parentNode;return e.appendChild(t),s.appendChild(e),e},newElm(t,s,i){const r=e.createElement(t);return this.attrs(r,s),this.css(r,i),r},newTxt(t,s,i){const r=e.createTextNode(t);return this.attrs(r,s),this.css(r,i),r}},P={},D=[];class R{constructor(){this._tree=new Map,this._targets=new Map}sub(t,e,s,i){let r=t[0],n=t[1];return n&&!this._targets.has(n)&&this._targets.set(n,1),z.seq(r).forEach((t=>{if(e||(e=t),g(e)&&(e=(s=s||n)[e]),!e)throw"Error: no callback for sub()";this._tree.has(t)||this._tree.set(t,z.jsMap());let r=this._tree.get(t);n=n||P,!r.has(n)&&r.set(n,[]),r.get(n).push([e,s,i])})),this}pub(t,...e){let s,i,r=t[0],n=t[1]||P;return(n===P||this._targets.has(n))&&z.seq(r).forEach((t=>{i=this._tree.get(t),s=i&&i.get(n),s&&s.forEach((t=>{t[0].apply(t[1],e.concat(t[2]||D))}))})),this}reset(){return this._targets.clear(),this._tree.clear(),this}drop(t){if(this._targets.has(t)){this._targets.delete(t);let e=this._tree.values();for(let s=e.next();!s.done;)s.value.delete(t),s=e.next()}return this}unsub(t,e,s){if(1!=arguments.length||A.vec(t)){let i=t[0],r=t[1]||P;if(r===P||this._targets.has(r)){let t,n;z.seq(i).forEach((i=>{if(t=this._tree.get(i),n=t&&t.get(r),n&&(g(e)&&(e=(s=s||r)[e]),e))for(let t=n.length-1;t>=0;--t)n[t][0]===e&&n[t][1]===s&&n.splice(t,1)}))}}else this.drop(t);return this}}return e?O.dom=C:(delete z.addEvent,delete z.delEvent),O.EventBus=function(){return new R},O.is=A,O.u=z,O}"object"==typeof module&&module.exports?s=require("../tpcl/seedrandom.min"):e=t.document,"object"==typeof module&&module.exports?module.exports=r():t["io/czlab/mcfud/core"]=r}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());const s=360,i=2*Math.PI,r=(Math.PI,Math.floor),{is:n,u:o}=e;const h=t=>t<0?- -t%s:t%s;return{lerp:(t,e,s)=>(1-s)*t+s*e,xmod:(t,e)=>t<0?t- -(e+e*r(-t/e)):t%e,ndiv:(t,e)=>r(t/e),pow:(t,e)=>0==e?1:1==e?t:2==e?t*t:3==e?t*t*t:Math.pow(t,e),pow2(t){let e=2;for(;t>e;)e*=2;return e},clamp:(t,e,s)=>s<t?t:s>e?e:s,sqr:t=>t*t,fuzzyEq:(t,e)=>o.feq(t,e),fuzzyZero:t=>o.feq0(t),radToDeg:t=>h(s*t/i),degToRad:t=>i*h(t)/s,pythag2:(t,e)=>t*t+e*e,pythag:(t,e)=>Math.sqrt(t*t+e*e),wrap:(t,e)=>(t+1)%e,biasGreater:(t,e)=>t>=.95*e+.01*t,remap(t,e,s,i,r,n){const o=(t-e)/(s-e)*(r-i)+i;return n?i<r?this.clamp(i,r,o):this.clamp(r,i,o):o},perlin1D(t,e,s,i,n){let o,h,l,a,c,u,d,f;for(let g=0;g<t;++g){o=0,h=0,l=1;for(let n=0;n<s;++n)a=t>>n,c=r(g/a)*a,u=(c+a)%t,d=(g-c)/a,f=(1-d)*e[r(c)]+d*e[r(u)],h+=l,o+=f*l,l/=i;n[g]=o/h}},perlin2D(t,e,s,i,n,o){let h,l,a,c,u,d,f,g,p,m,y,v;for(let w=0;w<t;++w)for(let x=0;x<e;++x){h=0,l=0,a=1;for(let o=0;o<i;++o)g=t>>o,p=r(w/g)*g,m=r(x/g)*g,y=(p+g)%t,v=(m+g)%e,c=(w-p)/g,u=(x-m)/g,d=(1-c)*s[r(m*t+p)]+c*s[r(m*t+y)],f=(1-c)*s[r(v*t+p)]+c*s[r(v*t+y)],l+=a,h+=(u*(f-d)+d)*a,a/=n;o[x*t+w]=h/l}}}}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/math"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());const{u:s,is:i}=e,r=(t,e)=>s.assert(!i.num(t)&&!i.num(e)&&t&&e,"wanted 2 vecs"),n=(t,e=0,s=0)=>t?[e,s]:{x:e,y:s},o={};class h{constructor(){this.x=0,this.y=0}unit(t){return i.bool(t)&&(t=n(t)),i.vec(t)?(t[0]=this.x,t[1]=this.y):(t.x=this.x,t.y=this.y),t}bind(t){return i.vec(t)?(this.x=t[0],this.y=t[1]):(this.x=t.x,this.y=t.y),this}op(t,e,s){let r=o.take();switch(r.x=this.x,r.y=this.y,t){case"+":i.num(e)&&(r.x+=e),i.num(s)&&(r.y+=s);break;case"-":i.num(e)&&(r.x-=e),i.num(s)&&(r.y-=s);break;case"*":i.num(e)&&(r.x*=e),i.num(s)&&(r.y*=s);break;case"/":i.num(e)&&(r.x/=e),i.num(s)&&(r.y/=s)}return r}"+"(t){return this.op("+",t.x,t.y)}"-"(t){return this.op("-",t.x,t.y)}"*"(t){return this.op("*",t.x,t.y)}"/"(t){return this.op("/",t.x,t.y)}}function l(t,e,s,r,n,o,h){const l=t-n,a=e-o,c=n+(l*s-a*r),u=o+(l*r+a*s);return i.vec(h)?(h[0]=c,h[1]=u):(h.x=c,h.y=u),h}function a(t,e,s,r){let n,h,l=o.take().bind(t);if(i.num(e))h=l.op(s,e,e);else{let t=o.take().bind(e);h=l[s](t),o.drop(t)}return n=h.unit(r?t:i.vec(t)),o.drop(l,h),n}s.inject(o,{take(){return this._pool.pop()},drop(...t){t.forEach((t=>{t.x=0,t.y=0,this._pool.push(t)}))},_pool:s.fill(16,(()=>new h))});return{gx:t=>i.vec(t)?t[0]:t.x,sx(t,e){i.vec[t]?t[0]=e:t.x=e},gy:t=>i.vec(t)?t[1]:t.y,sy(t,e){i.vec[t]?t[1]=e:t.y=e},vec:(t=0,e=0)=>n(!0,t,e),vecXY:(t=0,e=0)=>n(!1,t,e),add(t,e){return s.assert(2==arguments.length)&&a(t,e,"+")},add$(t,e){return s.assert(2==arguments.length)&&a(t,e,"+",!0)},sub(t,e){return s.assert(2==arguments.length)&&a(t,e,"-")},sub$(t,e){return s.assert(2==arguments.length)&&a(t,e,"-",!0)},mul(t,e){return s.assert(2==arguments.length)&&a(t,e,"*")},mul$(t,e){return s.assert(2==arguments.length)&&a(t,e,"*",!0)},div(t,e){return s.assert(2==arguments.length)&&a(t,e,"/")},div$(t,e){return s.assert(2==arguments.length)&&a(t,e,"/",!0)},dot(t,e){r(t,e);let s=o.take().bind(t),i=o.take().bind(e),n=s.x*i.x+s.y*i.y;return o.drop(s,i),n},equals(t,e){let s=o.take().bind(t),i=o.take().bind(e),r=s.x==i.x&&s.y==i.y;return o.drop(s,i),r},vecAB(t,e){r(t,e);let s,n=o.take().bind(t),h=o.take().bind(e),l=o.take();return l.x=h.x-n.x,l.y=h.y-n.y,s=l.unit(i.vec(t)),o.drop(n,h,l),s},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},dist2(t,e){return this.len2(this.sub(e,t))},dist(t,e){return Math.sqrt(this.dist2(t,e))},unit(t){let e,r=this.len(t),n=o.take().bind(t);return s.feq0(r)?(n.x=0,n.y=0):(n.x/=r,n.y/=r),e=n.unit(i.vec(t)),o.drop(n),e},unit$(t){let e,i=this.len(t),r=o.take().bind(t);return s.feq0(i)?(r.x=0,r.y=0):(r.x/=i,r.y/=i),e=r.unit(t),o.drop(r),e},copy(t,e){r(t,e);let s,i=o.take().bind(t),n=o.take().bind(e);return i.x=n.x,i.y=n.y,s=i.unit(t),o.drop(i,n),s},clone(t){let e=o.take().bind(t),s=e.unit(i.vec(t));return o.drop(e),s},set(t,e,s){let r,n=o.take().bind(t);return i.num(e)&&(n.x=e),i.num(s)&&(n.y=s),r=n.unit(t),o.drop(n),r},setX(t,e){return this.set(t,e)},setY(t,e){return this.set(t,null,e)},rot(t,e,s=null){let r,h,a=0,c=0,u=o.take().bind(t);return s&&(h=o.take().bind(s),a=h.x,c=h.y,o.drop(h)),r=l(u.x,u.y,Math.cos(e),Math.sin(e),a,c,n(i.vec(t))),o.drop(u),r},rot$(t,e,s){let i,r,n=0,h=0,a=o.take().bind(t);return s&&(r=o.take().bind(s),n=r.x,h=r.y,o.drop(r)),i=l(a.x,a.y,Math.cos(e),Math.sin(e),n,h,t),o.drop(a),i},cross(t,e){let s;if(i.num(t)){let r=o.take(),n=o.take().bind(e);r.x=-t*n.y,r.y=t*n.x,s=r.unit(i.vec(e)),o.drop(n,r)}else if(i.num(e)){let r=o.take(),n=o.take().bind(t);r.x=e*n.y,r.y=-e*n.x,s=r.unit(i.vec(t)),o.drop(n,r)}else{r(t,e);let i=o.take().bind(t),n=o.take().bind(e);s=i.x*n.y-i.y*n.x,o.drop(i,n)}return s},angle(t,e){return Math.acos(this.dot(t,e)/(this.len(t)*this.len(e)))},normal(t,e=!1){let s,r=o.take(),n=o.take().bind(t);return e?(r.x=-n.y,r.y=n.x):(r.x=n.y,r.y=-n.x),s=r.unit(i.vec(t)),o.drop(n,r),s},normal$(t,e=!1){let s,i=o.take(),r=o.take().bind(t);return e?(i.x=-r.y,i.y=r.x):(i.x=r.y,i.y=-r.x),s=i.unit(t),o.drop(r,i),s},proj_scalar(t,e){return this.dot(t,e)/this.len(e)},proj(t,e){const s=this.unit(e);this.mul$(s,this.dot(t,s));let r=o.take().bind(s),n=r.unit(i.vec(t));return o.drop(r),n},perp(t,e){return this.sub(t,this.proj(t,e))},reflect(t,e){const s=2*this.dot(t,e);return this.sub(t,this.mul(e,s))},flip(t){return this.mul(t,-1)},flip$(t){return this.mul$(t,-1)},translate(t,...e){let s,r,n,h,l=o.take().bind(t);return 1==e.length&&i.vec(e[0])&&!i.num(e[0][0])&&(e=e[0]),n=e.map((t=>(r=o.take().bind(t),s=r["+"](l),h=s.unit(i.vec(t)),o.drop(r,s),h))),o.drop(l),n},clamp$(t,e,s){const i=this.len(t),r=Math.max(e,Math.min(s,i));return i==r?t:this.mul$(this.div$(t,i||1),r)},clamp(t,e,s){const i=this.len(t),r=Math.max(e,Math.min(s,i));return i==r?t:this.mul(this.div(t,i||1),r)}}}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/vec2"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());Math.atan2;const s=Math.cos,i=Math.sin,r=(Math.tan,Math.floor),{u:n,is:o}=e;const h=t=>t%2!=0,l=(t,e,s,i)=>i-1+(s-1)*e,a=(t,e,s)=>({cells:s,dim:[t,e]}),c=(t,e)=>a(t,e,n.fill(t*e,0));return{v4:(t=0,e=0,s=0,i=0)=>[t,e,s,i],v3:(t=0,e=0,s=0)=>[t,e,s],dot:(t,e)=>t[0]*e[0]+t[1]*e[1]+t[2]*e[2],cross(t,e){return this.v3(t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0])},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},unit(t){let e=this.len(t);if(!n.feq0(e))return[t[0]/e,t[1]/e,t[2]/e]},sub(t,e){return o.num(e)?this.v3(t[0]-e,t[1]-e,t[2]-e):this.v3(t[0]-e[0],t[1]-e[1],t[2]-e[2])},add(t,e){return o.num(e)?this.v3(t[0]+e,t[1]+e,t[2]+e):this.v3(t[0]+e[0],t[1]+e[1],t[2]+e[2])},mul(t,e){return o.num(e)?this.v3(t[0]*e,t[1]*e,t[2]*e):this.v3(t[0]*e[0],t[1]*e[1],t[2]*e[2])},div(t,e){return o.num(e)?this.v3(t[0]/e,t[1]/e,t[2]/e):this.v3(t[0]/e[0],t[1]/e[1],t[2]/e[2])},matrix([t,e],...s){const i=t*e;return 0==s.length?c(t,e):n.assert(i==s.length)&&a(t,e,s)},matCell(t,e,s,i){const r=l(t.dim[0],t.dim[1],e,s);if(r>=0&&r<t.cells.length)return o.num(i)?(t.cells[r]=i,t):t.cells[r]},matIdentity(t){const e=n.assert(t>0)&&n.fill(t*t,0);for(let s=0;s<t;++s)e[l(0,t,s+1,s+1)]=1;return a(t,t,e)},matZero:t=>n.assert(t>0)&&a(t,t,n.fill(t*t,0)),matRowMajors(t){const[e,s]=t.dim;return n.partition(s,t.cells)},matColMajors(t){const[e,s]=t.dim,i=[];for(let r,n=0;n<s;++n){r=[];for(let i=0;i<e;++i)r.push(t.cells[i*s+n]);i.push(r)}return i},mat2(t,e,s,i){return this.matrix([2,2],t,e,s,i)},mat3(t,e,s,i,r,n,o,h,l){return this.matrix([3,3],t,e,s,i,r,n,o,h,l)},mat4(t,e,s,i,r,n,o,h,l,a,c,u,d,f,g,p){return this.matrix([4,4],t,e,s,i,r,n,o,h,l,a,c,u,d,f,g,p)},matEq(t,e){return t.dim[0]==e.dim[0]&&t.dim[1]==e.dim[1]&&(s=t.cells,i=e.cells,s.length==i.length&&s.every(((t,e)=>t==i[e]||n.feq(t,i[e]))));var s,i},matXpose(t){const[e,s]=t.dim,i=e*s,n=[];for(let o=0;o<i;++o)n.push(t.cells[r(o/e)+s*(o%e)]);return a(s,e,n)},matScale:(t,e)=>a(t.dim[0],t.dim[1],t.cells.map((t=>t*e))),matMult(t,e){let[s,i]=t.dim,[r,o]=e.dim,h=t.cells,l=e.cells;n.assert(i==r,"mismatch matrices");let c=new Array(s*o);for(let t=0;t<s;++t)for(let e=0;e<o;++e)c[e+t*o]=n.range(r).reduce(((s,r)=>s+h[r+t*i]*l[e+r*o]),0);return a(s,o,c)},matDet(t){let[e,s]=t.dim,i=[];if(2==s)return this._matDet2x2(t);for(let e=0;e<s;++e)n.conj(i,this.matDet(this.matCut(t,1,e+1)));return n.range(s).reduce(((e,s)=>{let r=i[s];return e+t.cells[s]*(h(s)?-r:r)}),0)},_matDet2x2:t=>(n.assert(4===t.cells.length),t.cells[0]*t.cells[3]-t.cells[1]*t.cells[2]),matCut(t,e,s){const[i,r]=t.dim;let o=e-1,h=s-1,l=[];for(let e=0;e<i;++e)for(let s=0;s<r;++s)e!=o&&s!=h&&n.conj(l,t.cells[s+e*r]);return a(i-1,r-1,l)},matMinor(t){const[e,s]=t.dim;let i=[];if(n.assert(e==s),2==s)return this._matMinor2x2(t);for(let r=0;r<e;++r)for(let e=0;e<s;++e)n.conj(i,this.matDet(this.matCut(t,r+1,e+1)));return a(e,s,i)},_matMinor2x2(t){return n.assert(4==t.cells.length)&&this.mat2(t.cells[3],t.cells[2],t.cells[1],t.cells[0])},matCofactor(t){const e=this.matMinor(t),[s,i]=e.dim;let r=e.cells.slice();for(let t=0;t<s;++t)for(let e,s=0;s<i;++s)e=t*i+s,h(t+s)&&(r[e]=-r[e]);return a(s,i,r)},matAdjugate(t){return this.matXpose(this.matCofactor(t))},_minv2x2(t){const[e,s]=t.dim;n.assert(4==t.cells.length&&2==e&&2==s);let i,r=t.cells,o=r[0]*r[3]-r[1]*r[2];if(n.feq0(o))i=this.matIdentity(e);else{let t=1/o;i=this.mat2(r[3]*t,-r[1]*t,-r[2]*t,r[0]*t)}return i},matInv(t){const[e,s]=t.dim;if(2==s)return this._minv2x2(t);let i=this.matDet(t);return n.feq0(i)?this.matIdentity(e):this.matScale(this.matAdjugate(t),1/i)},matFromColMajor(t){let e=t.length,s=t[0].length,i=c(s,e);for(let s,r=0;r<t.length;++r){s=t[r];for(let t=0;t<s.length;++t)i.cells[t*e+r]=s[t]}return i},matToColMajor(t){const[e,s]=t.dim,i=[];t.cells.slice();for(let r,n=0;n<s;++n){r=[];for(let i=0;i<e;++i)r.push(t.cells[i*s+n]);i.push(r)}return i},scale3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,1,1)]=t[0],e.cells[l(0,4,2,2)]=t[1],e.cells[l(0,4,3,3)]=t[2],e},translate3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,4,1)]=t[0],e.cells[l(0,4,4,2)]=t[1],e.cells[l(0,4,4,3)]=t[2],e},rot3D(t,e,s){return this.matMult(this.zRot3D(s),this.matMult(this.yRot3D(e),this.xRot3D(t)))},matVMult(t,e){let s=t.dim[1],i=e.length;n.assert(s==i);let r=this.matMult(t,a(i,1,e)),o=r.cells;return r.cells=null,o},rot2D(t){return this.mat2(s(t),-i(t),i(t),s(t))},xRot3D(t){return this.mat4(1,0,0,0,0,s(t),-i(t),0,0,i(t),s(t),0,0,0,0,1)},yRot3D(t){return this.mat4(s(t),0,i(t),0,0,1,0,0,-i(t),0,s(t),0,0,0,0,1)},zRot3D(t){return this.mat4(s(t),-i(t),0,0,i(t),s(t),0,0,0,0,1,0,0,0,0,1)},isIdentity(t){const[e,s]=t.dim;if(e==s){for(let i,r=0;r<e;++r)for(let e=0;e<s;++e)if(i=t.cells[r*s+e],r+1==e+1){if(1!=i)return!1}else if(0!=i)return!1;return!0}return!1},isOrthogonal(t){let e=this.matDet(t);return 1==Math.abs(e)&&this.isIdentity(this.matMult(this.matXpose(t),this.matInv(t)))}}}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/matrix"]=s}(this),function(t,e){"use strict";const s=" @N/\\Ri2}aP`(xeT4F3mt;8~%r0v:L5$+Z{'V)\"CKIc>z.*fJEwSU7juYg<klO&1?[h9=n,yoQGsW]BMHpXb6A|D#q^_d!-".split(""),i=s.length;function r(e){e||(e=t["io/czlab/mcfud/core"]());const{u:r}=e,n=t=>Math.abs(t)%i,o=t=>s[t],h=t=>s.findIndex((e=>e==t));function l(t,e){let s=e+t;return o(s>=i?s-i:s)}function a(t,e){let s=e-t;return o(s<0?i+s:s)}return{encrypt(t,e){if(0!=e){let s,i=n(e);s=t.split("").map((t=>(s=h(t),s<0?t:((t,e,s)=>t<0?l(e,s):a(e,s))(e,i,s)))),t=s.join("")}return t},decrypt(t,e){if(0!=e){let s,i=n(e);s=t.split("").map((t=>(s=h(t),s<0?t:((t,e,s)=>t<0?a(e,s):l(e,s))(e,i,s)))),t=s.join("")}return t}}}"object"==typeof module&&module.exports?module.exports=r(require("./core")):t["io/czlab/mcfud/crypt"]=r}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());return{fsm(t){let e=t.initState();return{state:()=>e,process(){const s=t[e];s&&s.run&&s.run()},trigger(s="change",i){const r=t[e],n=r&&r.transitions[s];if(n){const s=n.target,o=t[s];if(o)return r.exit&&r.exit(),o.enter&&o.enter(),i&&i.action?i.action():n.action&&n.action(i),e=s}}}}}}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/fsm"]=s}(this),function(t,e){"use strict";function s(e,s,i,r){e||(e=t["io/czlab/mcfud/core"]()),s||(s=t["io/czlab/mcfud/vec2"]()),i||(i=t["io/czlab/mcfud/math"]()),r||(r=t["io/czlab/mcfud/matrix"]());const n=2*Math.PI,{u:o}=e;return{setContextTransform:(t,e,s=!1)=>(t[s?"setTransform":"transform"](e.cells[0],e.cells[3],e.cells[1],e.cells[4],e.cells[2],e.cells[5]),t),textStyle:(t,e,s,i,r,n)=>(e&&(t.font=e),i&&(t.fillStyle=i),r&&(t.textAlign=r),n&&(t.textBaseline=n),s&&(t.strokeStyle=s),t),drawShape:(t,e,...s)=>(e&&e.draw&&e.draw(t,...s),t),cfgStyle:(t,e,s,i,r)=>(s&&(t.fillStyle=s),e&&(t.strokeStyle=e),r&&(t.lineCap=r),i&&(t.lineWidth=i),t),drawPoints(t,e){t.beginPath();for(let i,r,n,o=e.length,h=0;h<o;++h)n=(h+1)%o,i=e[h],r=e[n],t.moveTo(s.gx(i),s.gy(i)),t.lineTo(s.gx(r),s.gy(r));return t.closePath(),t.stroke(),t},fillPoints(t,e){t.beginPath();for(let i,r,n,o=e.length,h=0;h<o;++h)n=(h+1)%o,i=e[h],r=e[n],0==h?t.moveTo(s.gx(i),s.gy(i)):t.lineTo(s.gx(i),s.gy(i)),t.lineTo(s.gx(r),s.gy(r));return t.closePath(),t.fill(),t},drawCircle:(t,e,s,i)=>(t.beginPath(),t.arc(e,s,i,0,n,!0),t.closePath(),t.stroke(),t),fillCircle:(t,e,s,i)=>(t.beginPath(),t.arc(e,s,i,0,n,!0),t.closePath(),t.fill(),t),drawRect:(t,e,s,i,r,n=0,o=0,h=0)=>(t.save(),t.translate(o,h),t.rotate(n),t.translate(-o,-h),t.strokeRect(e,s,i,r),t.restore(),t),fillRect:(t,e,s,i,r,n=0,o=0,h=0)=>(t.save(),t.translate(o,h),t.rotate(n),t.translate(-o,-h),t.fillRect(e,s,i,r),t.restore(),t),drawLine:(t,e,s,i,r)=>(t.beginPath(),t.moveTo(e,s),t.lineTo(i,r),t.stroke(),t),drawText:(t,e,s,i)=>(t.strokeText(e,s,i),t),fillText:(t,e,s,i)=>(t.fillText(e,s,i),t),clearCanvas(t){return this.clearRect(t,0,0,t.canvas.width,t.canvas.height)},fillCanvas(t){return this.fillRect(t,0,0,t.canvas.width,t.canvas.height)},clearRect:(t,e,s,i,r)=>(t.clearRect(e,s,i,r),t)}}"object"==typeof module&&module.exports?module.exports=s(require("./core"),require("./vec2"),require("./math"),require("./matrix")):t["io/czlab/mcfud/gfx"]=s}(this),function(t,e){"use strict";const[s,i,r]=[1,0,-1];function n(e,n,o,h,l){e||(e=t["io/czlab/mcfud/core"]()),n||(n=t["io/czlab/mcfud/math"]()),o||(o=t["io/czlab/mcfud/vec2"]()),h||(h=t["io/czlab/mcfud/matrix"]()),l||(l=t["io/czlab/mcfud/algo/basic"]());const{Stack:a,StdCompare:c}=l,{is:u,u:d}=(Math.floor,e);const f=d.fill(36,undefined);function g(t){d.assert(t.length>2&&t.length<=36,"too little/many vertices");let e=0,s=t[0][0];for(let i,r=1;r<t.length;++r)i=t[r][0],i>s?(s=i,e=r):d.feq(i,s)&&t[r][1]<t[e][1]&&(e=r);let i=0,r=e;for(;;){f[i]=r;let s=0,n=f[i];for(let e,i,h,l=1;l<t.length;++l)s!=r?(e=o.sub(t[s],t[n]),i=o.sub(t[l],t[n]),h=o.cross(e,i),h<0&&(s=l),d.feq0(h)&&o.len2(i)>o.len2(e)&&(s=l)):s=l;if(r=s,++i,s==e)break}const n=[];for(let e=0;e<i;++e)n.push(o.clone(t[f[e]]));return n}class p{constructor(t,e,s,i){switch(arguments.length){case 2:this.pos=o.vec(),this.width=t,this.height=e;break;case 4:this.pos=o.vec(t,e),this.width=s,this.height=i;break;default:throw"Error: bad input to Rect()"}}}class m{constructor(t,e){this.width=t,this.height=e}half(){return new m(n.ndiv(this.width,2),n.ndiv(this.height,2))}}class v{constructor(t,e,s,i){this.p=o.vec(t,e),this.q=o.vec(s,i)}}class w{constructor(t,e=0,s=0){this.pos=o.vec(e,s),this.shape=t}}class _{constructor(){this.orient=0}setOrient(t){throw Error("no implementation")}}class N extends _{constructor(t){super(),this.calcPoints=[],this.normals=[],this.edges=[],this.set(t||[])}set(t){return this.calcPoints.length=0,this.normals.length=0,this.edges.length=0,this.points=g(t),this.points.forEach((t=>{this.calcPoints.push(o.vec()),this.edges.push(o.vec()),this.normals.push(o.vec())})),this._recalc()}setOrient(t){return this.orient=t,this._recalc()}moveBy(t,e){return this.points.forEach((s=>{s[0]+=t,s[1]+=e})),this._recalc()}_recalc(){let t=this.points.length;return this.points.forEach(((t,e)=>{o.copy(this.calcPoints[e],t),d.feq0(this.orient)||o.rot$(this.calcPoints[e],this.orient)})),this.points.forEach(((e,s)=>{this.edges[s]=o.sub(this.calcPoints[(s+1)%t],this.calcPoints[s]),this.normals[s]=o.unit(o.normal(this.edges[s]))})),this}}class b{constructor(t,e){this.overlapN=o.vec(),this.overlapV=o.vec(),this.A=t,this.B=e,this.clear()}swap(){let t=new b,e=this.AInB,s=this.BInA,i=this.A;return t.overlap=this.overlap,t.A=this.B,t.B=i,t.AInB=s,t.BInA=e,t.overlapN=o.flip(this.overlapN),t.overlapV=o.flip(this.overlapV),t}clear(){return this.overlap=1/0,this.AInB=!0,this.BInA=!0,this}}function k(t,e){let s=1/0,i=-1/0;for(let r,n=0;n<t.length;++n)r=o.dot(t[n],e),r<s&&(s=r),r>i&&(i=r);return[s,i]}function E(t,e){let n=o.len2(t),h=o.dot(e,t);return h<0?s:h>n?r:i}function M(t,e,s,i,r,n){let[h,l]=k(e,r),[a,c]=k(i,r),u=o.vecAB(t,s),d=o.dot(u,r);if(a+=d,c+=d,h>c||a>l)return!0;if(n){let t=0;if(h<a)if(n.AInB=!1,l<c)t=l-a,n.BInA=!1;else{let[e,s]=[l-a,c-h];t=e<s?e:-s}else if(n.BInA=!1,l>c)t=h-c,n.AInB=!1;else{let[e,s]=[l-a,c-h];t=e<s?e:-s}let e=Math.abs(t);e<n.overlap&&(n.overlap=e,o.copy(n.overlapN,r),t<0&&o.flip$(n.overlapN))}}function T(t,e,s){let i,r=t.shape.radius+e.shape.radius,n=o.vecAB(t.pos,e.pos),h=o.len2(n),l=!(h>r*r);return l&&s&&(i=Math.sqrt(h),s.A=t,s.B=e,s.overlap=r-i,o.copy(s.overlapN,o.unit$(n)),o.copy(s.overlapV,o.mul(n,s.overlap)),s.AInB=t.shape.radius<=e.shape.radius&&i<=e.shape.radius-t.shape.radius,s.BInA=e.shape.radius<=t.shape.radius&&i<=t.shape.radius-e.shape.radius),l}function S(t,e,i){let n,h=e.shape.radius*e.shape.radius,l=o.vecAB(t.pos,e.pos),a=t.shape.calcPoints,c=o.vec();for(let u,d,f,g,p=a.length,m=0;m<p;++m){u=m==p-1?0:m+1,d=0==m?p-1:m-1,f=0,g=null,o.copy(c,t.shape.edges[m]),n=o.vecAB(a[m],l),i&&o.len2(n)>h&&(i.AInB=!1);let y=E(c,n);if(y===s){if(o.copy(c,t.shape.edges[d]),y=E(c,o.vecAB(a[d],l)),y===r){let t=o.len(n);if(t>e.shape.radius)return!1;i&&(i.BInA=!1,g=o.unit(n),f=e.shape.radius-t)}}else if(y===r){if(o.copy(c,t.shape.edges[u]),o.sub$(o.copy(n,l),a[u]),y=E(c,n),y===s){let t=o.len(n);if(t>e.shape.radius)return!1;i&&(i.BInA=!1,g=o.unit(n),f=e.shape.radius-t)}}else{let t=o.unit$(o.normal(c)),s=o.dot(n,t),r=Math.abs(s);if(s>0&&r>e.shape.radius)return!1;i&&(g=t,f=e.shape.radius-s,(s>=0||f<2*e.shape.radius)&&(i.BInA=!1))}g&&i&&Math.abs(f)<Math.abs(i.overlap)&&(i.overlap=f,o.copy(i.overlapN,g))}return i&&(i.A=t,i.B=e,o.mul$(o.copy(i.overlapV,i.overlapN),i.overlap)),!0}function q(t,e,s){let i=S(e,t,s);if(i&&s){let t=s.A,e=s.AInB;o.flip$(s.overlapN),o.flip$(s.overlapV),s.A=s.B,s.B=t,s.AInB=s.BInA,s.BInA=e}return i}function I(t,e,s){let i=t.shape.calcPoints,r=e.shape.calcPoints;for(let n=0;n<i.length;++n)if(M(t.pos,i,e.pos,r,t.shape.normals[n],s))return!1;for(let n=0;n<r.length;++n)if(M(t.pos,i,e.pos,r,e.shape.normals[n],s))return!1;if(s){if(0==s.overlap||d.feq0(s.overlap))return!1;s.A=t,s.B=e,o.copy(s.overlapV,s.overlapN),o.mul$(s.overlapV,s.overlap)}return!0}class O{static create(){return new O}constructor(){this.identity()}identity(){return this.m=h.matIdentity(3),this}translate(t,e){return this.m=h.matMult(this.m,h.mat3(1,0,t,0,1,e,0,0,1)),this}scale(t,e){return this.m=h.matMult(this.m,h.mat3(t,0,0,0,e,0,0,0,1)),this}shear(t,e){return this.m=h.matMult(this.m,h.mat3(1,t,0,e,1,0,0,0,1)),this}rotateCCW(t,e,s){let i=Math.sin(t),r=Math.cos(t);return void 0!==e&&void 0!==s?(this.translate(-e,-s),this.rotateCCW(t),this.translate(e,s)):this.m=h.matMult(this.m,h.mat3(r,-i,0,i,r,0,0,0,1)),this}rotateCW(t,e,s){let i=Math.sin(t),r=Math.cos(t);return void 0!==e&&void 0!==s?(this.translate(-e,-s),this.rotateCW(t),this.translate(e,s)):this.m=h.matMult(this.m,h.mat3(r,i,0,-i,r,0,0,0,1)),this}transformXY(t,e){let s=[t,e,1];return h.matVMult(this.m,s).length=2,2}transformPoints(t){let e,s=[0,0,1];t.forEach((t=>{u.vec(t)?(s[0]=t[0],s[1]=t[1]):(s[0]=t.x,s[1]=t.y),e=h.matVMult(this.m,s),u.vec(t)?(t[0]=e[0],t[1]=e[1]):(t.x=e[0],t.y=e[1])}))}}class A{constructor(t,e){if(e<t){let s=t;t=e,e=s}d.feq0(t)&&(t=0),d.feq0(e)&&(e=0),this.min=t,this.max=e}min(){return this.min}max(){return this.max}intersects(t){return!(this.max<t.min||t.max<this.min)}contains(t){return this.min<=t&&t<=this.max}length(){return this.max-this.min}static MinEndPtCmp(t,e){return t.min<e.min?-1:t.min>e.min?1:t.max<e.max?-1:t.max>e.max?1:0}static MaxEndPtCmp(t,e){return t.max<e.max?-1:t.max>e.max?1:t.min<e.min?-1:t.min>e.min?1:0}static LenCmp(t,e){let s=t.length(),i=e.length();return s<i?-1:s>i?1:0}static test(){let t=[new A(15,33),new A(45,60),new A(20,70),new A(46,55)];console.log("Unsorted"),t.forEach((t=>console.log(`min=${t.min}, max=${t.max}`))),console.log("Sort by min endpoint"),t.sort(A.MinEndPtCmp),t.forEach((t=>console.log(`min=${t.min}, max=${t.max}`))),console.log("Sort by max endpoint"),t.sort(A.MaxEndPtCmp),t.forEach((t=>console.log(`min=${t.min}, max=${t.max}`))),console.log("Sort by length"),t.sort(A.LenCmp),t.forEach((t=>console.log(`min=${t.min}, max=${t.max}`)))}}class z{static theta(t){return Math.atan2(t[1],t[0])}static angleBetween(t,e){return Math.atan2(e[1]-t[1],e[0]-t[0])}static ccw(t,e,s){let i=(e[0]-t[0])*(s[1]-t[1])-(e[1]-t[1])*(s[0]-t[0]);return i<0?-1:i>0?1:0}static area2(t,e,s){return(e[0]-t[0])*(s[1]-t[1])-(e[1]-t[1])*(s[0]-t[0])}static distTo(t,e){let s=t[0]-e[0],i=t[1]-e[1];return Math.sqrt(s*s+i*i)}static distSqTo(t,e){let s=t[0]-e[0],i=t[1]-e[1];return s*s+i*i}static compareTo(t,e){return t[1]<e[1]?-1:t[1]>e[1]?1:t[0]<e[0]?-1:t[0]>e[0]?1:0}static XOrderCmp(t,e){return t[0]<e[0]?-1:t[0]>e[0]?1:0}static YOrderCmp(t,e){return t[1]<e[1]?-1:t[1]>e[1]?1:0}static ROrderCmp(t,e){let s=t[0]*t[0]+t[1]*t[1]-(e[0]*e[0]+e[1]*e[1]);return s<0?-1:s>0?1:0}static PolarOrderCmp(t){return(e,s)=>{let i=e[0]-t[0],r=e[1]-t[1],n=s[0]-t[0],o=s[1]-t[1];return r>=0&&o<0?-1:o>=0&&r<0?1:d.feq0(r)&&d.feq0(o)?i>=0&&n<0?-1:n>=0&&i<0?1:0:-z.ccw(t,e,s)}}static DistToOrderCmp(t,e){let s=z.distSqTo(t),i=z.distSqTo(e);return s<i?-1:s>i?1:0}static equals(t,e){return e===t||!!e&&(t[0]==e[0]&&t[1]==e[1])}static farthestPair(t){let e,s=[0,0],i=[0,0],r=0,n=-1/0,h=z.calcConvexHull(t);if(!1===h||t.length<=1)return!1;if(e=h.length,h.unshift(null),2==e)s=h[1],i=h[2],r=z.distTo(s,i);else{let t,r=2;for(;z.area2(h[e],h[1],h[r+1])>z.area2(h[e],h[1],h[r]);)++r;t=r;for(let l,a=1;a<=r&&t<=e;++a)for(z.distSqTo(h[a],h[t])>n&&(n=z.distSqTo(h[a],h[t]),o.copy(s,h[a]),o.copy(i,h[t]));t<e&&z.area2(h[a],h[a+1],h[t+1])>z.area2(h[a],h[a+1],h[t]);)++t,l=z.distSqTo(h[a],h[t]),l>n&&(n=z.distSqTo(h[a],h[t]),o.copy(s,h[a]),o.copy(i,h[t]))}return{best1:s,best2:i,bestDistance:Math.sqrt(n)}}static closestPair(t){let e=[0,0],s=[0,0],i=1/0,r=t.slice();const h=t.length;r.sort(z.YOrderCmp),r.sort(z.XOrderCmp);for(let t=0;t<h-1;++t)if(z.equals(r[t],r[t+1]))return o.copy(e,r[t]),o.copy(s,r[t+1]),{bestDistance:0,best1:e,best2:s};let l=r.slice();return function t(r,h,l,a,c){if(c<=a)return 1/0;let u=a+n.ndiv(c-a,2),d=r[u],f=t(r,h,l,a,u),g=t(r,h,l,u+1,c),p=Math.min(f,g);!function(t,e,s,i,r){for(let i=s;i<=r;++i)o.copy(e[i],t[i]);let n=s,h=i+1;for(let l=s;l<=r;++l)n>i?o.copy(t[l],e[h++]):h>r?o.copy(t[l],e[n++]):z.compareTo(e[h],e[n])<0?o.copy(t[l],e[h++]):o.copy(t[l],e[n++])}(h,l,a,u,c);let m=0;for(let t=a;t<=c;++t)Math.abs(h[t][0]-d[0])<p&&o.copy(l[m++],h[t]);for(let t=0;t<m;++t)for(let r,n=t+1;n<m&&l[n][1]-l[t][1]<p;++n)r=z.distTo(l[t],l[n]),r<p&&(p=r,r<i&&(i=p,o.copy(e,l[t]),o.copy(s,l[n])));return p}(r,l,d.fill(h,(()=>[0,0])),0,h-1),{bestDistance:i,best1:e,best2:s}}static calcConvexHull(t){d.assert(t&&t.length>0,"invalid points");let e,s,i,r=t.length,n=d.deepCopyArray(t),h=new a;for(n.sort(z.compareTo),e=n[0],n.shift(),n.sort(z.PolarOrderCmp(e)),n.unshift(e),h.push(n[0]),s=1;s<r&&z.equals(n[0],n[s]);++s);if(s==r)return!1;for(i=s+1;i<r&&0==z.ccw(n[0],n[s],n[i]);++i);h.push(n[i-1]);for(let t,e=i;e<r;++e){for(t=h.pop();z.ccw(h.peek(),t,n[e])<=0;)t=h.pop();h.push(t),h.push(n[e])}let l=new a;for(let t=h.iterator();t.hasNext();)l.push(t.next());r=l.size(),t=[];for(let e=l.iterator();e.hasNext();)t.push(o.clone(e.next()));if(r>2)for(let e=0;e<r;++e)if(z.ccw(t[e],t[(e+1)%r],t[(e+2)%r])<=0)return!1;return t}static test_convexHull(){let t="9230 13137 4096 24064 8192 26112 22016  9344 4440  8028 6505 31422 28462 32343 17152 19200 9561 11599\n               4096 20992 21538  2430 21903 23677 17152 16128 7168 25088 10162 18638 822 32301 16128 12032 18989  3797\n               8192 28160 16128 20224 14080 20224 26112  7296 20367 20436 7486   422 17835  2689 22016  3200 22016  5248\n               24650 16886 15104 20224 25866  4204 13056 15104 13662 10301 17152 20224 15104 12032 6144 20992 26112  3200\n               6144 29184 13056 12032 8128 20992 5076 19172 17152 17152 823 15895 25216  3200 6071 29161 5120 20992\n               10324 22176 29900  9390 27424  7945 4096 23040 12831 27971 29860 12437 28668  2061 1429 12561 29413   596\n               17152 18176 8192 27136 5120 29184 22016 11392 1444 10362 32011  3140 15731 32661 26112  4224 13120 20224\n               30950  2616 4096 22016 4096 25088 24064  3200 26112  5248 4862 30650 5570  8885 21784 18853 23164 32371\n               4160 29184 13056 13056 8192 29184 23040  7296 5120 25088 22016  7296 7168 29184 25216  7296 23040  3200\n               4718  4451 14080 16128 7168 20992 19546 17728 13056 16128 17947 17017 26112  6272 20658  1204 23553 13965\n               13056 14080 14080 12032 24064  7296 21377 26361 17088\n               12032 16128 16128 30875 28560 2542 26201 8192 25088 11444 16973".split(/\s+/).map((t=>+t)),e=[];for(let s=0;s<t.length;s+=2)e.push([t[s],t[s+1]]);e=[[5,15],[5,-20],[-60,10],[70,-10],[-60,-10],[70,10]];let s=z.calcConvexHull(e);!1===s||s.length!=e.length?console.log("not convex!"):s.forEach((t=>{console.log(`${t[0]}, ${t[1]}`)}))}static test_closestPair(){let t="954 11163 1125 11331 1296 11499 1467 11667 1657 11796 1847 11925 2037 12054 2238 12207 2439 12360\n               2640 12513 2878 12523 3116 12533 3354 12543 3518 12493 3682 12443 3846 12393\n               8463 7794 8022 7527 7581 7260 7140 6993 6731 6624 6322 6255 5913 5886\n               5521 5494 5129 5102 4737 4710 4599 5158".split(/\s+/).map((t=>+t)),e=[];for(let s=0;s<t.length;s+=2)e.push([t[s],t[s+1]]);let{bestDistance:s,best1:i,best2:r}=z.closestPair(e);console.log(`bestDist=${s}, p1=${i}, p2=${r}`)}static test_farthestPair(){let t="9230 13137 4096 24064 8192 26112 22016  9344 4440  8028 6505 31422 28462 32343 17152 19200 9561 11599 4096 20992 21538  2430\n               21903 23677 17152 16128 7168 25088 10162 18638 822 32301 16128 12032 18989  3797 8192 28160 16128 20224 14080 20224 26112  7296\n               20367 20436 7486   422 17835  2689 22016  3200 22016  5248 24650 16886 15104 20224 25866  4204 13056 15104 13662 10301 17152 20224\n               15104 12032 6144 20992 26112  3200 6144 29184 13056 12032 8128 20992 5076 19172 17152 17152 823 15895 25216  3200 6071 29161\n               5120 20992 10324 22176 29900  9390 27424  7945 4096 23040 12831 27971 29860 12437 28668  2061 1429 12561 29413   596 17152 18176\n               8192 27136 5120 29184 22016 11392 1444 10362 32011  3140 15731 32661 26112  4224 13120 20224 30950  2616 4096 22016\n               4096 25088 24064  3200 26112  5248 4862 30650 5570  8885 21784 18853 23164 32371 4160 29184 13056 13056 8192 29184 23040  7296\n               5120 25088 22016  7296 7168 29184 25216  7296 23040  3200 4718  4451 14080 16128 7168 20992 19546 17728 13056 16128 17947 17017\n               26112  6272 20658  1204 23553 13965 13056 14080 14080 12032 24064  7296 21377 26361 17088 12032 16128 16128\n               30875 28560 2542 26201 8192 25088 11444 16973".split(/\s+/).map((t=>+t)),e=[];for(let s=0;s<t.length;s+=2)e.push([t[s],t[s+1]]);let{bestDistance:s,best1:i,best2:r}=z.farthestPair(e);console.log(`bestDist=${s}, p1=${i}, p2=${r}`)}}return{Rect:p,Area:m,Line:v,Body:w,Circle:class extends _{constructor(t){super(),this.radius=t}setOrient(t){return this.orient=t,this}},Polygon:N,Manifold:b,C2DMatrix:O,Point2D:z,Interval1D:A,Interval2D:class{constructor(t,e){this.x=t,this.y=e}intersects(t){return!!this.x.intersects(t.x)&&!!this.y.intersects(t.y)}contains(t){return x.contains(t[0])&&y.contains(t[1])}area(){return x.length()*y.length()}},bodyWrap:(t,e,s)=>new w(t,e,s),orderVertices:t=>g(t),polyArea(t,e=!1){let s=e?this.orderVertices(t):t,i=0;for(let t,e,r,n=s.length,o=0;o<n;++o)r=(o+1)%n,t=s[o],e=s[r],i+=t[0]*e[1]-e[0]*t[1];return n.ndiv(Math.abs(i),2)},calcPolygonCenter(t,e=!1){const s=e?this.orderVertices(t):t,i=6*this.polyArea(s);let r=0,h=0;for(let t,e,i,n=0,o=s.length;n<o;++n)i=(n+1)%o,t=s[n],e=s[i],r+=(t[0]+e[0])*(t[0]*e[1]-e[0]*t[1]),h+=(t[1]+e[1])*(t[0]*e[1]-e[0]*t[1]);return o.vec(n.ndiv(r,i),n.ndiv(h,i))},getAABB(t){if(d.assert(t instanceof w,"wanted a body"),d.has(t.shape,"radius"))return new p(t.pos[0]-t.shape.radius,t.pos[1]-t.shape.radius,2*t.shape.radius,2*t.shape.radius);{let e=o.translate(t.pos,t.shape.calcPoints),s=e[0][0],i=e[0][1],r=s,n=i;for(let t,o=1;o<e.length;++o)t=e[o],t[0]<s&&(s=t[0]),t[0]>r&&(r=t[0]),t[1]<i&&(i=t[1]),t[1]>n&&(n=t[1]);return new p(s,i,r-s,n-i)}},shiftPoints:(t,e)=>t.map((t=>o.add(t,e))),rotPoints:(t,e,s)=>t.map((t=>o.rot(t,e,s))),calcRectPoints(t,e){const s=t/2,i=e/2;return[o.vec(s,-i),o.vec(s,i),o.vec(-s,i),o.vec(-s,-i)]},line:(t,e,s,i)=>new v(t,e,s,i),rectEqRect:(t,e)=>t.width==e.width&&t.height==e.height&&t.pos[0]==e.pos[0]&&t.pos[1]==e.pos[1],rectContainsRect:(t,e)=>!(t.pos[0]>=e.pos[0]||t.pos[1]>=e.pos[1]||t.pos[0]+t.width<=e.pos[0]+e.width||t.pos[1]+t.height<=e.pos[1]+e.height),rectGetMaxX:t=>t.pos[0]+t.width,rectGetMidX:t=>t.pos[0]+t.width/2,rectGetMinX:t=>t.pos[0],rectGetMaxY:t=>t.pos[1]+t.height,rectGetMidY:t=>t.pos[1]+t.height/2,rectGetMinY:t=>t.pos[1],rectContainsPoint(t,e,s){return e>=this.rectGetMinX(t)&&e<=this.rectGetMaxX(t)&&s>=this.rectGetMinY(t)&&s<=this.rectGetMaxY(t)},rectOverlayRect:(t,e)=>!(t.pos[0]+t.width<e.pos[0]||e.pos[0]+e.width<t.pos[0]||t.pos[1]+t.height<e.pos[1]||e.pos[1]+e.height<t.pos[1]),rectUnion(t,e){const s=Math.min(t.pos[0],e.pos[0]),i=Math.min(t.pos[1],e.pos[1]);return new p(s,i,Math.max(t.pos[0]+t.width,e.pos[0]+e.width)-s,Math.max(t.pos[1]+t.height,e.pos[1]+e.height)-i)},rectIntersection(t,e){if(this.rectOverlayRect(t,e)){const s=Math.max(t.pos[0],e.pos[0]),i=Math.max(t.pos[1],e.pos[1]);return new p(s,i,Math.min(t.pos[0]+t.width,e.pos[0]+e.width)-s,Math.min(t.pos[1]+t.height,e.pos[1]+e.height)-i)}},hitTestPointCircle(t,e,s){d.assert(s instanceof w,"wanted a body");let i=t-s.pos[0],r=e-s.pos[1];return i*i+r*r<=s.shape.radius*s.shape.radius},hitCircleCircle(t,e){d.assert(t instanceof w&&e instanceof w,"need bodies");let s=new b;if(T(t,e,s))return s},hitTestCircleCircle:(t,e)=>(d.assert(t instanceof w&&e instanceof w,"need bodies"),T(t,e,new b)),hitPolygonCircle(t,e){d.assert(t instanceof w&&e instanceof w,"need bodies");let s=new b;if(S(t,e,s))return s},hitTestPolygonCircle:(t,e)=>(d.assert(t instanceof w&&e instanceof w,"need bodies"),S(t,e,new b)),hitCirclePolygon(t,e){d.assert(e instanceof w&&t instanceof w,"need bodies");let s=new b;if(q(t,e,s))return s},hitTestCirclePolygon:(t,e)=>(d.assert(e instanceof w&&t instanceof w,"need bodies"),q(t,e,new b)),hitPolygonPolygon(t,e){d.assert(t instanceof w&&e instanceof w,"need bodies");let s=new b;if(I(t,e,s))return s},hitTestPolygonPolygon:(t,e)=>(d.assert(t instanceof w&&e instanceof w,"need bodies"),I(t,e,new b)),hitTestPointInPolygon(t,e,s){let i;for(let r,n,o=s.length,h=0,l=o-1;h<o;)r=s[h],n=s[l],r[1]>e!=n[1]>e&&t<(n[0]-r[0])*(e-r[1])/(n[1]-r[1])+r[0]&&(i=!i),l=h,++h;return i},hitTestPointPolygon(t,e,s){return d.assert(s instanceof w,"wanted a body"),this.hitTestPointInPolygon(t,e,o.translate(s.pos,s.shape.calcPoints))},hitTestLineCircle(t,e,s,i,r){let n,h=o.sub(e,t),l=[s,i],a=o.sub(l,t),c=o.sub(l,e),u=o.len2(a),d=o.dot(a,h)/o.dot(h,h);return n=d>=0&&d<=1?u-d*d*o.len2(h):d<0?u:o.len2(c),[n<r*r]},hitTestLinePolygon(t,e,s){d.assert(s instanceof w,"wanted a body");let i=o.translate(s.pos,s.shape.calcPoints);for(let s=0,r=0;s<i.length;++s){r=s+1,r==i.length&&(r=0);let[n,o]=this.lineIntersect2D(t,e,i[s],i[r]);if(n)return[n,o]}return[!1]},lineIntersect2D(t,e,s,i){let r,n,o=t[0],h=t[1],l=e[0],a=e[1],c=s[0],u=s[1],f=i[0],g=i[1],p=(o-l)*(u-g)-(h-a)*(c-f);return d.feq0(p)?[!1]:(r=(o-c)*(u-g)-(h-u)*(c-f),r/=p,n=(o-c)*(h-a)-(h-u)*(o-l),n/=p,0<=r&&r<=1&&0<=n&&n<=1?[!0,r,[o+r*(l-o),h+r*(a-h)]]:[!1])},lineIntersection2D(t,e,s,i){if(t[1]>i[1]&&e[1]>i[1]&&t[1]>s[1]&&e[1]>s[1]||e[1]<s[1]&&t[1]<s[1]&&e[1]<i[1]&&t[1]<i[1]||t[0]>i[0]&&e[0]>i[0]&&t[0]>s[0]&&e[0]>s[0]||e[0]<s[0]&&t[0]<s[0]&&e[0]<i[0]&&t[0]<i[0])return[!1,0];let r=(t[1]-s[1])*(i[0]-s[0])-(t[0]-s[0])*(i[1]-s[1]),n=(e[0]-t[0])*(i[1]-s[1])-(e[1]-t[1])*(i[0]-s[0]),o=(t[1]-s[1])*(e[0]-t[0])-(t[0]-s[0])*(e[1]-t[1]),h=(e[0]-t[0])*(i[1]-s[1])-(e[1]-t[1])*(i[0]-s[0]),l=r*n,a=o*h;return l>0&&l<n*n&&a>0&&a<h*h?[!0,r/n]:[!1,0]}}}"object"==typeof module&&module.exports?module.exports=n(require("./core"),require("./math"),require("./vec2"),require("./matrix"),require("../algo/basic")):t["io/czlab/mcfud/geo2d"]=n}(this),function(t,e){"use strict";function s(s,i){s||(s=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]());Math.floor;const{u:r,is:n}=s;return{spatialGrid:(t=320,s=320)=>function(t,s){const o=new Map;return{searchAndExec(t,e){let s,i=t.getSpatial();for(let r,n,h=i.y1;h<=i.y2;++h)if(n=o.get(h))for(let o,l,a=i.x1;a<=i.x2;++a)if(r=n.get(a))for(o=r.values(),l=o.next();!l.done;){if(t!==l.value&&(s=e(t,l.value))){a=h=1/0;break}s=null,l=o.next()}return s},search(t,e=!1){let s,i,r=[],n=t.getSpatial();for(let h=n.y1;h<=n.y2;++h)if(i=o.get(h))for(let o=n.x1;o<=n.x2;++o)(s=i.get(o))&&s.forEach((s=>{(s!==t||e)&&r.push(s)}));return r},engrid(e,r){if(!e)return;let n=e.getBBox(),o=e.getSpatial(),h=i.ndiv(n.x1,t),l=i.ndiv(n.y1,s),a=i.ndiv(n.x2,t),c=i.ndiv(n.y2,s);return o.x1==h&&o.x2==a&&o.y1==l&&o.y2==c||(this.degrid(e),o.x1=h,o.x2=a,o.y1=l,o.y2=c,r||this._register(e)),e},reset(){o.clear()},_register(t){let e=t.getSpatial();if(n.num(e.x1))for(let s,i,n=e.y1;n<=e.y2;++n){o.has(n)||o.set(n,new Map),i=o.get(n);for(let n=e.x1;n<=e.x2;++n)i.has(n)||i.set(n,new Map),s=i.get(n),r.assoc(s,t.getGuid(),t)}},degrid(t){if(t){let s=t.getSpatial();if(n.num(s.x1))for(let e,i,n=s.y1;n<=s.y2;++n)if(i=o.get(n))for(let n=s.x1;n<=s.x2;++n)(e=i.get(n))&&r.dissoc(e,t.getGuid());s.x1=e,s.x2=e,s.y1=e,s.y2=e}}}}(t,s)}}"object"==typeof module&&module.exports?module.exports=s(require("./core"),require("./math")):t["io/czlab/mcfud/spatial"]=s}(this),function(t,e){"use strict";function s(e,s){e||(e=t["io/czlab/mcfud/core"]()),s||(s=t["io/czlab/mcfud/math"]());Math.floor;const{u:i}=e;function r(t,e,o,h,l,a,c){let u=null,d=[],f=s.ndiv(t+e,2),g=s.ndiv(o+h,2);function p(t){function e({x1:t,x2:e,y1:s,y2:i}){let r=[],n=t<f,o=e>f;return s<g&&(n&&r.push(3),o&&r.push(0)),i>g&&(n&&r.push(2),o&&r.push(1)),r}return t.getBBox?e(t.getBBox()):(i.assert(void 0!==t.x1&&void 0!==t.y1&&void 0!==t.x2&&void 0!==t.y2,"wanted bbox for quadtree"),e(t))}const m={x1:t,x2:e,y1:o,y2:h};return{boundingBox:()=>m,subTrees:()=>u,dbg:t=>t(d,u,l,a,c),insert(...s){s.forEach((s=>{u?p(s).forEach((t=>u[t].insert(s))):(d.push(s),d.length>l&&c<a&&(i.assert(null===u),u=[r(f,e,o,g,l,a,c+1),r(f,e,g,h,l,a,c+1),r(t,f,g,h,l,a,c+1),r(t,f,o,g,l,a,c+1)],d.forEach((t=>p(t).forEach((e=>u[e].insert(t))))),d.length=0))}))},remove(t){u?u.forEach((e=>e.remove(t))):i.disj(d,t)},isLeaf:()=>null===u?-1:d.length,prune(){if(u){let t=0,e=0;for(let s,i=0;i<u.length;++i)s=u[i],s.prune(),n=s.isLeaf(),n>=0&&(++t,e+=n);t==u.length&&e<l&&(i.assert(0==d.length,"quadtree wanted zero items"),u.forEach((t=>t._swap(d))),u=null)}},_swap(t){d.forEach((e=>t.push(e))),d.length=0},reset(){d.length=0,u&&u.forEach((t=>t.reset())),u=null},searchAndExec(t,e,s){let i;if(u){let r=p(t);for(let n=0;n<r.length&&(i=u[r[n]].searchAndExec(t,e,s),!i);++n);}else for(let r,n=0;n<d.length&&(r=d[n],s&&r===t||!(i=e(r,t)));++n);return i},search(t,e){const s=new Map,i=[];return e&&s.set(t,null),u&&p(t).forEach((e=>{u[e].search(t).forEach((t=>{s.has(t)||(s.set(t,null),i.push(t))}))})),d.forEach((t=>{s.has(t)||(s.set(t,null),i.push(t))})),s.clear(),i}}}return{quadtree(t,e=12,s=5){const{x1:i,x2:n,y1:o,y2:h}=t;return r(i,n,o,h,e,s,0)}}}"object"==typeof module&&module.exports?module.exports=s(require("./core"),require("./math")):t["io/czlab/mcfud/qtree"]=s}(this),function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:i}=s;class r{constructor(t,s){this.lastBestMove=e,this.state=e,this.other=s,this.cur=t}clone(t){const e=new r;return e.state=t(this.state),e.lastBestMove=this.lastBestMove,e.other=this.other,e.cur=this.cur,e}}function n(t,e,s,i){return t.evalScore(e,s,i)*(1+.001*s)}function o(t,e,s,r,h,l){if(0==s||t.isOver(e))return{depth:s,value:n(t,e,s,r)};let a=e,c=t.getStateCopier(),u=i.shuffle(t.getNextMoves(e));for(let n,d,f=0;f<u.length;++f)if(d=u[f],t.undoMove||(i.assert(c,"Missing state copier!"),e=a.clone(c)),t.makeMove(e,d),n=o(t,e,s-1,r,{value:-l.value,move:l.move},{value:-h.value,move:h.move}),t.undoMove&&t.unmakeMove(e,d),n.value=-n.value,n.move=d,n.value>h.value&&(h={value:n.value,move:d,depth:n.depth}),h.value>=l.value)return l;return JSON.parse(JSON.stringify(h))}function h(t,e,s,r,o,l){if(0==s||t.isOver(e))return[n(t,e,s,r),null];let a=i.shuffle(t.getNextMoves(e)),c=t.getStateCopier(),u=e,d=-1/0,f=a[0];s==r&&(u.lastBestMove=f);for(let n,g,p=0;p<a.length&&(t.undoMove||(i.assert(c,"Missing state copier!"),e=u.clone(c)),g=a[p],t.makeMove(e,g),n=-h(t,e,s-1,r,-l,-o)[0],t.undoMove&&t.unmakeMove(e,g),d<n&&(d=n,f=g),!(o<n&&(o=n,s==r&&(u.lastBestMove=g),o>=l)));++p);return[d,u.lastBestMove]}const l={algo:"negamax",GFrame:r,GameBoard:class{constructor(){}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t){}isStalemate(t){}isOver(t){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}takeGFrame(){}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=l.evalNegaMax(this)),s}},XXevalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let[r,n]=h(t,e,s,s,-1/0,1/0);return i.nichts(n)&&console.log(`evalNegaMax: score=${r}, pos= ${n}, lastBestMove=${n}`),n},evalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let{value:r,move:n}=o(t,e,s,s,{value:-1/0},{value:1/0});return i.nichts(n)&&console.log(`evalNegaMax: score= ${r}, pos= ${n}`),n}};return l}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/negamax"]=s}(this),function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:i}=s;class r{constructor(t,s){this.state=e,this.other=s,this.cur=t}clone(t){const e=new r;return e.state=t(this.state),e.other=this.other,e.cur=this.cur,e}}const n=(t,e,s,i)=>t.evalScore(e,s,i);function o(t,s,r,h,l,a,c){if(0==r||t.isOver(s))return[n(t,s,r,h),e];let u=s,d=t.getStateCopier(),f=i.shuffle(t.getNextMoves(s));if(c){let e,n,g=f[0],p=-1/0;for(let m=0;m<f.length&&(t.undoMove||(i.assert(d,"Missing state copier!"),s=u.clone(d)),n=f[m],t.makeMove(s,n),e=o(t,s,r-1,h,l,a,!c)[0],t.undoMove&&t.unmakeMove(s,n),l=Math.max(e,l),e>p&&(p=e,g=n),!(a<=l));++m);return[p,g]}{let e,n,g=f[0],p=1/0;for(let m=0;m<f.length&&(t.undoMove||(i.assert(d,"Missing state copier!"),s=u.clone(d)),n=f[m],t.makeMove(s,n),e=o(t,s,r-1,h,l,a,!c)[0],t.undoMove&&t.unmakeMove(s,n),a=Math.min(e,a),e<p&&(p=e,g=n),!(a<=l));++m);return[p,g]}}const h={algo:"minimax",GFrame:r,GameBoard:class{constructor(){this.aiActor=e}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t,e,s){}isStalemate(t){}isOver(t,e){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}takeGFrame(){}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=h.evalMiniMax(this)),s}},evalMiniMax(t){const e=t.takeGFrame(),s=t.depth;let[r,n]=o(t,e,s,s,-1/0,1/0,!0);return i.nichts(n)&&console.log(`evalMiniMax: score=${r}, pos= ${n}`),n}};return h}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/minimax"]=s}(this),function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const i=(t,e)=>t<e?-1:t>e?1:0,r=Math.floor,{is:n,u:o}=s,h=t=>o.assert(n.num(t)||n.str(t),"expected number or string");function l(t,e=" ",s=""){for(;t.hasNext();)s+=`${t.next()}${e}`;return s}class a{constructor(t){this.current=t}hasNext(){return o.echt(this.current)}remove(){throw Error("Unsupported")}next(){if(!this.hasNext())throw Error("NoSuchElementException");let t=this.current.item;return this.current=this.current.next,t}}function c(t,e){return{item:t,next:e}}class u{constructor(){this.first=e,this.n=0}clone(){let t,e=new u,s=this.first;for(;s;)t?(t.next=c(s.item),t=t.next):e.first=t=c(s.item),e.n+=1,s=s.next;return e}isEmpty(){return o.nichts(this.first)}size(){return this.n}add(t){this.first=c(t,this.first),this.n+=1}iter(){return new a(this.first)}static test(){let t=new u;"to be or not to - be - - that - - - is".split(" ").forEach((e=>t.add(e))),console.log("size of bag = "+t.size()),console.log(l(t.iter()));let e=t.clone();console.log("size of cloned = "+e.size()),console.log(l(e.iter()))}}class d{constructor(){this.first=e,this.n=0}clone(){let t,e=new d,s=this.first;for(;s;)t?(t.next=c(s.item),t=t.next):e.first=t=c(s.item),e.n+=1,s=s.next;return e}isEmpty(){return o.nichts(this.first)}size(){return this.n}push(t){this.first=c(t,this.first),this.n+=1}pop(){if(this.isEmpty())throw Error("Stack underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,t}peek(){if(this.isEmpty())throw Error("Stack underflow");return this.first.item}toString(){return l(this.iter())}iter(){return new a(this.first)}static test(){let t=new d;"to be or not to - be - - that - - - is".split(" ").forEach((e=>{"-"!=e?t.push(e):t.isEmpty()||console.log("(-)"+t.pop()+" ")})),console.log("("+t.size()+" left on stack)");let e=t.clone();console.log("cloned= "+l(e.iter())),console.log("("+e.size()+" left on stack)")}}class f{constructor(){this.first=e,this.last=e,this.n=0}clone(){let t=new f,e=this.first;for(;e;)t.enqueue(e.item),e=e.next;return t}isEmpty(){return o.nichts(this.first)}size(){return this.n}peek(){if(this.isEmpty())throw Error("Queue underflow");return this.first.item}enqueue(t){let e=this.last;this.last=c(t),this.isEmpty()?this.first=this.last:e.next=this.last,this.n+=1}dequeue(){if(this.isEmpty())throw Error("Queue underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,this.isEmpty()&&(this.last=e),t}toString(){return l(this.iter())}iter(){return new a(this.first)}static test(){let t=new f;"to be or not to - be - - that - - - is".split(/\s+/).forEach((e=>{"-"!=e?t.enqueue(e):t.isEmpty()||console.log(t.dequeue()+" ")})),console.log("("+t.size()+" left on queue)");let e=t.clone();console.log("cloned= "+l(e.iter())),console.log("("+e.size()+" left on queue)")}}class g{constructor(t){this.compare=t||i,this.root=e,this.n=0}size(){return this.n}contains(t){return void 0!==this.get(t)}get(t){const e=(t,s,i)=>{if(s){let r=this.compare(t,s.key);i=r<0?e(t,s.left):r>0?e(t,s.right):s.value}return i};if(h(t)&&this.n>0)return e(t,this.root)}set(t,e){const s=(t,e,i)=>{if(!i)return this.n+=1,{key:t,value:e};let r=this.compare(t,i.key);return r<0?i.left=s(t,e,i.left):r>0?i.right=s(t,e,i.right):i.value=e,i};h(t)&&void 0!==e&&(this.root=s(t,e,this.root))}_getMaxNode(t){for(;t&&t.right;)t=t.right;return t}_getMaxKey(){let t=this._getMaxNode(this.root);if(t)return t.key}_getMinNode(t){for(;t&&t.left;)t=t.left;return t}_getMinKey(){let t=this._getMinNode(this.root);if(t)return t.key}remove(t){const s=(t,i)=>{if(i){let r,n,o,h=this.compare(t,i.key);h<0?i.left=s(t,i.left):h>0?i.right=s(t,i.right):i.left&&i.right?(o=this._getMaxNode(i.left),r=o.key,n=o.value,o.value=i.value,o.key=i.key,i.key=r,i.value=n,i.left=s(t,i.left)):i.left?(i=i.left,this.n-=1):i.right?(i=i.right,this.n-=1):(i=e,this.n-=1)}return i};h(t)&&(this.root=s(t,this.root))}keys(){let t=new f;return this.forEach(((e,s)=>t.enqueue(s))),t.iter()}firstKey(){let t;try{this.forEach(((e,s)=>{throw t=s,Error("????")}))}catch(t){}return t}lastKey(){let t;return this.forEach(((e,s)=>{t=s})),t}forEach(t,e){function s(t,e){return e&&e.apply(t,Array.prototype.slice.call(arguments,2))}!function t(e,i,r,n){if(!e)return s(r,n);t(e.left,i,r,(function(){s(r,i,e.value,e.key),t(e.right,i,r,(function(){s(r,n)}))}))}(this.root,t,e)}static test(){let t=new g;t.set(3,"3"),t.set(2,"2"),t.set(7,"7"),t.set(1,"1"),console.log(`firstKey= ${t.firstKey()}`),console.log(`lastKey= ${t.lastKey()}`),console.log(l(t.keys())),console.log(`k= ${t.get(3)}`),console.log(`has 2 = ${t.contains(2)}`),console.log(`has size = ${t.size()}`),t.remove(1),console.log(`has size = ${t.size()}`),console.log(l(t.keys())),console.log(`k= ${t.get(2)}`)}}class p{constructor(){this.st=new g}get(t){if(o.nichts(t))throw Error("calls get() with null key");return this.st.get(t)}put(t,e){if(o.nichts(t))throw Error("calls put() with null key");void 0===e?this.st.remove(t):this.st.set(t,e)}remove(t){if(o.nichts(t))throw Error("calls remove() with null key");this.st.remove(t)}contains(t){if(o.nichts(t))throw Error("calls contains() with null key");return this.st.contains(t)}size(){return this.st.size()}isEmpty(){return 0==this.size()}keys(){return this.st.keys()}min(){if(this.isEmpty())throw Error("calls min() with empty symbol table");return this.st.firstKey()}max(){if(this.isEmpty())throw Error("calls max() with empty symbol table");return this.st.lastKey()}ceiling(t){if(o.nichts(t))throw Error("argument to ceiling() is null");let e,s,i=this.st.keys();for(;i.hasNext();)if(s=i.next(),s==t||s>t){e=s;break}if(void 0===e)throw Error("argument to ceiling() is too large");return e}floor(t){if(o.nichts(t))throw Error("argument to floor() is null");let e,s,i=this.st.keys();for(;i.hasNext();)s=i.next(),(s==t||s<t)&&(e=s);if(void 0===e)throw Error("argument to floor() is too small");return e}static test(){let t=new p;t.put("a",1),t.put("g",9),t.put("c",3),t.put("j",10),t.put("z",26),t.put("x",24),console.log(`isEmpty= ${t.isEmpty()}`),console.log(`size= ${t.size()}`),console.log(`get-c= ${t.get("c")}`),console.log(`contains z= ${t.contains("z")}`),console.log(`contains m= ${t.contains("m")}`),console.log(l(t.keys())),console.log(`ceil w= ${t.ceiling("w")}`),console.log(`floor k= ${t.floor("k")}`),console.log(`min = ${t.min()}`),console.log(`max = ${t.max()}`),t.remove("x"),console.log(l(t.keys()))}}class m{static M=4;Node(t){return{m:t,children:new Array(m.M)}}Entry(t,e,s){return{key:t,val:e,next:s}}constructor(t){this.root=this.Node(0),this.compare=t,this._height=0,this.n=0}isEmpty(){return 0==this.size()}size(){return this.n}height(){return this._height}get(t){if(o.nichts(t))throw Error("argument to get() is null");return this._search(this.root,t,this._height)}_search(t,e,s){let i=t.children;if(0==s){for(let s=0;s<t.m;++s)if(0==this.compare(e,i[s].key))return i[s].val}else for(let r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,i[r+1].key)<0)return this._search(i[r].next,e,s-1)}put(t,e){if(o.nichts(t))throw Error("argument key to put() is null");let s,i=this._insert(this.root,t,e,this._height);this.n+=1,i&&(s=this.Node(2),s.children[0]=this.Entry(this.root.children[0].key,null,this.root),s.children[1]=this.Entry(i.children[0].key,null,i),this.root=s,this._height+=1)}_insert(t,e,s,i){let r,n=this.Entry(e,s);if(0==i)for(r=0;r<t.m&&!(this.compare(e,t.children[r].key)<0);++r);else for(r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,t.children[r+1].key)<0){let o=this._insert(t.children[r++].next,e,s,i-1);if(!o)return null;n.key=o.children[0].key,n.val=null,n.next=o;break}for(let e=t.m;e>r;--e)t.children[e]=t.children[e-1];if(t.children[r]=n,t.m++,t.m>=m.M)return this._split(t)}_split(t){let e=r(m.M/2),s=this.Node(e);t.m=e;for(let i=0;i<e;++i)s.children[i]=t.children[e+i];return s}toString(){return function t(e,s,i){let r="",n=e.children;if(0==s)for(let t=0;t<e.m;++t)r+=`${i}${n[t].key} ${n[t].val}\n`;else for(let o=0;o<e.m;++o)o>0&&(r+=`${i}(${n[o].key})\n`),r+=t(n[o].next,s-1,i+"     ");return r}(this.root,this._height,"")+"\n"}static test(){let t=new m(i);t.put("www.cs.princeton.edu","128.112.136.12"),t.put("www.cs.princeton.edu","128.112.136.11"),t.put("www.princeton.edu","128.112.128.15"),t.put("www.yale.edu","130.132.143.21"),t.put("www.simpsons.com","209.052.165.60"),t.put("www.apple.com","17.112.152.32"),t.put("www.amazon.com","207.171.182.16"),t.put("www.ebay.com","66.135.192.87"),t.put("www.cnn.com","64.236.16.20"),t.put("www.google.com","216.239.41.99"),t.put("www.nytimes.com","199.239.136.200"),t.put("www.microsoft.com","207.126.99.140"),t.put("www.dell.com","143.166.224.230"),t.put("www.slashdot.org","66.35.250.151"),t.put("www.espn.com","199.181.135.201"),t.put("www.weather.com","63.111.66.11"),t.put("www.yahoo.com","216.109.118.65"),console.log("cs.princeton.edu:  "+t.get("www.cs.princeton.edu")),console.log("hardvardsucks.com: "+t.get("www.harvardsucks.com")),console.log("simpsons.com:      "+t.get("www.simpsons.com")),console.log("apple.com:         "+t.get("www.apple.com")),console.log("ebay.com:          "+t.get("www.ebay.com")),console.log("dell.com:          "+t.get("www.dell.com")),console.log(""),console.log("size:    "+t.size()),console.log("height:  "+t.height()),console.log(t.toString()),console.log("")}}class y{constructor(t){this.d=t,this.st=new p}put(t,e){if(t<0||t>=this.d)throw Error("Illegal index");o.feq0(e)?this.st.remove(t):this.st.put(t,e)}get(t){if(t<0||t>=this.d)throw Error("Illegal index");return this.st.contains(t)?this.st.get(t):0}nnz(){return this.st.size()}dimension(){return this.d}dot(t){if(o.assert(t instanceof y,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e,s=0,i=(this.st.size()<=t.st.size()?this:t).st.keys();for(;i.hasNext();)e=i.next(),t.st.contains(e)&&(s+=this.get(e)*t.get(e));return s}dotWith(t){let e=0;for(let s,i=this.st.keys();i.hasNext();)s=i.next(),e+=t[s]*this.get(s);return e}magnitude(){return Math.sqrt(this.dot(this))}scale(t){let e=new y(this.d);for(let s,i=this.st.keys();i.hasNext();)s=i.next(),e.put(s,t*this.get(s));return e}plus(t){if(o.assert(t instanceof y,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e=new y(this.d);for(let t,s=this.st.keys();s.hasNext();)t=s.next(),e.put(t,this.get(t));for(let s,i=t.st.keys();i.hasNext();)s=i.next(),e.put(s,t.get(s)+e.get(s));return e}toString(){let t="";for(let e,s=this.st.keys();s.hasNext();)e=s.next(),t+=`(${e}, ${this.st.get(e)}) `;return t}static test(){let t=new y(10),e=new y(10);t.put(3,.5),t.put(9,.75),t.put(6,.11),t.put(6,0),e.put(3,.6),e.put(4,.9),console.log("a = "+t.toString()),console.log("b = "+e.toString()),console.log("a dot b = "+t.dot(e)),console.log("a + b   = "+t.plus(e).toString())}}return{prnIter:l,StdCompare:i,BTree:m,Bag:u,Stack:d,Queue:f,ST:p,TreeMap:g,SparseVector:y,Iterator:a}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/basic"]=s}(this),function(t,e){"use strict";function s(s,i,r){s||(s=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]()),r||(r=t["io/czlab/mcfud/algo/basic"]());const{prnIter:n,Bag:o,Stack:h,Iterator:l,StdCompare:a}=r,c=Math.floor,{is:u,u:d}=s;function f(t,e,s,i,r){d.assert(t>e,"bad resize capacity");let n,o=new Array(t);for(n=s;n<i;++n)o[n]=r[n];return o}const g=(t,e,s)=>s(t,e)<0;function p(t,e,s){const i=t[e];t[e]=t[s],t[s]=i}function m(t){let e,s="";for(e=0;e<t.length;++e)s+=`${t[e]} `;console.log(s)}class y{static sort(t,e){const s=t.length;for(let i=1;i<s;++i)for(let s=i;s>0&&g(t[s],t[s-1],e);--s)p(t,s,s-1);return t}static sortRange(t,e,s,i){for(let r=e+1;r<s;++r)for(let s=r;s>e&&g(t[s],t[s-1],i);--s)p(t,s,s-1);return t}static indexSort(t,e){const s=t.length,i=d.fill(s,(t=>t));for(let r=1;r<s;++r)for(let s=r;s>0&&g(t[i[s]],t[i[s-1]],e);--s)p(i,s,s-1);return i}static test(){let t="SORTEXAMPLE".split("");m(y.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(y.sortRange(t,0,t.length,a)),t="SORTEXAMPLE".split(""),m(y.indexSort(t,a))}}class v{static sort(t,e){let s,r,n,o=t.length;for(let h,l=1;l<o;++l){for(r=0,n=l,h=t[l];r<n;)s=r+i.ndiv(n-r,2),g(h,t[s],e)?n=s:r=s+1;for(let e=l;e>r;--e)t[e]=t[e-1];t[r]=h}return t}static test(){let t="SORTEXAMPLE".split("");m(v.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(v.sort(t,a))}}class w{static sort(t,e){let s,i=t.length;for(let r=0;r<i;++r){s=r;for(let n=r+1;n<i;++n)g(t[n],t[s],e)&&(s=n);p(t,r,s)}return t}static test(){let t="SORTEXAMPLE".split("");m(w.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(w.sort(t,a))}}class x{static sort(t,e){let s=t.length,r=1,n=i.ndiv(s,3);for(;r<n;)r=3*r+1;for(;r>=1;){for(let i=r;i<s;++i)for(let s=i;s>=r&&g(t[s],t[s-r],e);s-=r)p(t,s,s-r);r=i.ndiv(r,3)}return t}static test(){let t="SORTEXAMPLE".split("");m(x.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(x.sort(t,a))}}function _(t,e,s,r,n,o){if(n<=r);else{let h=r+i.ndiv(n-r,2);_(t,e,s,r,h,o),_(t,e,s,h+1,n,o),function(t,e,s,i,r,n,o){for(let t=i;t<=n;++t)s[t]=e[t];let h=i,l=r+1;for(let a=i;a<=n;++a)h>r?e[a]=s[l++]:l>n?e[a]=s[h++]:g(t[s[l]],t[s[h]],o)?e[a]=s[l++]:e[a]=s[h++]}(t,e,s,r,h,n,o)}return t}class N{static sort(t,e){return function t(e,s,r,n,o){if(n<=r);else{let h=r+i.ndiv(n-r,2);t(e,s,r,h,o),t(e,s,h+1,n,o),function(t,e,s,i,r,n){for(let i=s;i<=r;++i)e[i]=t[i];let o=s,h=i+1;for(let l=s;l<=r;++l)o>i?t[l]=e[h++]:h>r?t[l]=e[o++]:g(e[h],e[o],n)?t[l]=e[h++]:t[l]=e[o++]}(e,s,r,h,n,o)}return e}(t,new Array(t.length),0,t.length-1,e),t}static indexSort(t,e){let s=t.length,i=d.fill(s,(t=>t));return _(t,i,new Array(s),0,s-1,e),i}static test(){let t="SORTEXAMPLE".split("");m(N.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(N.sort(t,a)),t="SORTEXAMPLE".split(""),m(N.indexSort(t,a))}}class b{static sort(t,e){const s=t.length;for(let i,r=0;r<s;++r){i=0;for(let n=s-1;n>r;--n)g(t[n],t[n-1],e)&&(p(t,n,n-1),++i);if(0==i)break}return t}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");b.sort(t,a),m(t)}}function k(t,e,s,i){let r=e,n=t[e],o=s+1;for(;;){for(;g(t[++r],n,i)&&r!=s;);for(;g(n,t[--o],i)&&o!=e;);if(r>=o)break;p(t,r,o)}return p(t,e,o),o}class E{static sort(t,e){return function t(e,s,i,r){if(i<=s);else{let n=k(e,s,i,r);t(e,s,n-1,r),t(e,n+1,i,r)}return e}(t,0,t.length-1,e),t}static select(t,e,s){if(e<0||e>=t.length)throw Error(`index is not between 0 and ${t.length}: ${e}`);let i=0,r=t.length-1;for(;r>i;){let n=k(t,i,r,s);if(n>e)r=n-1;else{if(!(n<e))return t[n];i=n+1}}return t[i]}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");m(E.sort(t,a)),t="SORTEXAMPLE".split(""),m(E.sort(t,a)),d.shuffle(t),t.forEach(((e,s)=>console.log(E.select(t,s,a))))}}const M=(t,e,s,i)=>g(t[e],t[s],i);class T{Node(t){return{key:t,order:0}}constructor(t,s){this.compare=t,this.table=new Map,this.head=e,this._min=e,this.n=0,u.vec(s)&&s.forEach((t=>this.insert(t)))}isEmpty(){return 0==this.n}size(){return this.n}insert(t){let e=this.Node(t);this.n+=1,this.head=this._insertNode(e,this.head),this._min=this._min?this._greater(this._min.key,t)?this.head:this._min:this.head}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cut(this._min,this.head);let t=this._min.child,s=this._min.key;return this._min.key=e,t&&(this.head=this._meld(this.head,t),this._min.child=e),this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),s}union(t){return this.head=this._meld(this.head,t.head),this._min=this._greater(this._min.key,t._min.key)?t._min:this._min,this.n=this.n+t.n,this}_greater(t,e){return!d.nichts(t)&&(!!d.nichts(e)||this.compare(t,e)>0)}_link(t,e){e.child=this._insertNode(t,e.child),e.order+=1}_consolidate(){this.table.clear();let t=this.head,s=e,i=e,r=0;this._min=this.head;do{for(s=t,t=t.next,i=this.table.get(s.order);i;)this.table.delete(s.order),this._greater(s.key,i.key)?(this._link(s,i),s=i):this._link(i,s),i=this.table.get(s.order);this.table.set(s.order,s),s.order>r&&(r=s.order)}while(t!==this.head);this.head=null,this.table.forEach((t=>{t&&(this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head))}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cut(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new T(this.compare),e=s=>{if(!s)return;let i=s;do{t.insert(i.key),e(i.child),i=i.next}while(i!==s)};return e(this.head),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new T(a);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",e.isEmpty(),console.log(t),console.log("min= "+e.min()),console.log(n(e.iter())),console.log("("+e.size()+" left on pq)");let s=new T(a);"ZTAK".split("").forEach((t=>s.insert(t))),s=s.union(e),console.log(n(s.iter()))}}class S{Node(t){return{key:t,order:0,index:0}}constructor(t,s){if(t<0)throw Error("Cannot create a priority queue of negative size");this.maxN=t,this.n=0,this.head=e,this._min=e,this.compare=s,this.table=new Map,this.nodes=new Array(t)}isEmpty(){return 0==this.n}contains(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");return d.echt(this.nodes[t])}size(){return this.n}insert(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(this.contains(t))throw Error("Specified index is already in the queue");let s=this.Node(e);s.index=t,this.nodes[t]=s,this.n+=1,this.head=this._insertNode(s,this.head),this._min=this._min?this._greater(this._min.key,e)?this.head:this._min:this.head}minIndex(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.index}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cutNode(this._min,this.head);let t=this._min.child,s=this._min.index;if(this._min.key=e,t){do{t.parent=e,t=t.next}while(t!==this._min.child);this.head=this._meld(this.head,t),this._min.child=e}return this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),this.nodes[s]=e,s}keyOf(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");return this.nodes[t].key}changeKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");this._greater(e,this.nodes[t].key)?this.increaseKey(t,e):this.decreaseKey(t,e)}decreaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(e,this.nodes[t].key))throw Error("Calling with this argument would not decrease the key");let s=this.nodes[t];s.key=e,this._greater(this._min.key,e)&&(this._min=s),s.parent&&this._greater(s.parent.key,e)&&this._cut(t)}increaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(this.nodes[t].key,e))throw Error("Calling with this argument would not increase the key");this.delete(t),this.insert(t,e)}delete(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");let s=this.nodes[t];if(s.key=null,s.parent&&this._cut(t),this.head=this._cutNode(s,this.head),s.child){let t=s.child;s.child=e,s=t;do{t.parent=e,t=t.next}while(t!==s);this.head=this._meld(this.head,t)}this.isEmpty()?this._min=e:this._consolidate(),this.nodes[t]=e,this.n-=1}_greater(t,e){return!d.nichts(t)&&(!!d.nichts(e)||this.compare(t,e)>0)}_link(t,e){t.parent=e,e.child=this._insertNode(t,e.child),e.order+=1}_cut(t){let s=this.nodes[t],i=s.parent;i.child=this._cutNode(s,i.child),s.parent=e,i.order-=1,this.head=this._insertNode(s,this.head),i.mark=!i.mark,!i.mark&&i.parent&&this._cut(i.index)}_consolidate(){let t=e,s=e,i=0,r=this.head;this.table.clear(),this._min=this.head;do{for(t=r,r=r.next,s=this.table.get(t.order);s;)this.table.delete(t.order),this._greater(t.key,s.key)?(this._link(t,s),t=s):this._link(s,t),s=this.table.get(t.order);this.table.set(t.order,t),t.order>i&&(i=t.order)}while(r!==this.head);this.head=e,this.table.forEach((t=>{this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head)}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cutNode(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new S(this.maxN,this.compare);return this.nodes.forEach((e=>{e&&t.insert(e.index,e.key)})),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new S(t.length,a);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(console.log("min= "+e.min()),console.log("minindex= "+e.minIndex()),console.log("size= "+e.size()),console.log("contains(3)="+e.contains(3)),console.log("keyOf(3)="+e.keyOf(3)),e.changeKey(3,"bbbb");!e.isEmpty();){let t=e.minIndex();console.log(t+" "+e.keyOf(t)),e.delMin()}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class q{constructor(t,e){if(this.comparator=t,this.n=0,u.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t,this)}else this.pq=new Array(u.num(e)?e:2);d.assert(this._isMinHeap(),"not min heap")}isEmpty(){return 0==this.n}size(){return this.n}min(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=f(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.pq[++this.n]=t,this._swim(this.n),d.assert(this._isMinHeap(),"not min heap-insert")}delMin(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return p(this.pq,1,this.n--),this._sink(1),this.pq[this.n+1]=e,this.n>0&&this.n==i.ndiv(this.pq.length-1,4)&&(this.pq=f(i.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_swim(t){for(;t>1&&this._greater(i.ndiv(t,2),t);)p(this.pq,t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&e++,!this._greater(t,e))break;p(this.pq,t,e),t=e}}_greater(t,e){return this.comparator(this.pq[t],this.pq[e])>0}_isMinHeap(){for(let t=1;t<=this.n;++t)if(d.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(!d.nichts(this.pq[t]))return!1;return!d.echt(this.pq[0])&&this._isMinHeapOrdered(1)}_isMinHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&this._greater(t,e))&&(!(s<=this.n&&this._greater(t,s))&&(this._isMinHeapOrdered(e)&&this._isMinHeapOrdered(s)))}iter(){let t=new q(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new q(a);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}class I{constructor(t,e){if(this.comparator=t,this.n=0,u.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t)}else this.pq=new Array(u.num(e)?e:2);d.assert(this._isMaxHeap(),"not max heap")}isEmpty(){return 0==this.n}size(){return this.n}max(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=f(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.n+=1,this.pq[this.n]=t,this._swim(this.n),d.assert(this._isMaxHeap(),"not max heap-insert")}delMax(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return p(this.pq,1,this.n),this.n-=1,this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==i.ndiv(this.pq.length-1,4)&&(this.pq=f(i.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_isMaxHeap(){for(let t=1;t<=this.n;++t)if(d.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(d.echt(this.pq[t]))return!1;return!d.echt(this.pq[0])&&this._isMaxHeapOrdered(1)}_isMaxHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&M(this.pq,t,e,this.comparator))&&(!(s<=this.n&&M(this.pq,t,s,this.comparator))&&(this._isMaxHeapOrdered(e)&&this._isMaxHeapOrdered(s)))}_swim(t){for(;t>1&&M(this.pq,i.ndiv(t,2),t,this.comparator);)p(this.pq,t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){let e;for(;2*t<=this.n&&(e=2*t,e<this.n&&M(this.pq,e,e+1,this.comparator)&&++e,M(this.pq,t,e,this.comparator));)p(this.pq,t,e),t=e}iter(){const t=new I(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t="",e=new I(a);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}function O(t,e,s,i){return i(t[e-1],t[s-1])<0}function A(t,e,s){const i=t[e-1];t[e-1]=t[s-1],t[s-1]=i}class z{static sort(t,e){function s(t,e,s,i){for(;2*e<=s;){let r=2*e;if(r<s&&O(t,r,r+1,i)&&++r,!O(t,e,r,i))break;A(t,e,r),e=r}}let r,n=t.length;for(r=i.ndiv(n,2);r>=1;--r)s(t,r,n,e);for(r=n;r>1;)A(t,1,r--),s(t,1,r,e);return t}static test(){let t="SORTEXAMPLE".split("");m(z.sort(t,a)),t="bed bug dad yes zoo all bad yet".split(" "),m(z.sort(t,a))}}class C{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}minIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}minKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMin(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),d.assert(t==this.pq[this.n+1],"No good"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(s<0)throw Error("Calling decreaseKey() with a key strictly greater than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(s>0)throw Error("Calling increaseKey() with a key strictly less than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_greater(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])>0}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._greater(i.ndiv(t,2),t);)this._exch(t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&++e,!this._greater(t,e))break;this._exch(t,e),t=e}}iter(){let t=new C(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new C(t.length,a);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(;!e.isEmpty();){let s=e.delMin();console.log(s+" "+t[s])}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class P{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}maxIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}maxKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMax(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),d.assert(this.pq[this.n+1]==t,"bad delMax"),this.qp[t]=-1,this.mKeys[t]=e,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)>0)throw Error("Calling increaseKey() with a key that is strictly less than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)<0)throw Error("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_less(t,e){return g(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]],this.compare)}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._less(i.ndiv(t,2),t);)this._exch(t,i.ndiv(t,2)),t=i.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._less(e,e+1)&&++e,!this._less(t,e))break;this._exch(t,e),t=e}}iter(){let t=new P(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new P(t.length,a);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);console.log("");for(let s=0;s<t.length;++s)d.rand()<.5?e.increaseKey(s,t[s]+t[s]):e.decreaseKey(s,t[s].substring(0,1));for(;!e.isEmpty();){let t=e.maxKey(),s=e.delMax();console.log(s+" "+t)}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);let s=new Array(t.length);for(let e=0;e<t.length;++e)s[e]=e;d.shuffle(s);for(let t=0;t<s.length;++t){let i=e.keyOf(s[t]);e.delete(s[t]),console.log(s[t]+" "+i)}}}return{FibonacciMinPQ:T,IndexFibonacciMinPQ:S,Insertion:y,BinaryInsertion:v,Selection:w,Shell:x,Merge:N,Bubble:b,Quick:E,MinPQ:q,MaxPQ:I,Heap:z,IndexMinPQ:C,IndexMaxPQ:P}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math"),require("./basic")):t["io/czlab/mcfud/algo/sort"]=s}(this),function(t,e){"use strict";function s(s,i,r,n){s||(s=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]()),r||(r=t["io/czlab/mcfud/algo/basic"]()),n||(n=t["io/czlab/mcfud/algo/sort"]());const{Bag:o,Stack:h,Queue:l,StdCompare:a,prnIter:c}=r,{MinPQ:u}=n,{is:d,u:f}=(Math.floor,s);class g{static count(t,e){let s=new Map,i=0,r="",n=0;for(let r,o=0;o<t.length;++o)r=t[o],r.length<e||(++i,s.has(r)?s.set(r,s.get(r)+1):(s.set(r,1),++n));return s.set(r,0),Array.from(s.keys()).forEach((t=>{s.get(t)>s.get(r)&&(r=t)})),[r,s.get(r),[n,i]]}static test(){let t="it was the best of times it was the worst of times\n        it was the age of wisdom it was the age of foolishness\n        it was the epoch of belief it was the epoch of incredulity\n        it was the season of light it was the season of darkness\n        it was the spring of hope it was the winter of despair".split(" "),[e,s,i]=g.count(t,1);console.log(e+" "+s),console.log("distinct = "+i[0]),console.log("words= "+i[1])}}class p{constructor(){this.first=e,this.n=0}size(){return this.n}isEmpty(){return 0==this.size()}contains(t){if(f.nichts(t))throw Error("argument to contains is null");return void 0!==this.get(t)}get(t){if(f.nichts(t))throw Error("argument to get is null");for(let e=this.first;e;e=e.next)if(t==e.key)return e.val}put(t,e){if(f.nichts(t))throw Error("first argument to put is null");if(void 0===e)this.delete(t);else{let s,i;for(i=this.first;i&&!s;i=i.next)t==i.key&&(i.val=e,s=!0);s||(this.first=((t,e,s)=>({key:t,val:e,next:s}))(t,e,this.first),this.n+=1)}}delete(t){const s=(t,i)=>t?i==t.key?(this.n-=1,t.next):(t.next=s(t.next,i),t):e;if(f.nichts(t))throw Error("argument to delete is null");this.first=s(this.first,t)}keys(){let t=new l;for(let e=this.first;e;e=e.next)t.enqueue(e.key);return t.iter()}static load(t){let e=new p;return t.forEach(((t,s)=>e.put(t,s))),e}static test(){let t=p.load("SEARCHEXAMPLE".split(""));console.log(((e="",s=0,i=0)=>{for(i=t.keys();i.hasNext();)e+=`${s=i.next()}=${t.get(s)} `;return e})()),console.log("size= "+t.size()),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),t.delete("R"),t.isEmpty(),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),console.log("size= "+t.size())}}class m{constructor(t,e=2){this.mKeys=new Array(e),this.vals=new Array(e),this.compare=t,this.n=0,this._resize=t=>{let e=new Array(t),s=new Array(t);for(let t=0;t<this.n;++t)e[t]=this.mKeys[t],s[t]=this.vals[t];this.vals=s,this.mKeys=e},this._argOk=t=>f.echt(t,"Invalid argument"),this._check=()=>(()=>{for(let t=1;t<this.size();++t)if(this.compare(this.mKeys[t],this.mKeys[t-1])<0)return!1;return!0})()&&(()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0;t<this.size();++t)if(0!=this.compare(this.mKeys[t],this.select(this.rank(this.mKeys[t]))))return!1;return!0})()}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){if(this._argOk(t)&&!this.isEmpty()){let e=this.rank(t);if(e<this.n&&0==this.compare(this.mKeys[e],t))return this.vals[e]}}rank(t){let e,s,r=0,n=this.n-1;for(this._argOk(t);r<=n;)if(e=r+i.ndiv(n-r,2),s=this.compare(t,this.mKeys[e]),s<0)n=e-1;else{if(!(s>0))return e;r=e+1}return r}put(t,e){if(this._argOk(t)&&void 0===e)this.delete(t);else{let s=this.rank(t);if(s<this.n&&0==this.compare(this.mKeys[s],t))this.vals[s]=e;else{this.n==this.mKeys.length&&this._resize(2*this.mKeys.length);for(let t=this.n;t>s;--t)this.mKeys[t]=this.mKeys[t-1],this.vals[t]=this.vals[t-1];this.n+=1,this.mKeys[s]=t,this.vals[s]=e}}}delete(t){if(this._argOk(t)&&this.isEmpty());else{let s=this.rank(t);if(s==this.n||0!=this.compare(this.mKeys[s],t));else{for(let t=s;t<this.n-1;++t)this.mKeys[t]=this.mKeys[t+1],this.vals[t]=this.vals[t+1];this.n-=1,this.mKeys[this.n]=e,this.vals[this.n]=e,this.n>0&&this.n==i.ndiv(this.mKeys.length,4)&&this._resize(i.ndiv(this.mKeys.length,2)),this._check()}}}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.min())}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.max())}min(){if(this.isEmpty())throw Error("called min with empty symbol table");return this.mKeys[0]}max(){if(this.isEmpty())throw Error("called max with empty symbol table");return this.mKeys[this.n-1]}select(t){if(t<0||t>=this.size())throw Error(`called select with invalid argument: ${t}`);return this.mKeys[t]}floor(t){let e=this._argOk(t)&&this.rank(t);if(e<this.n&&0==this.compare(t,this.mKeys[e]))return this.mKeys[e];if(0==e)throw Error("argument to floor is too small");return this.mKeys[e-1]}ceiling(t){let e=this._argOk(t)&&this.rank(t);if(e==this.n)throw Error("argument to ceiling is too large");return this.mKeys[e]}size(t,e){return 0==arguments.length?this.n:(this._argOk(t)&&this._argOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}keys(t,e){0==arguments.length&&(t=this.min(),e=this.max()),this._argOk(t)&&this._argOk(e);let s=new l;if(this.compare(t,e)>0);else{for(let i=this.rank(t);i<this.rank(e);++i)s.enqueue(this.mKeys[i]);this.contains(e)&&s.enqueue(this.mKeys[this.rank(e)])}return s.iter()}static load(t,e){let s=new m(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t=m.load("SEARCHEXAMPLE".split(""),a),e=e=>{e="";for(let s,i=t.keys();i.hasNext();)s=i.next(),e+=`${s}=${t.get(s)} `;return e};console.log(e()),t.deleteMin(),console.log(e()),t.deleteMax(),t.isEmpty(),console.log(e()),console.log("floor of Q= "+t.floor("Q")),console.log("ceil of Q= "+t.ceiling("Q")),console.log("size= "+t.size()),console.log("size= "+t.size("E","P")),console.log("keys E->P = "+c(t.keys("E","P")))}}class y{constructor(t){this.compare=t,this.root=e,this._argOk=t=>f.assert(t,"Invalid argument"),this._check=()=>(this.isBST(this.root,null,null)||console.log("Not in symmetric order"),this.isSizeConsistent(this.root)||console.log("Subtree counts not consistent"),this.isRankConsistent()||console.log("Ranks not consistent"),this.isBST(this.root,null,null)&&this.isSizeConsistent(this.root)&&this.isRankConsistent()),this.isBST=(t,e,s)=>!!f.nichts(t)||!(f.echt(e)&&this.compare(t.key,e)<=0)&&(!(f.echt(s)&&this.compare(t.key,s)>=0)&&(this.isBST(t.left,e,t.key)&&this.isBST(t.right,t.key,s))),this.isSizeConsistent=t=>!!f.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(this.isSizeConsistent(t.left)&&this.isSizeConsistent(t.right)),this.isRankConsistent=()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this.rank(t))))return!1;return!0}}Node(t,e,s){return{key:t,val:e,size:s}}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){return this._getNode(this.root,t)}_getNode(t,e){if(!this._argOk(e)||!f.nichts(t)){let s=this.compare(e,t.key);return s<0?this._getNode(t.left,e):s>0?this._getNode(t.right,e):t.val}}put(t,e){this._argOk(t)&&f.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this._check())}_putNode(t,e,s){if(f.nichts(t))t=this.Node(e,s,1);else{let i=this.compare(e,t.key);i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right)}return t}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMinNode(this.root),this._check()}_deleteMinNode(t){return f.nichts(t.left)?t=t.right:(t.left=this._deleteMinNode(t.left),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMaxNode(this.root),this._check()}_deleteMaxNode(t){return f.nichts(t.right)?t=t.left:(t.right=this._deleteMaxNode(t.right),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}delete(t){this.root=this._argOk(t)&&this._deleteNode(this.root,t),this._check()}_deleteNode(t,e){if(f.echt(t)){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(f.nichts(t.right))return t.left;if(f.nichts(t.left))return t.right;let e=t;(t=this._minNode(e.right)).right=this._deleteMinNode(e.right),t.left=e.left}t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1}return t}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return f.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return f.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(f.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0)return this._floorNode(t.left,e);let i=this._floorNode(t.right,e);return f.nichts(i)?t:i}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too large");return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0){let e=this._ceilingNode(t.left,s);return e||t}return this._ceilingNode(t.right,s)}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(f.nichts(t));else{let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}_sizeNode(t){return f.nichts(t)?0:t.size}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}height(){return this._heightNode(this.root)}_heightNode(t){return f.nichts(t)?-1:1+Math.max(this._heightNode(t.left),this._heightNode(t.right))}levelOrder(){let t,e=[],s=new l;for(e.push(this.root);e.length>0;)t=e.pop(),f.echt(t)&&(s.enqueue(t.key),e.push(t.left,t.right));return s.iter()}static load(t,e){let s=new y(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=y.load("SEARCHEXAMPLE".split(""),a);t="";for(let s,i=e.levelOrder();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("level-order:\n"+t),t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;e.isEmpty(),console.log("keys=\n"+t),console.log("size="+e.size()),console.log("size E->Q = ",e.size("E","Q")),t="";for(let s,i=e.keys("E","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[E->Q]= "+t),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank P= "+e.rank("P")),console.log("contains X= "+e.contains("X")),console.log("contains Z= "+e.contains("Z")),e.delete("X"),console.log("get C="+e.get("C")),console.log("max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("height= "+e.height()),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank E= "+e.rank("E")),console.log("floor G= "+e.floor("G")),console.log("ceiling G= "+e.ceiling("G"))}}class v{static BLACK=!1;static RED=!0;constructor(t){this.compare=t,this.root=e,this._argOk=t=>f.assert(t,"Invalid argument"),this._check=()=>{let t=(e,s,i)=>!!f.nichts(e)||!(s&&this.compare(e.key,s)<=0)&&(!(i&&this.compare(e.key,i)>=0)&&(t(e.left,s,e.key)&&t(e.right,e.key,i))),e=t=>!!f.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(e(t.left)&&e(t.right)),s=t=>!!f.nichts(t)||!this._isRed(t.right)&&((t===this.root||!this._isRed(t)||!this._isRed(t.left))&&(s(t.left)&&s(t.right))),i=(t,e)=>f.nichts(t)?0==e:(this._isRed(t)||--e,i(t.left,e)&&i(t.right,e));return t(this.root,null,null)&&e(this.root)&&(()=>{for(let t=0;t<this.size();++t)if(t!=this._rankNode(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this._rankNode(t))))return!1;return!0})()&&s(this.root)&&(()=>{let t=0,e=this.root;for(;e;)this._isRed(e)||++t,e=e.left;return i(this.root,t)})()}}Node(t,e,s,i){return{key:t,val:e,color:s,size:i}}_isRed(t){return!f.nichts(t)&&t.color===v.RED}_sizeNode(t){return f.nichts(t)?0:t.size}isEmpty(){return f.nichts(this.root)}get(t){return this._argOk(t)&&this._getNode(this.root,t)}_getNode(t,e){for(;t;){let s=this.compare(e,t.key);if(s<0)t=t.left;else{if(!(s>0))return t.val;t=t.right}}}contains(t){return void 0!==this.get(t)}put(t,e){this._argOk(t)&&f.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.root.color=v.BLACK)}_putNode(t,e,s){if(f.nichts(t))return this.Node(e,s,v.RED,1);let i=this.compare(e,t.key);return i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}deleteMin(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=v.RED),this.root=this._deleteMinNode(this.root),this.isEmpty()||(this.root.color=v.BLACK)}_deleteMinNode(t){return f.nichts(t.left)?null:(this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteMinNode(t.left),this._balance(t))}deleteMax(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=v.RED),this.root=this._deleteMaxNode(this.root),this.isEmpty()||(this.root.color=v.BLACK)}_deleteMaxNode(t){return this._isRed(t.left)&&(t=this._rotateRight(t)),f.nichts(t.right)?null:(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),t.right=this._deleteMaxNode(t.right),this._balance(t))}delete(t){this._argOk(t)&&!this.contains(t)||(this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=v.RED),this.root=this._deleteNode(this.root,t),this.isEmpty()||(this.root.color=v.BLACK))}_deleteNode(t,e){if(this.compare(e,t.key)<0)this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteNode(t.left,e);else{if(this._isRed(t.left)&&(t=this._rotateRight(t)),0==this.compare(e,t.key)&&f.nichts(t.right))return null;if(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),0==this.compare(e,t.key)){let e=this._minNode(t.right);t.key=e.key,t.val=e.val,t.right=this._deleteMinNode(t.right)}else t.right=this._deleteNode(t.right,e)}return this._balance(t)}_rotateRight(t){if(f.nichts(t)||!this._isRed(t.left))throw Error("bad input to rotateRight");let e=t.left;return t.left=e.right,e.right=t,e.color=e.right.color,e.right.color=v.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_rotateLeft(t){if(f.nichts(t)||!this._isRed(t.right))throw Error("bad input to rotateLeft");let e=t.right;return t.right=e.left,e.left=t,e.color=e.left.color,e.left.color=v.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_flipColors(t){t.color=!t.color,t.left.color=!t.left.color,t.right.color=!t.right.color}_moveRedLeft(t){return this._flipColors(t),this._isRed(t.right.left)&&(t.right=this._rotateRight(t.right),t=this._rotateLeft(t),this._flipColors(t)),t}_moveRedRight(t){return this._flipColors(t),this._isRed(t.left.left)&&(t=this._rotateRight(t),this._flipColors(t)),t}_balance(t){return this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}height(){return this._height(this.root)}_height(t){return f.nichts(t)?-1:1+Math.max(this._height(t.left),this._height(t.right))}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return f.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return f.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(f.nichts(e))throw Error("argument to ceiling is too small");return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}static load(t,e){let s=new v(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=v.load("SEARCHEXAMPLE".split(""),a);t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log(t),e.isEmpty(),console.log("height= "+e.height()+", size= "+e.size()),console.log("get X= "+e.get("X")),console.log("contains X= "+e.contains("X")),console.log("min= "+e.min()+",max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("min= "+e.min()+",max= "+e.max()),e.delete("R"),console.log("contains R= "+e.contains("R")),console.log("floor J= "+e.floor("J")),console.log("ceiling J= "+e.ceiling("J")),console.log("rank M= "+e.rank("M")),t="";for(let s,i=e.keys("D","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[D-Q]= "+t),console.log("size[E-P]= "+e.size("E","P"))}}class w{static indexOf(t,e){let s=0,r=t.length-1;for(;s<=r;){let n=s+i.ndiv(r-s,2);if(e<t[n])r=n-1;else{if(!(e>t[n]))return n;s=n+1}}return-1}static test(){let t="84 48 68 10 18 98 12 23 54 57 33 16 77 11 29".split(" ").map((t=>+t)).sort();"23 50 10 99 18 23 98 84 11 10 48 77 13 54 98 77 77 68".split(" ").map((t=>+t)).forEach((e=>{w.indexOf(t,e)<0&&console.log(e)}))}}class x{Node(t,e,s,i){return{key:t,val:e,height:s,size:i}}constructor(t){this.compare=t,this.root=e}isEmpty(){return f.nichts(this.root)}_sizeNode(t){return f.nichts(t)?0:t.size}height(){return this._heightNode(this.root)}_heightNode(t){return f.nichts(t)?-1:t.height}get(t){if(f.nichts(t))throw Error("argument to get() is null");let e=this._getNode(this.root,t);if(e)return e.val}_getNode(t,s){if(!t)return e;let i=this.compare(s,t.key);return i<0?this._getNode(t.left,s):i>0?this._getNode(t.right,s):t}contains(t){return void 0!==this.get(t)}put(t,e){if(f.nichts(t))throw Error("first argument to put() is null");void 0===e?this.delete(t):this.root=this._putNode(this.root,t,e)}_putNode(t,e,s){if(!t)return this.Node(e,s,0,1);let i=this.compare(e,t.key);if(i<0)t.left=this._putNode(t.left,e,s);else{if(!(i>0))return t.val=s,t;t.right=this._putNode(t.right,e,s)}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balanceNode(t)}_balanceNode(t){return this._balanceFactor(t)<-1?(this._balanceFactor(t.right)>0&&(t.right=this._rotateRight(t.right)),t=this._rotateLeft(t)):this._balanceFactor(t)>1&&(this._balanceFactor(t.left)<0&&(t.left=this._rotateLeft(t.left)),t=this._rotateRight(t)),t}_balanceFactor(t){return this._heightNode(t.left)-this._heightNode(t.right)}_rotateRight(t){let e=t.left;return t.left=e.right,e.right=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}_rotateLeft(t){let e=t.right;return t.right=e.left,e.left=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}delete(t){if(f.nichts(t))throw Error("argument to delete() is null");this.contains(t)&&(this.root=this._deleteNode(this.root,t))}_deleteNode(t,e){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(!t.left)return t.right;if(!t.right)return t.left;let e=t;(t=this.min(e.right)).right=this.deleteMin(e.right),t.left=e.left}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)}deleteMin(){if(this.isEmpty())throw Error("called deleteMin() with empty symbol table");this.root=this._deleteMinNode(this.root)}_deleteMinNode(t){return t.left?(t.left=this._deleteMinNode(t.left),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.right}deleteMax(){if(this.isEmpty())throw Error("called deleteMax() with empty symbol table");this.root=this._deleteMaxNode(this.root)}_deleteMaxNode(t){return t.right?(t.right=this._deleteMaxNode(t.right),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.left}min(){if(this.isEmpty())throw Error("called min() with empty symbol table");return this._minNode(this.root).key}_minNode(t){return t.left?this._minNode(t.left):t}max(){if(this.isEmpty())throw Error("called max() with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return t.right?this._maxNode(t.right):t}floor(t){if(f.nichts(t))throw Error("argument to floor() is null");if(this.isEmpty())throw Error("called floor() with empty symbol table");let e=this._floorNode(this.root,t);if(e)return e.key}_floorNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(f.nichts(t))throw Error("argument to ceiling() is null");if(this.isEmpty())throw Error("called ceiling() with empty symbol table");let e=this._ceilingNode(this.root,t);if(e)return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error("k is not in range 0-"+(this.size()-1));let e=this._selectNode(this.root,t);if(e)return e.key}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t}rank(t){if(f.nichts(t))throw Error("argument to rank() is null");return this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keysInOrder(){let t=new l;return this._keysInOrderNode(this.root,t),t.iter()}_keysInOrderNode(t,e){f.nichts(t)||(this._keysInOrderNode(t.left,e),e.enqueue(t.key),this._keysInOrderNode(t.right,e))}keysLevelOrder(){let t=new l;if(!this.isEmpty()){let e=new l;for(e.enqueue(this.root);!e.isEmpty();){let s=e.dequeue();t.enqueue(s.key),s.left||e.enqueue(s.left),s.right&&e.enqueue(s.right)}}return t}keys(t,e){if(0==arguments.length)return this.keysInOrder();if(f.nichts(t))throw Error("first argument to keys() is null");if(f.nichts(e))throw Error("second argument to keys() is null");let s=new l;return this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}}size(t,e){if(0==arguments.length)return this._sizeNode(this.root);if(f.nichts(t))throw Error("first argument to size() is null");if(f.nichts(e))throw Error("second argument to size() is null");return this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}_check(){let t=this;return function e(s,i,r){return!s||!(!i&&t.compare(s.key,i)<=0)&&(!(!r&&t.compare(s.key,r)>=0)&&(e(s.left,i,s.key)&&e(s.right,s.key,r)))}(this.root,null,null)&&function e(s){if(!s)return!0;let i=t._balanceFactor(s);return!(i>1||i<-1)&&(e(s.left)&&e(s.right))}(this.root)&&function e(s){return!s||s.size==t._sizeNode(s.left)+t._sizeNode(s.right)+1&&(e(s.left)&&e(s.right))}(this.root)&&function(){for(let e=0;e<t.size();e++)if(e!=t.rank(t.select(e)))return!1;for(let e,s=t.keys().iterator();s.hasNext();)if(e=s.next(),0!=this.compare(e,t.select(t.rank(key))))return!1;return!0}()}static test(){let t=new x(a);"SEARCHEXAMPLE".split("").forEach(((e,s)=>t.put(e,s)));for(let e,s=t.keys();s.hasNext();)e=s.next(),console.log(e+" "+t.get(e))}}const _=Math.sqrt(2);function N(t,e){return{parent:e,pos:t,f:0,g:0,h:0,pid:`${t[0]},${t[1]}`,equals(t){return this.pos[0]==t.pos[0]&&this.pos[1]==t.pos[1]}}}class b{static manhattan(t,e,s=1){return s*Math.abs(t[1]-e[1])+s*Math.abs(t[0]-e[0])}static euclidean(t,e,s=1){let i=e[0]-t[0],r=e[1]-t[1];return s*(i*i+r*r)}static diagonal(t,e,s=1,i=_){let r=Math.abs(e[0]-t[0]),n=Math.abs(e[1]-t[1]);return s*(r+n)+(i-2*s)*Math.min(r,n)}constructor(t){this.grid=t}pathTo(t,e,s){return this._search(this.grid,t,e,s)}_search(t,e,s,i){const r=i.compare,n=t.length,o=t[0].length,h=new Map,l=new Map,a=new u(r,10),c=N(s),d=N(e),f=[[1,0],[-1,0],[0,1],[0,-1]],g=(t,e)=>{for(;t;t=t.parent)e.unshift(t.pos);return e};i.wantDiagonal&&f.push([1,1],[1,-1],[-1,1],[-1,-1]),l.set(d.pid,d.g),a.insert(d);let p,m=[];for(;!a.isEmpty();){if(p=a.delMin(),l.delete(p.pid),h.set(p.pid,0),p.equals(c))return g(p,[]);m.length=0;for(let t,e=0;e<f.length;++e)t=[p.pos[0]+f[e][0],p.pos[1]+f[e][1]],t[0]>o-1||t[0]<0||t[1]>n-1||t[1]<0||i.blocked(t)||m.push(N(t,p));m.forEach((t=>{h.has(t.pid)||(t.g=p.g+i.cost(),t.h=i.calcHeuristic(t.pos,c.pos),t.f=t.g+t.h,l.has(t.pid)&&t.g>l.get(t.pid)||(a.insert(t),l.set(t.pid,t.g)))}))}}static test(){let t,e,s,i=[[0,1,0,0,0,0],[0,0,0,0,0,0],[0,1,0,1,0,0],[0,1,0,0,1,0],[0,0,0,0,1,0]],r=i.length,n=i[0].length,o={wantDiagonal:!1,compare:(t,e)=>t.f-e.f,cost:()=>1,blocked:t=>0!=i[t[1]][t[0]],calcHeuristic:(t,e)=>b.euclidean(t,e)},h=new b(i).pathTo([0,0],[5,4],o);h?(s="",h.forEach((t=>{s+=`[${t[0]},${t[1]}] `})),console.log(s),e=f.fill(r,(()=>f.fill(n,"#"))),t=0,h.forEach((s=>{e[s[1]][s[0]]=""+t,++t})),e.forEach((t=>{console.log(t.toString())}))):console.log("no path")}}return{AStarGrid:b,AVLTreeST:x,RedBlackBST:v,BST:y,BinarySearch:w,BinarySearchST:m,FrequencyCounter:g,SequentialSearchST:p}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/search"]=s}(this),function(t,e){"use strict";function s(s,i,r,n){r||(r=t["io/czlab/mcfud/algo/basic"]()),n||(n=t["io/czlab/mcfud/algo/sort"]()),s||(s=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]());const{prnIter:o,TreeMap:h,Bag:l,Stack:a,Queue:c,ST:u,StdCompare:d}=r,{IndexMinPQ:f,MinPQ:g}=n,{is:p,u:m}=(Math.floor,s);function y(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`);return!0}class v{constructor(t){m.assert(t>=0,"Number of vertices must be non-negative"),this.verts=t,this.edges=0,this.adjls=m.fill(t,(()=>new l))}clone(){let t=new v(this.V());t.edges=this.E(),t.adjls=[];for(let e=0,s=this.V();e<s;++e)t.adjls.push(this.adjls[e].clone());return t}V(){return this.verts}E(){return this.edges}addEdge(t,e){y(t,this.verts),y(e,this.verts),this.edges+=1,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return y(t,this.verts)&&this.adjls[t]}degree(t){return y(t,this.verts)&&this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e=0;e<this.verts;++e)t+=`${e}: `+o(this.adjls[e].iter()),t+="\n";return t}static load(t,e){let s=new v(t);m.assert(e.length%2==0,"wanted even n# of data points");for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}static test(){let t=v.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);t.degree(1),console.log(t.toString());let e=t.clone();console.log("cloned=\n"+e.toString())}}class w{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.nCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.nCount}static test(){let t,e,s=v.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new w(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t),console.log(e.count()!=s.V()?"NOT connected":"connected")}))}}class x{constructor(t,e){this.bMarked=new Array(t.V()),y(e,this.bMarked.length);let s,i,r=m.fill(t.V(),(e=>t.adj(e).iter())),n=new a;for(this.bMarked[e]=!0,n.push(e);!n.isEmpty();)s=n.peek(),r[s].hasNext()?(i=r[s].next(),this.bMarked[i]||(this.bMarked[i]=!0,n.push(i))):n.pop()}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}static test(){let t,e,s=v.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new x(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t)}))}}class _{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new a;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t=v.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new _(t,0);for(let s,i,r=0;r<t.V();++r)if(e.hasPathTo(r)){s=`0 to ${r}:  `;for(let t=e.pathTo(r);t.hasNext();)i=t.next(),s+=0==i?i:`-${i}`;console.log(s)}else console.log(`0 to ${r}:  not connected\n`)}}function N(t,e,s){let i,r=[];for(i=0;i<t.V();++i)s.mDistTo[i]=1/0;for(e.forEach((t=>{s.bMarked[t]=!0,s.mDistTo[t]=0,r.push(t)}));r.length>0;){i=r.shift();for(let e,n=t.adj(i).iter();n.hasNext();)e=n.next(),s.bMarked[e]||(s.edgeTo[e]=i,s.mDistTo[e]=s.mDistTo[i]+1,s.bMarked[e]=!0,r.push(e))}}function b(t,e){if(!t||0==t.length)throw Error("argument is null or empty");return t.forEach((t=>y(t,e))),!0}class k{constructor(t,e){this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V()),p.vec(e)||(e=[e]),b(e,t.V()),N(t,e,this),function(t,e,s){if(0!=s.mDistTo[e])throw Error(`dist of source ${e} to itself = ${s.mDistTo[e]}`);for(let e=0;e<t.V();++e)for(let i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s.hasPathTo(e)!==s.hasPathTo(i))throw Error(`edge ${e}-${i}hasPathTo(${e})=${s.hasPathTo(e)}hasPathTo(${i})=${s.hasPathTo(i)}`);if(s.hasPathTo(e)&&s.mDistTo[i]>s.mDistTo[e]+1)throw Error(`edge ${e}-${i}distTo[${e}]=${s.mDistTo[e]}distTo[${i}]=${s.mDistTo[i]}`)}for(let i,r=0;r<t.V();++r)if(s.hasPathTo(r)&&r!=e&&(i=s.edgeTo[r],s.mDistTo[r]!=s.mDistTo[i]+1))throw Error(`shortest path edge ${i}-${r} distTo[${i}]= ${s.mDistTo[i]}distTo[${r}]= ${s.mDistTo[r]}`)}(t,e,this)}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new a;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t=v.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new k(t,0);for(let s,i=0;i<t.V();++i)if(e.hasPathTo(i)){s=`0 to ${i}(${e.distTo(i)}): `;for(let t,r=e.pathTo(i);r.hasNext();)t=r.next(),s+=0==t?`${t}`:`-${t}`;console.log(s)}else console.log(`0 to ${i} (-):  not connected\n`)}}class E{constructor(t,e,s){if(t<0)throw Error("vertex index must be a non-negative integer");if(e<0)throw Error("vertex index must be a non-negative integer");this.v=t,this.w=e,this._weight=s}weight(){return this._weight}either(){return this.v}other(t){if(t==this.v)return this.w;if(t==this.w)return this.v;throw Error("Illegal endpoint")}static comparator(t,e){return t._weight<e._weight?-1:t._weight>e._weight?1:0}toString(){return`${this.v}-${this.w} ${this._weight}`}static test(){console.log(new E(12,34,5.67).toString())}}class M{constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this._V=t,this._E=0,this.adjls=m.fill(t,(()=>new l))}static randGraph(t,e){let s=new M(t);if(e<0)throw Error("Number of edges must be non-negative");for(let i,r,n,o=0;o<e;++o)r=m.randInt(t),n=m.randInt(t),i=Math.round(100*m.rand())/100,s.addEdge(new E(r,n,i));return s}clone(){let t=new M(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){let e=t.either(),s=t.other(e);y(e,this._V),y(s,this._V),this.adjls[e].add(t),this.adjls[s].add(t),this._E+=1}adj(t){return y(t,this._V)&&this.adjls[t]}degree(t){return y(t,this._V)&&this.adjls[t].size()}edges(){const t=new l;for(let e,s,i,r=0;r<this._V;++r)for(s=0,e=this.adjls[r].iter();e.hasNext();)i=e.next(),i.other(r)>r?t.add(i):i.other(r)==r&&(s%2==0&&t.add(i),++s);return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()}, `;t+="\n"}return t}static load(t,e){let s=new M(t);m.assert(e.length%3==0,"Invalid data size");for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new E(e[i],e[i+1],e[i+2]));return s}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38 2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34 6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(" ").map((t=>+t)),e=M.load(8,t);console.log(e.toString())}}class T{constructor(t){this.bMarked=new Array(t.V()),this._id=new Array(t.V()),this._size=new Array(t.V()),this.nCount=0;for(let e=0;e<t.V();++e)this.bMarked[e]||(this._dfs(t,e),++this.nCount)}_dfs(t,e){this.bMarked[e]=!0,this._id[e]=this.nCount,this._size[this.nCount]+=1;for(let s,i,r=t.adj(e).iter();r.hasNext();)s=r.next(),t instanceof M?(i=s.other(e),this.bMarked[i]||this._dfs(t,i)):this.bMarked[s]||this._dfs(t,s)}id(t){return y(t,this.bMarked.length)&&this._id[t]}size(t){return y(t,this.bMarked.length)&&this._size[this._id[t]]}count(){return this.nCount}connected(t,e){return y(t,this.bMarked.length)&&y(e,this.bMarked.length)&&this.id(t)==this.id(e)}static test(){let t=v.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]),e=new T(t),s=e.count();console.log(s+" components");let i=m.fill(s,(()=>[]));for(let s=0;s<t.V();++s)i[e.id(s)].push(s);for(let t,e=0;e<s;++e)t="",i[e].forEach((e=>t+=e.toString()+" ")),console.log(t)}}class S{static load(t,e){if(t<0)throw Error("verts in a Digraph must be non-negative");m.assert(e.length%2==0,"expected even n# of data-length");let s=new S(t);for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}constructor(t){if(t<0)throw Error("verts in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=m.fill(t,0),this.adjls=m.fill(t,(()=>new l))}clone(){let t=this,e=new S(this.V());e._E=this.E(),e._indegree=m.fill(e.V(),(e=>t._indegree[e]));for(let t=0;t<e.V();++t)e.adjls[t]=this.adjls[t].clone();return e}V(){return this._V}E(){return this._E}addEdge(t,e){y(t,this._V)&&y(e,this._V),this.adjls[t].add(e),this._indegree[e]+=1,++this._E}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}reverse(){let t=new S(this._V);for(let e,s=0;s<this._V;++s)for(e=this.adjls[s].iter();e.hasNext();)t.addEdge(e.next(),s);return t}toString(){let t=`${this._V} vertices, ${this._E} edges\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()} `;t+="\n"}return t}static test(){let t=S.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s="";for(let i=0;i<t.V();++i)e+=`${i}=${t.indegree(i)}, `,s+=`${i}=${t.outdegree(i)},`;console.log("indegreee= "+e),console.log("outdegreee= "+s),console.log(t.toString());let i=t.clone();console.log("cloned=\n"+i.toString());let r=t.reverse();console.log("rev'ed=\n"+r.toString())}}class q{constructor(t,e){this.bMarked=new Array(t.V()),p.vec(e)||(e=[e]),b(e,t.V()),e.forEach((e=>{this.bMarked[e]||this._dfs(t,e)}))}_dfs(t,e){this.mCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.mCount}static test(){let t=S.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s=new q(t,[1,2,6]);for(let i=0;i<t.V();++i)s.marked(i)&&(e+=`${i} `);s.count(),console.log(e)}}class I{constructor(t){this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V()),this.mCycle=e;for(let e=0;e<t.V();++e)this.bMarked[e]||this.mCycle||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();){if(s=i.next(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new a;for(let t=e;t!=s;t=this.edgeTo[t])this.mCycle.push(t);this.mCycle.push(s),this.mCycle.push(e),this._check()}}else this.edgeTo[s]=e,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return!!this.mCycle}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=-1,e=-1;for(let s,i=this.cycle();i.hasNext();)s=i.next(),-1==t&&(t=s),e=s;if(t!=e)throw Error(`cycle begins with ${t} and ends with ${e}\n`)}return!0}static test(){let t="2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)),e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9\n               10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8\n               6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t));[new I(S.load(13,e)),new I(S.load(13,t))].forEach((t=>{t.hasCycle()?(console.log("Directed cycle: "),console.log(o(t.cycle()))):console.log("No directed cycle")}))}}class O{constructor(t,e,s){if(t<0)throw Error("Vertex names must be non-negative integers");if(e<0)throw Error("Vertex names must be non-negative integers");this.v=t,this.w=e,this._weight=s}from(){return this.v}to(){return this.w}weight(){return this._weight}toString(){return`${this.v}->${this.w} ${Number(this._weight).toFixed(2)}`}static test(){console.log(new O(12,34,5.67).toString())}}class A{constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=m.fill(t,(()=>new l))}static randGraph(t,e){if(e<0)throw Error("n# edges in a Digraph must be non-negative");let s=new A(t);for(let i=0;i<e;++i)s.addEdge(new O(m.randInt(t),m.randInt(t),.01*_randInt(100)));return s}static load(t,e){if(t<0)throw Error("n# vertices in a Digraph must be non-negative");m.assert(e.length%3==0,"bad data length");let s=new A(t);for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new O(e[i],e[i+1],e[i+2]));return s}clone(){let t=new A(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t._indegree[e]=this._indegree(e);for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){m.assert(t instanceof O,"Expected DirectedEdge");let e=t.to(),s=t.from();y(s,this._V),y(e,this._V),this.adjls[s].add(t),this._indegree[e]+=1,this._E++}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}edges(){const t=new l;for(let e=0;e<this._V;++e)for(let s=this.adj(e).iter();s.hasNext();)t.add(s.next());return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e=0;e<this._V;++e)t+=`${e}: `+o(this.adjls[e].iter())+"\n";return t}static test(){let t="4 5 0.35\n        5 4 0.35\n        4 7 0.37\n        5 7 0.28\n        7 5 0.28\n        5 1 0.32\n        0 4 0.38\n        0 2 0.26\n        7 3 0.39\n        1 3 0.29\n        2 7 0.34\n        6 2 0.40\n        3 6 0.52\n        6 0 0.58\n        6 4 0.93".split(/\s+/).map((t=>+t)),e=A.load(8,t);console.log(e.toString())}}class z{constructor(t){this._pre=new Array(t.V()),this._post=new Array(t.V()),this.preCounter=0,this.postCounter=0,this.postorder=new c,this.preorder=new c,this.bMarked=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.bMarked[e]=!0,this._pre[e]=this.preCounter++,this.preorder.enqueue(e);for(let s,i=t.adj(e).iter();i.hasNext();)s=t instanceof A?i.next().to():i.next(),this.bMarked[s]||this._dfs(t,s);this.postorder.enqueue(e),this._post[e]=this.postCounter++}pre(t){return y(t,this.bMarked.length)&&this._pre[t]}post(t){return y(t,this.bMarked.length)&&this._post[t]}postOrder(){return this.postorder.iter()}preOrder(){return this.preorder.iter()}reversePost(){let t=new a;for(let e=this.postorder.iter();e.hasNext();)t.push(e.next());return t.iter()}_check(){let t,e=0;for(t=this.postOrder();t.hasNext();){if(this.post(t.next())!=e)throw Error("post(v) and post() inconsistent");++e}for(e=0,t=this.preOrder();t.hasNext();){if(this.pre(t.next())!=e)throw Error("pre(v) and pre() inconsistent");++e}return!0}static test(){let t=S.load(13,"2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)));console.log(t.toString());let e=new z(t);console.log("   v  pre  post"),console.log("--------------");for(let s=0;s<t.V();++s)console.log(`    ${s}  ${e.pre(s)}  ${e.post(s)}\n`);console.log("Preorder:  "),console.log(o(e.preOrder())),console.log("Postorder:  "),console.log(o(e.postOrder())),console.log(""),console.log("Reverse postorder: "),console.log(o(e.reversePost()))}}class C{constructor(t){m.assert(t instanceof A,"Expected EdgeWeightedDigraph"),this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s=i.to(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new a;let t=i;for(;t.from()!=s;)this.mCycle.push(t),t=this.edgeTo[t.from()];return void this.mCycle.push(t)}}else this.edgeTo[s]=i,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return m.echt(this.mCycle)}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=e,s=e;for(let e,i=this.cycle();i.hasNext();){if(e=i.next(),t||(t=e),s&&s.to()!=e.from())throw Error(`cycle edges ${s} and ${e} not incident\n`);s=e}if(s.to()!=t.from())throw Error(`cycle edges ${s} and ${t} not incident\n`)}return!0}static test(){let t=13,e=new A(t);m.shuffle(m.fill(t,(t=>t)));for(let s,i,r,n=0;n<8;++n){do{i=m.randInt(t),r=m.randInt(t)}while(i>=r);s=m.rand(),e.addEdge(new O(i,r,s))}for(let s=0;s<6;++s)e.addEdge(new O(m.randInt(t),m.randInt(t),m.rand()));console.log(e.toString());let s=new C(e);s.hasCycle()?console.log("Cycle: "+o(s.cycle())):console.log("No directed cycle")}}class P{constructor(t){this.st=new u,t.forEach((t=>t.forEach(((t,e)=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this._graph=new v(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s,i=1;i<t.length;++i)s=this.st.get(t[i]),this._graph.addEdge(e,s)}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this._graph.V())&&this.keys[t]}graph(){return this._graph}static test(){let t="JFK MCO\n                  ORD DEN\n                  ORD HOU\n                  DFW PHX\n                  JFK ATL\n                  ORD DFW\n                  ORD PHX\n                  ATL HOU\n                  DEN PHX\n                  PHX LAX\n                  JFK ORD\n                  DEN LAS\n                  DFW HOU\n                  ORD ATL\n                  LAS LAX\n                  ATL MCO\n                  HOU MCO\n                  LAS PHX".split(/\s+/),e=new P(m.partition(2,t)),s=e.graph();["JFK","LAX"].forEach((t=>{if(e.contains(t)){let i=e.indexOf(t);console.log(t);for(let t=s.adj(i).iter();t.hasNext();)console.log("   "+e.nameOf(t.next()))}else console.log("input not contain '"+t+"'")}))}}class D{constructor(t){this.st=new u,t.forEach((t=>t.forEach((t=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this.graph=new S(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s=1;s<t.length;++s)this.graph.addEdge(e,this.st.get(t[s]))}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this.graph.V())&&this.keys[t]}digraph(){return this.graph}static test(){let t="JFK MCO\n              ORD DEN\n              ORD HOU\n              DFW PHX\n              JFK ATL\n              ORD DFW\n              ORD PHX\n              ATL HOU\n              DEN PHX\n              PHX LAX\n              JFK ORD\n              DEN LAS\n              DFW HOU\n              ORD ATL\n              LAS LAX\n              ATL MCO\n              HOU MCO\n              LAS PHX".split(/\s+/),e=new D(m.partition(2,t)),s=e.digraph();["JFK","ATL","LAX"].forEach((t=>{console.log(`${t}`);let i=s.adj(e.indexOf(t)).iter();for(;i.hasNext();)console.log("   "+e.nameOf(i.next()))}))}}class R{constructor(t){let s;if(this._order=e,this.rank=e,t instanceof A?s=new C(t):t instanceof S?(s=new I(t),s.hasCycle()||(this.rank=new Array(t.V()))):m.assert(!1,"bad arg for Topological"),s&&!s.hasCycle()){this._order=new c;for(let e,s=0,i=new z(t).reversePost();i.hasNext();)e=i.next(),this.rank&&(this.rank[e]=s++),this._order.enqueue(e)}}order(){return this._order.iter()}hasOrder(){return m.echt(this._order)}rank(t){return this.rank&&y(t,this.rank.length)&&this.hasOrder()?this.rank[t]:-1}static test(){let t=new D([["Algorithms","Theoretical CS","Databases","Scientific Computing"],["Introduction to CS","Advanced Programming","Algorithms"],["Advanced Programming","Scientific Computing"],["Scientific Computing","Computational Biology"],["Theoretical CS","Computational Biology","Artificial Intelligence"],["Linear Algebra","Theoretical CS"],["Calculus","Linear Algebra"],["Artificial Intelligence","Neural Networks","Robotics","Machine Learning"],["Machine Learning","Neural Networks"]]);for(let e=new R(t.digraph()).order();e.hasNext();)console.log(t.nameOf(e.next()))}}class ${constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new a;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=S.load(13,e),i=new $(s,3);for(let e=0;e<s.V();++e)if(i.hasPathTo(e)){t=`3 to ${e}:  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`-${s}`;console.log(t)}else console.log(`3 to ${e}:  not connected`)}}class L{constructor(t,e){p.vec(e)||(e=[e]),this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.mDistTo[e]=1/0;b(e,t.V())&&this._bfs(t,e)}_bfs(t,e){let s=new c;for(e.forEach((t=>{this.bMarked[t]=!0,this.mDistTo[t]=0,s.enqueue(t)}));!s.isEmpty();){let e=s.dequeue();for(let i,r=t.adj(e).iter();r.hasNext();)i=r.next(),this.bMarked[i]||(this.edgeTo[i]=e,this.mDistTo[i]=this.mDistTo[e]+1,this.bMarked[i]=!0,s.enqueue(i))}}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new a;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=S.load(13,e),i=new L(s,3);for(let e=0;e<s.V();++e)if(t="",i.hasPathTo(e)){t=`3 to ${e} (${i.distTo(e)}):  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`->${s}`;console.log(t)}else console.log(`3 to ${e} (-):  not connected`)}}class j{constructor(t,e,s){m.assert(t instanceof A,"Expected EdgeWeightedDigraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw Error(`edge ${e} has negative weight`);this._distTo=new Array(t.V()),this.edgeTo=m.fill(t.V(),null),y(e,t.V());for(let e=0;e<t.V();++e)this._distTo[e]=1/0;for(this._distTo[e]=0,this.pq=new f(t.V(),s),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next())}this._check(t,e)}_relax(t){let e=t.from(),s=t.to();this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=new a;for(let s=this.edgeTo[t];s;s=this.edgeTo[s.from()])e.push(s);return e.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.to(),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],e=s.from(),i!=s.to())throw Error("bad edge");if(this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}else;return!0}static test(){let t="4 5 0.35\n                  5 4 0.35\n                  4 7 0.37\n                  5 7 0.28\n                  7 5 0.28\n                  5 1 0.32\n                  0 4 0.38\n                  0 2 0.26\n                  7 3 0.39\n                  1 3 0.29\n                  2 7 0.34\n                  6 2 0.40\n                  3 6 0.52\n                  6 0 0.58\n                  6 4 0.93".split(/\s+/).map((t=>+t)),e=A.load(8,t),s=new j(e,0,d);for(let t=0;t<e.V();++t)s.hasPathTo(t)?console.log(`0 to ${t} (${Number(s.distTo(t)).toFixed(2)})  ${o(s.pathTo(t))}`):console.log(`0 to ${t}         no path\n`)}}class V{constructor(t,e,s){m.assert(t instanceof M,"Expected EdgeWeightedGraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw new Error(`edge ${e} has negative weight`);for(this._distTo=m.fill(t.V(),(()=>1/0)),this._distTo[e]=0,this.compare=s,this.edgeTo=m.fill(t.V(),(()=>null)),y(e,t.V()),this.pq=new f(t.V(),this.compare),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next(),e)}this._check(t,e)}_relax(t,e){let s=t.other(e);this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=t,s=new a;for(let i=this.edgeTo[t];i;i=this.edgeTo[e])s.push(i),e=i.other(e);return s.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.other(e),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],i!=s.either()&&i!=s.other(s.either()))return!1;if(e=s.other(i),this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38\n                  2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34\n                  6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(/\s+/).map((t=>+t)),e=M.load(8,t),s=new V(e,6,d);for(let t,i=0;i<e.V();++i)if(s.hasPathTo(i)){t=`6 to ${i} (${Number(s.distTo(i)).toFixed(2)})  `;for(let e=s.pathTo(i);e.hasNext();)t+=`${e.next()}   `;console.log(t)}else console.log(`6 to ${i}         no path`)}}return{DepthFirstDirectedPaths:$,BreadthFirstDirectedPaths:L,SymbolGraph:P,DijkstraUndirectedSP:V,DijkstraSP:j,Topological:R,SymbolDigraph:D,EdgeWeightedDirectedCycle:C,DepthFirstOrder:z,EdgeWeightedDigraph:A,DirectedEdge:O,DirectedCycle:I,DirectedDFS:q,Digraph:S,CC:T,EdgeWeightedGraph:M,Edge:E,BreadthFirstPaths:k,DepthFirstPaths:_,NonrecursiveDFS:x,DepthFirstSearch:w,Graph:v}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/graph"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());Math.floor;const{u:s,is:i}=e,r={mutationRate:.1,crossOverRate:.7,probTournament:.75,NUM_HIDDEN:1,BIAS:-1,NUM_ELITE:4,TOURNAMENT_SIZE:5,MAX_PERTURBATION:.3,ACTIVATION_RESPONSE:1,NEURONS_PER_HIDDEN:10};class n{constructor(){}gt(t){}lt(t){}eq(t){}clone(){}score(){}update(t){}}class o extends n{constructor(t,e){super(),this.value=t,this.flip=e}gt(t){return this.flip?this.value<t.value:this.value>t.value}eq(t){return this.value==t.value}lt(t){return this.flip?this.value>t.value:this.value<t.value}score(){return this.value}update(t){this.value=t}clone(){return new o(this.value,this.flip)}}class h{constructor(){this.averageScore=0,this.totalScore=0,this.bestScore=0,this.worstScore=0,this.best=undefined}}class l{constructor(t){const e=s.fill(t+1,(()=>s.randMinus1To1()));this.numInputs=e.length,this.activation=0,this.weights=e,this.error=0}}class a{constructor(t,e){this.numNeurons=t,this.neurons=s.fill(t,(()=>new l(e)))}}class c{constructor(t,e){this.fitness=e,this.genes=t,this.age=0}clone(){return new c(this.genes.slice(),this.fitness.clone())}}function u(t){let e=s.randInt(t.length),i=s.randInt(t.length);return e<i?[e,i]:[i,e]}function d(t,e){let i,r=0,n=s.rand(),o=t.map((t=>r+=t.fitness.score()/e));for(i=0;i<o.length-1;++i)if(n>=o[i]&&n<=o[i+1])return t[i];return t[0]}function f(t){let e=s.randInt(t.length),i=s.randInt(t.length);for(;e==i;)i=s.randInt2(0,t.length-1);return s.rand()<r.probTournament?t[e].fitness.gt(t[i].fitness)?t[e]:t[i]:t[e].fitness.lt(t[i].fitness)?t[e]:t[i]}function g(t,e){let s=0,i=1/0,r=new h;function n(t){s=t.fitness.score(),r.bestScore=s,r.best=t}function o(t){i=t.fitness.score(),r.worstScore=i}return e&&(i=0,s=1/0),t.forEach((t=>{e?t.fitness.score()<s?n(t):t.fitness.score()>i&&o(t):t.fitness.score()>s?n(t):t.fitness.score()<i&&o(t),r.totalScore+=t.fitness.score()})),r.averageScore=r.totalScore/t.length,r}function p(t,e="cycles"){let i=t.startTime=s.now();return t[e]=0,i}function m(t){return t.endTime=s.now()}function y(t,e,i,r,n){let o=s.randInt(e.length);for(;e.length>1&&o==t;)o=s.randInt(e.length);let h,l,a=e[t].genes,u=e[o].genes;i?[h,l]=i(a,u):(h=a.slice(),l=u.slice()),r&&(r(h),r(l));let d=n(h,e[t].fitness),f=n(l,e[o].fitness);return d.gt(f)?new c(h,d):new c(l,f)}function v(t,e){let s,i=0;for(;i<t.length&&(s=t[i],!s.fitness.eq(e.fitness)&&!e.fitness.lt(s.fitness));++i);return i}function w(t,{calcFit:e,crossOver:n,create:o,mutate:h}){if(i.num(t))return s.fill(t,(()=>o()));let l,a,u,p,m=[],y=g(t);t.sort(((t,e)=>t.fitness.lt(e.fitness)?-1:t.fitness.gt(e.fitness)?1:0));for(let e=r.NUM_ELITES,s=t.length-1;s>=0&&e>0;--s)m.push(t[s]),--e;for(;m.length<t.length;)void 0!==r.TOURNAMENT_SIZE?(u=f(t),p=f(t)):(u=d(t,y),p=d(t,y)),n?[l,a]=n(u.genes,p.genes):(l=u.genes.slice(),a=p.genes.slice()),h&&(h(l),h(a)),m.push(new c(l,e(l,u.fitness)),new c(a,e(a,p.fitness)));for(;m.length>t.length;)m.pop();return m}return{NeuronLayer:a,Neuron:l,NeuralNet:class{constructor(t,e,i,r){this.layers=function(n){if(i>0){n.push(new a(r,t));for(let t=0;t<i-1;++t)n.push(new a(r,r))}return s.conj(n,new a(e,i>0?r:t))}([]),this.numOfWeights=this.layers.reduce(((t,e)=>t+e.neurons.reduce(((t,e)=>t+e.weights.length),0)),0),this.numOutputs=e,this.numInputs=t,this.numHidden=i,this.neuronsPerHidden=r}putWeights(t){s.assert(t.length>=this.numOfWeights,"bad input to putWeights");let e=0;this.layers.forEach((s=>s.neurons.forEach((s=>s.weights.forEach(((i,r)=>s.weights[r]=t[e++]))))))}getWeights(){const t=[];for(let e=0;e<this.numHidden+1;++e)for(let s=0;s<this.layers[e].numNeurons;++s)for(let i=0;i<this.layers[e].neurons[s].numInputs;++i)t.push(this.layers[e].neurons[s].weights[i]);return t}getNumberOfWeights(){return this.numOfWeights}feedForward(t){return this.update(t)}update(t){s.assert(t.length>=this.numInputs,"invalid input size");let e,i,n,o=[];return this.layers.forEach(((s,h)=>{h>0&&(t=o),o=[],s.neurons.forEach((s=>{n=0,e=0,i=s.numInputs;for(let r=0;r<i-1;++r)e+=s.weights[r]*t[n++];e+=s.weights[i-1]*r.BIAS,o.push(s.activation=this.sigmoid(e,r.ACTIVATION_RESPONSE))}))})),s.assert(o.length==this.numOutputs,"out length incorrect")?o:[]}sigmoid(t,e){return 1/(1+Math.exp(-t/e))}calcSplitPoints(){let t=[],e=0;return this.layers.forEach((s=>s.neurons.forEach((s=>{e+=s.numInputs,t.push(e-1)})))),t}},runGASearch:function(t,e){let i,r,n=p(e),o=e.maxCycles||100,h=1e3*(e.maxSeconds||30),l=function*([t,e],{mutate:i,create:r,maxAge:n,calcFit:o,poolSize:h,crossOver:l}){let a,c=r();yield c;let u,d,f,g,p,m=[c],w=[c];h=h||1,n=n||50;for(let t=0;t<h-1;++t)a=r(),a.fitness.gt(c.fitness)&&(yield c=a,w.push(a)),m.push(a);for(p=h-1,g=1;;)if(s.now()-t>e&&(yield c),g=g>0?g-1:p,a=m[g],d=y(g,m,l,i,o),a.fitness.gt(d.fitness)){if(void 0===n)continue;if(a.age+=1,n>a.age)continue;if(f=v(w,d,w.length),u=f/w.length,s.rand()<Math.exp(-u)){m[g]=d;continue}c.age=0,m[g]=c}else d.fitness.gt(a.fitness)?(d.age=0,m[g]=d,d.fitness.gt(c.fitness)&&(yield c=d,w.push(c))):(d.age=a.age+1,m[g]=d)}([n,h],e);for(;;){if(i=l.next().value,r=m(e),r-n>h){r=null;break}if(!t.gt(i.fitness))break;if(e.cycles>=o)break;e.cycles+=1}return[null==r,i]},runGACycle:function(t,e){let i,r,{maxCycles:n,targetScore:o,maxSeconds:h}=e,l=p(e),a=1e3*(h||30);for(n=n||100;;){if(t=w(t,e),r=m(e),r-l>a){r=null;break}if(i=g(t),s.echt(o)&&i.bestScore>=o)break;if(e.cycles>=n)break;e.cycles+=1}return e.gen++,[null==r,t]},calcStats:g,NumFitness:o,Fitness:n,Chromosome:c,mutateSM:function(t){if(s.rand()<r.mutationRate){let e,[i,r]=u(t),n=r-i-1;if(2==n)e=t[i+1],t[i+1]=t[i+2],t[i+2]=e;else if(n>2){e=s.shuffle(t.slice(i+1,r));for(let s=0,n=i+1;n<r;++n)t[n]=e[s++]}}},mutateDM:function(t){if(s.rand()<r.mutationRate){let e,i,r,[n,o]=u(t),h=t.length;o-n-1>0&&(i=t.slice(n+1,o),r=t.slice(0,n+1).concat(t.slice(o)),e=s.randInt(r.length),i=r.slice(0,e).concat(i).concat(r.slice(e)),t.length=0,i.forEach((e=>t.push(e))),s.assert(t.length==h,"mutateDM error"))}},mutateIVM:function(t){if(s.rand()<r.mutationRate){let e,[i,r]=u(t),n=t.length;if(r-i-1>1){e=t.slice(i+1,r).reverse();for(let s=0,n=i+1;n<r;++n)t[n]=e[s++]}s.assert(n==t.length,"mutateIVM error")}},mutateDIVM:function(t){if(s.rand()<r.mutationRate){let e,i,r,[n,o]=u(t),h=t.length;o-n-1>0&&(i=t.slice(n+1,o).reverse(),r=t.slice(0,n+1).concat(t.slice(o)),e=s.randInt(r.length),i=r.slice(0,e).concat(i).concat(r.slice(e)),t.length=0,i.forEach((e=>t.push(e))),s.assert(t.length==h,"mutateDIVM error"))}},crossOverOBX:function(t,e){let i,n,o,h,l;if(s.randInt2(0,t.length-2),o=t.slice(),h=e.slice(),s.rand()>r.crossOverRate||t===e);else{n=s.listIndexesOf(t,!0).slice(0,s.toGoldenRatio(t.length)[1]).sort(),i=n.map((e=>t[e])),l=0;for(let t=0;t<h.length;++t)for(let e=0;e<i.length;++e)if(h[t]==i[e]){h[t]=i[l++];break}i.length=0,l=0;for(let t=0;t<n.length;++t)i.push(e[n[t]]);for(let t=0;t<o.length;++t)for(let e=0;e<i.length;++e)if(o[t]==i[e]){o[t]=i[l++];break}}return[o,h]},crossOverPBX:function(t,e){let i,n;if(s.rand()>r.crossOverRate||t===e)i=t.slice(),n=e.slice();else{i=s.fill(t.length,null),n=s.fill(t.length,null),s.listIndexesOf(t,!0).slice(0,s.toGoldenRatio(t.length)[1]).sort().forEach((s=>{i[s]=t[s],n[s]=e[s]}));let r=0,o=0;for(let s=0;s<t.length;++s){for(;null!==n[o]&&o<t.length;)++o;for(n.indexOf(t[s])<0&&(n[o]=t[s]);null!==i[r]&&r<t.length;)++r;i.indexOf(e[s])<0&&(i[r]=e[s])}s.assert(!i.some((t=>null===t)),"crossOverPBX null error"),s.assert(!n.some((t=>null===t)),"crossOverPBX null error")}return[i,n]},crossOverRND:function(t,e){let i,n;if(s.rand()>r.crossOverRate||t===e)i=t.slice(),n=e.slice();else{let r=s.randInt(t.length);i=[],n=[];for(let s=0;s<r;++s)i.push(t[s]),n.push(e[s]);for(let s=r;s<t.length;++s)i.push(e[s]),n.push(t[s])}return[i,n]},crossOverPMX:function(t,e){let i=t.slice(),n=e.slice();if(s.rand()>r.crossOverRate||t===e);else{let r=s.randInt2(0,t.length-2),o=r;for(;o<=r;)o=s.randInt2(0,t.length-1);for(let h,l,a,c,u=r;u<o+1;++u)a=t[u],c=e[u],a!=c&&(h=i.indexOf(a),l=i.indexOf(c),s.swap(i,h,l),h=n.indexOf(a),l=n.indexOf(c),s.swap(n,h,l))}return[i,n]},crossOverAtSplits:function(t,e,i){let n,o;if(s.rand()>r.crossOverRate||t===e)n=t.slice(),o=e.slice();else{let r=i[s.randInt2(0,i.length-2)],h=i[s.randInt2(r,i.length-1)];n=[],o=[];for(let s=0;s<t.length;++s)s<r||s>=h?(n.push(t[s]),o.push(e[s])):(n.push(e[s]),o.push(t[s]))}return[n,o]},hillClimb:function(t,e,i,r,n,o){o.startTime=s.now();let h,l=t(n);for(;!i(l);)h=t(r(l)),e(l,h)&&(l=h);return o.endTime=s.now(),l},showBest(t,e,i){console.log(s.fill(80,"-").join("")),console.log("total time: "+s.prettyMillis(e.endTime-e.startTime)),i&&console.log("time expired"),console.log("total generations= "+e.gen),console.log("total cycles= "+e.cycles),console.log("fitness= "+t.fitness.score()),console.log(s.fill(80,"-").join(""))},config:t=>s.inject(r,t)}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/NNetGA"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());const s=Math.floor,{u:i,is:r}=e,n={INPUT:0,HIDDEN:1,OUTPUT:2,BIAS:3,NONE:4},o={NEURON:0,LINK:1},h={SNAPSHOT:0,ACTIVE:1},l={numInputs:0,numOutputs:0,bias:-1,sigmoidResponse:1,numAddLinkAttempts:5,numTrysToFindLoopedLink:5,numTrysToFindOldLink:5,chanceAddLink:.07,chanceAddNode:.03,chanceAddRecurrentLink:-1,mutationRate:.8,maxWeightPerturbation:.5,probabilityWeightReplaced:.1,activationMutationRate:.1,maxActivationPerturbation:.1,compatibilityThreshold:.26,youngFitnessBonus:1.3,youngBonusAgeThreshhold:10,survivalRate:0,oldAgeThreshold:50,oldAgePenalty:.7,crossOverRate:.7,numGensAllowedNoImprovement:15,maxPermittedNeurons:100,numBestElites:4};function a(t,e=!1){return{value:t,gt(t){return e?this.value<t.value:this.value>t.value},eq(t){return this.value==t.value},lt(t){return e?this.value>t.value:this.value<t.value},score(){return this.value},update(t){this.value=t},clone(){return a(this.value,e)}}}class c{constructor(t,e=null,s=!1){this.pos=e?e.slice():[0,0],this.activation=1,this.recurrent=s,r.vec(t)?(this.id=t[0],this.neuronType=t[1]):(this.id=0,this.neuronType=t)}clone(){let t=new c(this.neuronType);return t.id=this.id,t.activation=this.activation,t.recurrent=this.recurrent,t.pos=this.pos.slice(),t}static from(t,e,s=null,i=!1){return new c([t,e],s,i)}}class u{constructor(t,e,s,r=!0,n=null,o=!1){this.fromNeuron=t,this.toNeuron=e,this.innovationID=s,this.recurrent=!0===o,this.enabled=!1!==r,this.weight=null===n?i.randMinus1To1():n}clone(){let t=new u;return t.fromNeuron=this.fromNeuron,t.toNeuron=this.toNeuron,t.innovationID=this.innovationID,t.recurrent=this.recurrent,t.enabled=this.enabled,t.weight=this.weight,t}}class d{constructor(t,e,s,i,r=n.NONE,o=null){this.pos=o?o.slice():[0,0],this.innovationID=i,this.innovationType=s,this.neuronID=0,this.neuronType=r,this.neuronIn=t,this.neuronOut=e}static from(t,e){let s=new d(-1,-1,null,e,t.neuronType,t.pos);return s.neuronID=t.id,s}}class f{constructor(t,e){this.NEURON_COUNTER=t.length-1,this.INNOV_COUNTER=0,this.vecInnovs=t.map((t=>d.from(t,this.nextIID()))).concat(e.map((t=>new d(t.fromNeuron,t.toNeuron,o.LINK,this.nextIID()))))}nextIID(){return this.INNOV_COUNTER++}check(t,e,s){let i=this.vecInnovs.find((i=>i.neuronIn==t&&i.neuronOut==e&&i.innovationType==s));return void 0===i?-1:i.innovationID}create(t,e,s,i=n.NONE,r=null){let h=new d(t,e,s,this.nextIID(),i,r);return o.NEURON==s&&(h.neuronID=++this.NEURON_COUNTER),this.vecInnovs.push(h),h}flush(){this.vecInnovs.length=0}getNeuronID(t){return this.vecInnovs[t].neuronID}}class g{constructor(t,e,s,i=!1){this.weight=t,this.from=e,this.out=s,this.recurrent=!0===i}clone(){let t=new g;return t.weight=this.weight,t.from=this.from,t.out=this.out,t.recurrent=this.recurrent,t}}class p{constructor(t,e,s,i){this.neuronType=t,this.neuronID=e,this.sumActivation=0,this.output=0,this.posX=0,this.posY=0,this.vecLinksIn=[],this.vecLinksOut=[],this.activation=i,this.pos=s?s.slice():[0,0]}clone(){let t=new p;return t.neuronType=this.neuronType,t.neuronID=this.neuronID,t.output=this.output,t.posX=this.posX,t.posY=this.posY,t.pos=this.pos.slice(),t.activation=this.activation,t.sumActivation=this.sumActivation,t.vecLinksIn=this.vecLinksIn.map((t=>t.clone())),t.vecLinksOut=this.vecLinksOut.map((t=>t.clone())),t}}class m{constructor(t,e){this.vecNeurons=t,this.depth=e}clone(){let t=new m(null,this.depth);return t.vecNeurons=this.vecNeurons.map((t=>t.clone())),t}compute(t,e){return this.update(t,e)}update(t,e=h.ACTIVE){let s=[],r=e==h.SNAPSHOT?this.depth:1;for(let e,h,a=0;a<r;++a){for(s.length=0,h=0;this.vecNeurons[h].neuronType==n.INPUT;)this.vecNeurons[h].output=t[h],++h;for(i.assert(this.vecNeurons[h].neuronType==n.BIAS,"expecting BIAS node"),this.vecNeurons[h].output=1,++h;h<this.vecNeurons.length;)e=this.vecNeurons[h].vecLinksIn.reduce(((t,e)=>t+e.weight*e.from.output),0),this.vecNeurons[h].output=(o=e,l=this.vecNeurons[h].activation,1/(1+Math.exp(-o/l))),this.vecNeurons[h].neuronType==n.OUTPUT&&s.push(this.vecNeurons[h].output),++h}var o,l;return e==h.SNAPSHOT&&this.vecNeurons.forEach((t=>t.output=0)),s}draw(t,e,s,i,r){}}class y{constructor(t,e,s,i=null,r=null){if(t<0)return;let o,h=0,l=1/(e+2),d=1/(s+1);if(i&&r)this.vecNeurons=i,this.vecLinks=r;else{for(this.vecNeurons=[],this.vecLinks=[],o=0;o<e;++o)this.vecNeurons.push(c.from(h++,n.INPUT,[(o+2)*l,0]));for(this.vecNeurons.push(c.from(h++,n.BIAS,[l,0])),o=0;o<s;++o)this.vecNeurons.push(c.from(h++,n.OUTPUT,[(o+1)*d,1]));for(o=0;o<e+1;++o)for(let t=0;t<s;++t)this.vecLinks.push(new u(this.vecNeurons[o].id,this.vecNeurons[e+1+t].id,e+s+1+this.vecLinks.length))}this.nextNeuronID=h,this.fitness=a(0),this.genomeID=t,this.adjustedFitness=0,this.amountToSpawn=0,this.numInputs=e,this.numOutputs=s,this.species=0}createPhenotype(t){let e=this.vecNeurons.map((t=>new p(t.neuronType,t.id,t.pos,t.activation)));return this.vecLinks.forEach((t=>{if(t.enabled){let s=e[this.getIndex(t.toNeuron)],i=e[this.getIndex(t.fromNeuron)],r=new g(t.weight,i,s,t.recurrent);i.vecLinksOut.push(r),s.vecLinksIn.push(r)}})),new m(e,t)}_randAny(){return this.vecNeurons[i.randInt2(0,this.vecNeurons.length-1)]}_randNonInputs(){return this.vecNeurons[i.randInt2(this.numInputs+1,this.vecNeurons.length-1)]}addLink(t,e,s,r,h){if(i.rand()>t)return;let l=-1,a=-1,c=!1;if(i.rand()<e)for(;r--;){let t=this._randNonInputs();if(t.neuronType!=n.BIAS&&t.neuronType!=n.INPUT&&!t.recurrent){l=a=t.id,c=t.recurrent=!0;break}}else for(;h--&&(l=this._randAny().id,a=this._randNonInputs().id,l==a||this.duplicateLink(l,a));)l=a=-1;if(l<0||a<0);else{let t=s.check(l,a,o.LINK);this.vecNeurons[this.getIndex(l)].pos[1]>this.vecNeurons[this.getIndex(a)].pos[1]&&(c=!0),t<0&&(t=s.create(l,a,o.LINK).innovationID),this.vecLinks.push(new u(l,a,t,!0,i.randMinus1To1(),c))}}addNeuron(t,e,r){if(i.rand()>t)return;let h,l,a,d,f=0,g=!1,p=this.numInputs+this.numOutputs+5;if(this.vecLinks.length<p){for(;r--;)if(f=i.randInt2(0,this.numGenes()-1-s(Math.sqrt(this.numGenes()))),h=this.vecLinks[f].fromNeuron,this.vecLinks[f].enabled&&!this.vecLinks[f].recurrent&&this.vecNeurons[this.getIndex(h)].neuronType!=n.BIAS){g=!0;break}if(!g)return}else for(;!g;)f=i.randInt2(0,this.numGenes()-1),h=this.vecLinks[f].fromNeuron,this.vecLinks[f].enabled&&!this.vecLinks[f].recurrent&&this.vecNeurons[this.getIndex(h)].neuronType!=n.BIAS&&(g=!0);this.vecLinks[f].enabled=!1;let m=this.vecLinks[f].weight,y=this.vecLinks[f].fromNeuron,v=this.vecLinks[f].toNeuron,w=(this.vecNeurons[this.getIndex(y)].pos[1]+this.vecNeurons[this.getIndex(v)].pos[1])/2,x=(this.vecNeurons[this.getIndex(y)].pos[0]+this.vecNeurons[this.getIndex(v)].pos[0])/2,_=e.check(y,v,o.NEURON);if(_>=0&&this.hasNeuron(e.getNeuronID(_))&&(_=-1),_<0){let t=e.create(y,v,o.NEURON,n.HIDDEN,[x,w]),s=c.from(this.nextNeuronID,n.HIDDEN,[x,w]);t.neuronID=s.id,d=s.id,this.nextNeuronID++,this.vecNeurons.push(s),l=e.create(y,d,o.LINK).innovationID,this.vecLinks.push(new u(y,d,l,!0,1)),a=e.create(d,v,o.LINK).innovationID,this.vecLinks.push(new u(d,v,a,!0,m))}else d=e.getNeuronID(_),l=e.check(y,d,o.LINK),a=e.check(d,v,o.LINK),(l<0||a<0)&&i.assert(!1,"Error in Genome::AddNeuron"),this.vecLinks.push(new u(y,d,l,!0,1),new u(d,v,a,!0,m)),this.vecNeurons.push(c.from(d,n.HIDDEN,[x,w]))}getIndex(t){for(let e=0;e<this.vecNeurons.length;++e)if(this.vecNeurons[e].id==t)return e;i.assert(!1,"Error in Genome::getIndex")}duplicateLink(t,e){return this.vecLinks.some((s=>s.fromNeuron==t&&s.toNeuron==e))}hasNeuron(t){return this.vecNeurons.some((e=>t==e.id))}mutateWeights(t,e,s){for(let r=0;r<this.vecLinks.length;++r)i.rand()<t&&(i.rand()<e?this.vecLinks[r].weight=i.randMinus1To1():this.vecLinks[r].weight+=i.randMinus1To1()*s)}mutateActivation(t,e){this.vecNeurons.forEach((s=>{i.rand()<t&&(s.activation+=i.randMinus1To1()*e)}))}calcCompatibility(t){let e=0,s=0,i=0,r=0,n=0,o=0;for(;e<this.vecLinks.length-1||s<t.vecLinks.length-1;){if(e==this.vecLinks.length-1){++s,++r;continue}if(s==t.vecLinks.length-1){++e,++r;continue}let h=this.vecLinks[e].innovationID,l=t.vecLinks[s].innovationID;h==l?(++e,++s,++n,o+=Math.abs(this.vecLinks[e].weight-t.vecLinks[s].weight)):(++i,h<l?++e:h>l&&++s)}const h=Math.max(this.numGenes(),t.numGenes());let l=1*r/h+1*i/h;return n>0?l+.4*o/n:l}sortGenes(){return this.vecLinks.sort(((t,e)=>t.innovationID<e.innovationID?-1:t.innovationID>e.innovationID?1:0)),this}id(){return this.genomeID}setID(t){this.genomeID=t}numGenes(){return this.vecLinks.length}numNeurons(){return this.vecNeurons.length}setFitness(t){this.fitness=a(t)}splitY(t){return this.vecNeurons[t].pos[1]}genes(){return this.vecLinks}neurons(){return this.vecNeurons}startOfGenes(){return 0}endOfGenes(){return this.vecLinks.length}clone(){let t=this,e=new y(-911);return e.fitness=t.fitness.clone(),e.genomeID=t.genomeID,e.adjustedFitness=t.adjustedFitness,e.amountToSpawn=t.amountToSpawn,e.numInputs=t.numInputs,e.numOutputs=t.numOutputs,e.species=t.species,e.vecNeurons=t.vecNeurons.map((t=>t.clone())),e.vecLinks=t.vecLinks.map((t=>t.clone())),e}}class v{constructor(t,e){this.speciesID=t,this._gensNoImprovement=0,this._age=0,this.spawnsRqd=0,this.vecMembers=[e],this._leader=e.clone(),this._bestFitness=e.fitness.score()}adjustFitnesses(){let t,e=0;this.vecMembers.forEach((s=>{t=s.fitness.score(),this._age<l.youngBonusAgeThreshhold&&(t*=l.youngFitnessBonus),this._age>l.oldAgeThreshold&&(t*=l.oldAgePenalty),e+=t,s.adjustedFitness=t/this.vecMembers.length}))}addMember(t){t.fitness.score()>this._bestFitness&&(this._bestFitness=t.fitness.score(),this._gensNoImprovement=0,this._leader=t.clone()),this.vecMembers.push(t),t.species=this.id()}purge(){return this.vecMembers.length=0,++this._gensNoImprovement,this.spawnsRqd=0,++this._age,this}calculateSpawnAmount(){this.vecMembers.forEach((t=>{this.spawnsRqd+=t.amountToSpawn}))}spawn(){let t,e;return 1==this.vecMembers.length?e=this.vecMembers[0]:(t=s(l.survivalRate*this.vecMembers.length)-1,t<0&&(t=1),e=this.vecMembers[i.randInt2(0,t)]),e.clone()}id(){return this.speciesID}bestFitness(){return this._bestFitness}age(){return this._age}leader(){return this._leader}numToSpawn(){return this.spawnsRqd}numMembers(){return this.vecMembers.length}gensNoImprovement(){return this._gensNoImprovement}}function w(t,e,s,i){const r=e-t;return i.push({val:t+r/2,depth:s+1}),s>6||(w(t,t+r/2,s+1,i),w(t+r/2,e,s+1,i)),i}return{NeatGA:class{constructor(t,e,s){let r=new y(0,e,s);this.vecSplits=w(0,1,0,[]),this.vecBestGenomes=[],this.vecSpecies=[],this.SPECIES_COUNTER=0,this.GENOME_COUNTER=0,this.generation=0,this.popSize=t,this.totFitAdj=0,this.avFitAdj=0,this.fittestGenome=0,this._bestEverFitness=0,this.vecGenomes=i.fill(t,(()=>new y(this.nextGID(),e,s))),this.innovHistory=new f(r.neurons(),r.genes())}resetAndKill(){this.totFitAdj=0,this.avFitAdj=0;let t=[];this.vecSpecies.forEach((e=>{e.gensNoImprovement()>l.numGensAllowedNoImprovement&&e.bestFitness()<this._bestEverFitness||t.push(e.purge())})),this.vecSpecies.length=0,t.forEach((t=>this.vecSpecies.push(t)))}speciateAndCalculateSpawnLevels(){let t=!1;this.vecGenomes.forEach((e=>{for(let s=0;s<this.vecSpecies.length;++s)if(e.calcCompatibility(this.vecSpecies[s].leader())<=l.compatibilityThreshold){this.vecSpecies[s].addMember(e),t=!0;break}t||this.vecSpecies.push(new v(this.nextSID(),e)),t=!1})),this.vecSpecies.forEach((t=>t.adjustFitnesses())),this.vecGenomes.forEach((t=>this.totFitAdj+=t.adjustedFitness)),this.avFitAdj=this.totFitAdj/this.vecGenomes.length,this.vecGenomes.forEach((t=>t.amountToSpawn=t.adjustedFitness/this.avFitAdj)),this.vecSpecies.forEach((t=>t.calculateSpawnAmount()))}crossOver(t,e){let s;function r(t,e){e.indexOf(t)<0&&e.push(t)}s=t.fitness.score()==e.fitness.score()?t.numGenes()==e.numGenes()?i.randSign()>0?1:0:t.numGenes()<e.numGenes()?0:1:t.fitness.score()>e.fitness.score()?0:1;let o,h=[],l=[],a=[],u=0,d=0;for(;u!=t.endOfGenes()||d!=e.endOfGenes();)u==t.endOfGenes()&&d!=e.endOfGenes()?(1==s&&(o=e.vecLinks[d]),++d):d==e.endOfGenes()&&u!=t.endOfGenes()||t.vecLinks[u].innovationID<e.vecLinks[d].innovationID?(0==s&&(o=t.vecLinks[u]),++u):e.vecLinks[d].innovationID<t.vecLinks[u].innovationID?(1==s&&(o=e.vecLinks[d]),++d):e.vecLinks[d].innovationID==t.vecLinks[u].innovationID&&(o=i.rand()<.5?t.vecLinks[u]:e.vecLinks[d],++u,++d),0!=l.length&&i.last(l).innovationID==o.innovationID||l.push(o.clone()),r(o.fromNeuron,a),r(o.toNeuron,a);return a.sort().forEach((t=>h.push(function(t,e){let s=c.from(0,n.HIDDEN);for(let i,r=0;r<t.vecInnovs.length;++r)if(i=t.vecInnovs[r],i.neuronID==e)return s.neuronType=i.neuronType,s.id=i.neuronID,s.pos=i.pos.slice(),s;i.assert(!1,"boom from createNeuronFromID")}(this.innovHistory,t)))),new y(this.nextGID(),t.numInputs,t.numOutputs,h,l)}nextSID(){return++this.SPECIES_COUNTER}nextGID(){return++this.GENOME_COUNTER}tournamentSelection(t){let e=0,s=0;for(let r,n=0,o=this.vecGenomes.length-1;n<t;++n)r=i.randInt2(0,o),this.vecGenomes[r].fitness.score()>s&&(e=r,s=this.vecGenomes[r].fitness.score());return this.vecGenomes[e]}calculateNetDepth(t){let e=0;for(let s=0;s<t.numNeurons();++s)for(let i=0;i<this.vecSplits.length;++i)t.splitY(s)==this.vecSplits[i].val&&this.vecSplits[i].depth>e&&(e=this.vecSplits[i].depth);return e+2}sortAndRecord(t){this.vecGenomes.forEach(((e,s)=>e.setFitness(t[s]))),this.vecGenomes.sort(((t,e)=>t.fitness.score()>e.fitness.score()?-1:t.fitness.score()<e.fitness.score()?1:0)),this._bestEverFitness=Math.max(this._bestEverFitness,this.vecGenomes[0].fitness.score()),this.vecBestGenomes.length=0;for(let t=0;t<l.numBestElites;++t)this.vecBestGenomes.push(this.vecGenomes[t])}epoch(t){i.assert(t.length==this.vecGenomes.length,"NeatGA::Epoch(scores/ genomes mismatch)!"),this.resetAndKill(),this.sortAndRecord(t),this.speciateAndCalculateSpawnLevels();let e,r=[],n=0;if(this.vecSpecies.forEach((t=>{if(n<this.popSize){let s=!1,o=i.rounded(t.numToSpawn());for(;o--;){if(s){if(1==t.numMembers())e=t.spawn();else{let s,r=5,n=t.spawn();if(i.rand()<l.crossOverRate){for(s=t.spawn();n.id()==s.id()&&r--;)s=t.spawn();e=n.id()!=s.id()?this.crossOver(n,s):n}else e=n}e.setID(this.nextGID()),e.numNeurons()<l.maxPermittedNeurons&&e.addNeuron(l.chanceAddNode,this.innovHistory,l.numTrysToFindOldLink),e.addLink(l.chanceAddLink,l.chanceAddRecurrentLink,this.innovHistory,l.numTrysToFindLoopedLink,l.numAddLinkAttempts),e.mutateWeights(l.mutationRate,l.probabilityWeightReplaced,l.maxWeightPerturbation),e.mutateActivation(l.activationMutationRate,l.maxActivationPerturbation)}else s=!0,e=t.leader().clone();r.push(e.sortGenes()),++n==this.popSize&&(o=0)}}})),n<this.popSize){let t=this.popSize-n;for(;t--;)r.push(this.tournamentSelection(s(this.popSize/5)).clone())}return this.vecGenomes=r,++this.generation,this.createPhenotypes()}createPhenotypes(){return this.vecGenomes.map((t=>t.createPhenotype(this.calculateNetDepth(t))))}renderSpeciesInfo(){}numSpecies(){return this.vecSpecies.length}bestEverFitness(){return this._bestEverFitness}getBestPhenotypesFromLastGeneration(){return this.vecBestGenomes.map(((t,e)=>{t.createPhenotype(this.calculateNetDepth(t))}))}},NeuralNet:m,Genome:y,NeuronGene:c,LinkGene:u,NLink:g,NNeuron:p,Species:v,NumFitness:a,InnovHistory:f,NeuronType:n,InnovType:o,RunType:h,configParams:t=>i.inject(l,t)}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/NEAT"]=s}(this),function(t,e){"use strict";function s(e){e||(e=t["io/czlab/mcfud/core"]());const s=Math.floor,{u:i,is:r}=e,n=0,o=1,h=2,l=3;function a(t,e=!1){return{value:t,gt(t){return e?this.value<t.value:this.value>t.value},eq(t){return this.value==t.value},lt(t){return e?this.value>t.value:this.value<t.value},score(){return this.value},update(t){this.value=t},clone(){return a(this.value,e)}}}const c=a,u={BIAS:1,nextInnovNo:1,superSpeed:1,mutationRate:.8,crossOverRate:.25,probAddLink:.07,probAddNode:.03,probCancelLink:.75,probAddRecurrentLink:.05,probWeightReplaced:.1,maxWeightPerturbation:.02,noImprovementLimit:15,excessCoeff:1,weightDiffCoeff:.5,compatibilityThreshold:3};class d{constructor(t,e,s,i){this.innovNo=i,this.fromNode=t,this.toNode=e,this.weight=s,this.enabled=!0}mutateWeight(){i.rand()<u.probWeightReplaced?this.weight=i.randMinus1To1():this.weight+=i.randGaussian()*u.maxWeightPerturbation,this.weight>1&&(this.weight=1),this.weight<-1&&(this.weight=-1)}clone(t,e){let s=new d(t,e,this.weight,this.innovNo);return s.enabled=this.enabled,s}}class f{constructor(t,e,s,i){this.fromNode=t,this.toNode=e,this.innovNumber=s,this.innovNumbers=i.slice()}matches(t,e,s){if(t.genes.length==this.innovNumbers.length&&e.number==this.fromNode&&s.number==this.toNode){for(let e=0;e<t.genes.length;++e)if(!this.innovNumbers.includes(t.genes[e].innovNo))return!1;return!0}return!1}}class g{constructor(t,e,s=0){this.outputConnections=[],this.layer=s,this.neuronType=t,this.pos=[0,0],this.number=e,this.inputSum=0,this.outputValue=0}engage(){0!=this.layer&&(this.outputValue=this.sigmoid(this.inputSum));for(let t=0;t<this.outputConnections.length;++t)this.outputConnections[t].enabled&&(this.outputConnections[t].toNode.inputSum+=this.outputConnections[t].weight*this.outputValue);return this}stepFunction(t){return t<0?0:1}sigmoid(t){return 1/(1+Math.pow(Math.E,-4.9*t))}sigmoid2(t,e){return 1/(1+Math.exp(-t/e))}isConnectedTo(t){let e,s;if(t.layer<this.layer?(e=t,s=this):t.layer>this.layer&&(e=this,s=t),e&&s)for(let t=0;t<e.outputConnections.length;++t)if(e.outputConnections[t].toNode===s)return!0;return!1}clone(){return new g(this.neuronType,this.number,this.layer)}}class p{constructor(t,e,s=!1){this.outputs=e,this.fitness=c(0),this.inputs=t,this.layers=2,this.nextNode=0,this.network=[],this.genes=[],this.nodes=s?[]:this.ctor(t,e,[])}ctor(t,e,s){for(let e=0;e<t;++e)s.push(new g(n,e)),++this.nextNode;for(let i=0;i<e;++i)s.push(new g(o,i+t,1)),++this.nextNode;return this.biasNode=this.nextNode,this.nextNode++,s.push(new g(h,this.biasNode)),s}bindTo(t){return this.husk=t,t.brain=this}getNeuron(t){return this.nodes.find((e=>e.number==t))}connectNeurons(){return this.nodes.forEach((t=>t.outputConnections.length=0)),this.genes.forEach((t=>t.fromNode.outputConnections.push(t))),this}update(t){i.assert(this.network.length>0,"invalid network"),i.assert(t.length==this.inputs,"invalid input values");for(let e,s=0;s<this.inputs;++s)e=this.nodes[s],e.outputValue=t[s],i.assert(e.neuronType==n,"invalid input neuron");this.nodes[this.biasNode].outputValue=u.BIAS,this.network.forEach((t=>t.engage()));const e=[];for(let t,s=0;s<this.outputs;++s)t=this.nodes[this.inputs+s],e[s]=t.outputValue,i.assert(t.neuronType==o,"invalid output neuron");return this.nodes.forEach((t=>t.inputSum=0)),e}compute(t){return this.update(t)}generateNetwork(){this.connectNeurons(),i.cls(this.network);for(let t=0;t<this.layers;++t)for(let e=0;e<this.nodes.length;++e)this.nodes[e].layer==t&&this.network.push(this.nodes[e]);return this}addNeuron(t){if(0==this.genes.length)return this.addLink(t);let e=10,s=0;for(this.genes.length>1&&(s=i.randInt(this.genes.length));this.genes[s].fromNode.neuronType==h&&e>0;)s=i.randInt(this.genes.length),e--;if(e<=0)return console.warn("failed to add neuron"),this;this.genes[s].enabled=!1;let r,n,o=this.nextNode;if(this.nodes.push(new g(l,o)),++this.nextNode,n=this.getNeuron(o),r=this.getInnovNo(t,this.genes[s].fromNode,n),this.genes.push(new d(this.genes[s].fromNode,n,1,r)),r=this.getInnovNo(t,n,this.genes[s].toNode),this.genes.push(new d(n,this.genes[s].toNode,this.genes[s].weight,r)),n.layer=1+this.genes[s].fromNode.layer,r=this.getInnovNo(t,this.nodes[this.biasNode],o),this.genes.push(new d(this.nodes[this.biasNode],n,0,r)),n.layer==this.genes[s].toNode.layer){for(let t=0;t<this.nodes.length-1;++t)this.nodes[t].layer>=n.layer&&(this.nodes[t].layer+=1);++this.layers}return this.connectNeurons()}addLink(t){if(this.fullyConnected())return console.warn("addLink failed, too full"),this;let e,s,r=i.randInt(this.nodes.length),n=i.randInt(this.nodes.length),o=10,h=(t,e)=>this.nodes[t].layer==this.nodes[e].layer||this.nodes[t].isConnectedTo(this.nodes[e]);for(;h(r,n)&&o>0;)r=i.randInt(this.nodes.length),n=i.randInt(this.nodes.length),--o;return o<=0?(console.log("failed to add-link"),this):(this.nodes[r].layer>this.nodes[n].layer&&(s=n,n=r,r=s),e=this.getInnovNo(t,this.nodes[r],this.nodes[n]),this.genes.push(new d(this.nodes[r],this.nodes[n],i.randMinus1To1(),e)),this.connectNeurons())}getInnovNo(t,e,s){let i=!0,r=u.nextInnovNo;for(let n=0;n<t.length;++n)if(t[n].matches(this,e,s)){i=!1,r=t[n].innovNumber;break}return i&&(t.push(new f(e.number,s.number,r,this.genes.map((t=>t.innovNo)))),u.nextInnovNo+=1),r}fullyConnected(){let t=0,e=i.fill(this.layers,0);this.nodes.forEach((t=>e[t.layer]+=1));for(let s,i=0;i<this.layers-1;++i){s=0;for(let t=i+1;t<this.layers;++t)s+=e[t];t+=s*e[i]}return t<=this.genes.length}mutate(t){return 0==this.genes.length&&this.addLink(t),i.rand()<u.mutationRate&&this.genes.forEach((t=>t.mutateWeight())),i.rand()<u.probAddLink&&this.addLink(t),i.rand()<u.probAddNode&&this.addNeuron(t),this}crossOver(t){let e,s,r=[],n=[],o=new p(this.inputs,this.outputs,!0);o.nextNode=this.nextNode,o.layers=this.layers,o.biasNode=this.biasNode;for(let o=0;o<this.genes.length;++o)s=!0,e=this.matchingGene(t,this.genes[o].innovNo),-1!=e?(this.genes[o].enabled&&t.genes[e].enabled||i.rand()<u.probCancelLink&&(s=!1),n.push(i.rand()<.5?this.genes[o]:t.genes[e])):(n.push(this.genes[o]),s=this.genes[o].enabled),r.push(s);this.nodes.forEach((t=>o.nodes.push(t.clone())));for(let t=0;t<n.length;++t)o.genes.push(n[t].clone(o.getNeuron(n[t].fromNode.number),o.getNeuron(n[t].toNode.number))),o.genes[t].enabled=r[t];return o.connectNeurons()}matchingGene(t,e){for(let s=0;s<t.genes.length;++s)if(t.genes[s].innovNo==e)return s;return-1}printGenome(){console.log("Prvar genome  layers:"+this.layers),console.log("bias node: "+this.biasNode),console.log("this.nodes");for(let t=0;t<this.nodes.length;++t)console.log(this.nodes[t].number+",");console.log("Genes");for(let t=0;t<this.genes.length;++t)console.log("gene "+this.genes[t].innovNo+"From node "+this.genes[t].fromNode.number+"To node "+this.genes[t].toNode.number+"is enabled "+this.genes[t].enabled+"from layer "+this.genes[t].fromNode.layer+"to layer "+this.genes[t].toNode.layer+"weight: "+this.genes[t].weight);return this}clone(){let t=new p(this.inputs,this.outputs,!0);return this.nodes.forEach((e=>t.nodes.push(e.clone()))),this.genes.forEach((e=>{t.genes.push(e.clone(t.getNeuron(e.fromNode.number),t.getNeuron(e.toNode.number)))})),t.fitness=this.fitness.clone(),t.layers=this.layers,t.nextNode=this.nextNode,t.biasNode=this.biasNode,t.connectNeurons()}drawGenome(t,e,s,i){return this}}class m{constructor(t){this.bestFitness=0,this.members=[],this.rep,this.staleness=0,this.averageFitness=0,t&&(this.bestFitness=t.fitness.score(),this.members.push(t),this.rep=t.clone())}compatible(t){let e,s=this.getExcessDisjoint(t,this.rep),i=this.averageWeightDiff(t,this.rep),r=t.genes.length-20;return r<1&&(r=1),e=u.excessCoeff*s/r+u.weightDiffCoeff*i,u.compatibilityThreshold>e}add(t){return this.members.push(t),this}getExcessDisjoint(t,e){let s=0;for(let i=0;i<t.genes.length;++i)for(let r=0;r<e.genes.length;++r)if(t.genes[i].innovNo==e.genes[r].innovNo){++s;break}return t.genes.length+e.genes.length-2*s}averageWeightDiff(t,e){if(0==t.genes.length||0==e.genes.length)return 0;let s=0,i=0;for(let r=0;r<t.genes.length;++r)for(let n=0;n<e.genes.length;++n)if(t.genes[r].innovNo==e.genes[n].innovNo){++s,i+=Math.abs(t.genes[r].weight-e.genes[n].weight);break}return 0==s?100:i/s}sortAsc(){this.members.sort(((t,e)=>t.fitness.score()>e.fitness.score()?-1:t.fitness.score()<e.fitness.score()?1:0)),0==this.members.length?this.staleness=200:this.members[0].fitness.score()>this.bestFitness?(this.bestFitness=this.members[0].fitness.score(),this.rep=this.members[0].clone(),this.staleness=0):++this.staleness}setAverage(){this.averageFitness=this.members.reduce(((t,e)=>t+e.fitness.score()),0)/this.members.length}giveMeBaby(t){let e,s=()=>{let t=this.members.reduce(((t,e)=>t+e.fitness.score()),0),e=0,s=i.rand()*t;for(let t=0;t<this.members.length;++t)if(e+=this.members[t].fitness.score(),e>s)return this.members[t];return this.members[0]};if(i.rand()<u.crossOverRate)e=s().clone();else{let t=s(),i=s();e=t.fitness.score()<i.fitness.score()?i.crossOver(t):t.crossOver(i)}return e.mutate(t)}cull(){this.members.length>2&&(this.members.length=s(this.members.length/2))}fitnessSharing(){this.members.forEach((t=>{t.fitness.update(t.fitness.score()/this.members.length)}))}}return{NeatGA:class{constructor(t,e,s){this.history=[],this.species=[],this.gen=1,this.genomes=i.fill(t,((t,i)=>((i=new p(e,s)).mutate(this.history),i.generateNetwork())))}createPhenotypes(){return this.genomes}epoch(t){let e=1==this.gen?null:this.genomes[0];this.speciate(),this.genomes.forEach(((e,s)=>{s>=0&&e.fitness.update(t[s])})),this.sortSpecies(),this.resetAndKill();let r,n=[],o=this.getAvgFitnessSum();for(this.species.forEach((t=>{n.push(t.rep.clone()),r=s(t.averageFitness/o*this.genomes.length)-1;for(let e=0;e<r;++e)n.push(t.giveMeBaby(this.history))})),e||(e=this.species[0].rep),n.length<this.genomes.length&&n.push(e.clone());n.length<this.genomes.length;)n.push(this.species[0].giveMeBaby(this.history));return i.append(this.genomes,n,!0),this.gen+=1,this.genomes.forEach((t=>t.generateNetwork())),this.genomes}speciate(){this.species.forEach((t=>i.cls(t.members)));for(let t,e,s=0;s<this.genomes.length;++s){e=this.genomes[s],t=!1;for(let s=0;s<this.species.length;++s)if(this.species[s].compatible(e)){this.species[s].add(e),t=!0;break}t||this.species.push(new m(e))}}sortSpecies(){this.species.forEach((t=>t.sortAsc())),this.species.sort(((t,e)=>t.bestFitness>e.bestFitness?-1:t.bestFitness<e.bestFitness?1:0))}getAvgFitnessSum(){return this.species.reduce(((t,e)=>t+e.averageFitness),0)}resetAndKill(){let t=[];this.species.forEach((t=>{t.cull(),t.fitnessSharing(),t.setAverage()}));for(let e=0;e<this.species.length;++e)(e<2||this.species[e].staleness<u.noImprovementLimit)&&t.push(this.species[e]);i.append(this.species,t,!0);let e=this.getAvgFitnessSum();t=[];for(let s=0;s<this.species.length;++s)s<1?t.push(this.species[s]):this.species[s].averageFitness/e*this.species.length<1||t.push(this.species[s]);i.append(this.species,t,!0)}massExtinction(){this.species.length>5&&this.species.slice(0,5)}},Genome:p,LinkGene:d,Neuron:g,Species:m,NumFitness:a,InnovHistory:f,configParams:t=>i.inject(u,t)}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core")):t["io/czlab/mcfud/algo/NEAT2"]=s}(this),function(t,e){"use strict";function s(e,s){e||(e=t["io/czlab/mcfud/core"]()),s||(s=t["io/czlab/mcfud/math"]());const{is:i,u:r}=e;function n(t,e,s){return e>t.length-1?t:`${t.substr(0,e)}${s}${t.substr(e+1)}`}function o(t,e){return+t.charAt(e)}class h{static DV={n:1,s:2,e:4,w:8};static DX={e:1,w:-1,n:0,s:0};static DY={e:0,w:0,n:-1,s:1};static OPPOSITE={e:"w",w:"e",n:"s",s:"n"};constructor(t,e){this.COLS=t,this.ROWS=e,this._getEntryNodes()}_getEntryNodes(){let t={},e=2*this.ROWS+1-2,s=2*this.COLS+1-2;t.start={x:1,y:1,gate:{x:0,y:1}},t.end={x:s,y:e,gate:{x:s+1,y:e}},this.entryNodes=t}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}generate(){this.grid=this._walk(0,0,r.fill(this.ROWS,(()=>r.fill(this.COLS,0))))}canSouth(t){return 0!=(t&h.DV.s)}canEast(t){return 0!=(t&h.DV.e)}toAscii(){let t=this.grid,e=t.length,s=[],i=t[0].length;for(let r,n=0;n<e;++n){r="|";for(let e=0;e<i;++e)r+=this.canSouth(t[n][e])?" ":"_",this.canEast(t[n][e])?r+=this.canSouth(t[n][e]|t[n][e+1])?" ":"_":r+="|";s.push(r)}return s.unshift("_".repeat(s[0].length)),s.join("\n")}_walk(t,e,s){let i,n;return r.shuffle(["n","s","e","w"]).forEach((r=>{i=t+h.DX[r],n=e+h.DY[r],n>=0&&n<s.length&&i>=0&&i<s[n].length&&0==s[n][i]&&(s[e][t]|=h.DV[r],s[n][i]|=h.DV[h.OPPOSITE[r]],this._walk(i,n,s))})),s}toGrid(){let t,e,s=this.grid,i=s.length,n=[],o=s[0].length;for(let r,h=0;h<i;++h){t=[],e=[],r=0,t[r]=1,e[r]=1;for(let i=0;i<o;++i)++r,this.canSouth(s[h][i])?(t[r]=0,e[r]=0):(t[r]=0,e[r]=1),++r,this.canEast(s[h][i])?(t[r]=0,e[r]=1):(t[r]=1,e[r]=1);n.push(t,e)}return n.unshift(r.fill(n[0].length,1)),n}}return{Maze1:class{constructor(t,e,s="D",i={}){let{bias:r,removeWalls:n,maxWallsRemove:o}=i;this.bias=r||"",this.removeWalls=n||0,this.maxWallsRemove=o||300,this.ROWS=t,this.COLS=e,this.matrix=[],this.entryNodes=this.getEntryNodes(s)}generate(){this.getMatrix(this.parseMaze(r.fill(this.COLS*this.ROWS,(()=>"01111")))),this.removeMazeWalls()}toAscii(){return""}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}toGrid(){let t,e=[];return this.matrix.forEach(((s,i)=>{t=[];for(let e=0;e<s.length;++e)t[e]="1"==s.charAt(e)?1:0;e.push(t)})),e}parseMaze(t){const e={n:1,s:2,w:3,e:4},i={n:2,s:1,w:4,e:3};let h,l,a,c=0,u=[],d=0,f=3,g=t.length-1,p=r.randInt(t.length);for(this.bias&&("H"==this.bias?f=this.COLS/100>=1?s.ndiv(this.COLS,100)+2:3:"V"==this.bias&&(f=this.ROWS/100>=1?s.ndiv(this.ROWS,100)+2:3)),t[p]=n(t[p],0,1);c<g;)if(++d,h=this.getNeighbours(p),a=Object.keys(h).filter((e=>-1!=h[e]&&!o(t[h[e]],0))),this.bias&&d!=f?a=this.biasDirections(a):d=0,a.length)++c,a.length>1&&u.push(p),l=a[r.randInt(a.length)],t[p]=n(t[p],e[l],0),p=h[l],t[p]=n(t[p],i[l],0),t[p]=n(t[p],0,1);else{if(0==u.length)break;p=u.pop()}return t}getMatrix(t){let e="",s="",i=this.COLS*this.ROWS;r.assert(t.length==i,"invalid nodes");for(let r=0;r<i;++r){if(e+=0==e.length?"1":"",s+=0==s.length?"1":"",o(t[r],1))e+="11",s+=o(t[r],4)?"01":"00";else{let i=t.hasOwnProperty(r-this.COLS)&&o(t[r-this.COLS],4),n=t.hasOwnProperty(r+1)&&o(t[r+1],1);o(t[r],4)?(e+="01",s+="01"):n||i?(e+="01",s+="00"):(e+="00",s+="00")}(r+1)%this.COLS==0&&(this.matrix.push(e,s),e="",s="")}this.matrix.push("1".repeat(2*this.COLS+1))}getEntryNodes(t){let e={},s=2*this.ROWS+1-2,i=2*this.COLS+1-2;if("D"==t&&(e.start={x:1,y:1,gate:{x:0,y:1}},e.end={x:i,y:s,gate:{x:i+1,y:s}}),"H"==t||"V"==t){let r="H"==t?s:i;r=(r-1)/2;let n=r%2==0;r=n?r+1:r;let o="H"==t?1:r,h="H"==t?r:1,l="H"==t?i:n?o:o+2,a="H"==t?n?h:h+2:s,c="H"==t?{x:0,y:h}:{x:o,y:0},u="H"==t?{x:i+1,y:a}:{x:l,y:s+1};e.start={x:o,y:h,gate:c},e.end={x:l,y:a,gate:u}}return e}biasDirections(t){let e=-1!=t.indexOf("w")||-1!=t.indexOf("e"),s=-1!=t.indexOf("n")||-1!=t.indexOf("s");return"H"==this.bias&&e?t.filter((t=>"w"==t||"e"==t)):"V"==this.bias&&s?t.filter((t=>"n"==t||"s"==t)):t}getNeighbours(t){return{w:t>0&&t%this.COLS!=0?t-1:-1,e:(t+1)%this.COLS!=0?t+1:-1,n:t-this.COLS>=0?t-this.COLS:-1,s:this.COLS*this.ROWS>t+this.COLS?t+this.COLS:-1}}removeWall(t,e){const s=t%2==0,i=e%2==0;if(!o(this.matrix[t],e))return!1;if(!s&&i){const s=t-2>0&&1==o(this.matrix[t-2],e),i=t+2<this.matrix.length&&1==o(this.matrix[t+2],e);if(s&&i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==o(this.matrix[t-1],e-1),i=1==o(this.matrix[t-1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==o(this.matrix[t+1],e-1),i=1==o(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}}else if(s&&!i){const s=1==o(this.matrix[t],e-2),i=1==o(this.matrix[t],e+2);if(s&&i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==o(this.matrix[t-1],e-1),i=1==o(this.matrix[t+1],e-1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==o(this.matrix[t-1],e+1),i=1==o(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}}}removeMazeWalls(){if(0==this.removeWalls||0==this.matrix.length)return;let t,e,s=0,i=this.matrix.length-1,n=this.maxWallsRemove;for(;s<n&&(++s,!(this.wallsRemoved>=this.removeWalls));){let s=r.randInt2(1,i);s=s==i?s-1:s,e=[],t=this.matrix[s];for(let s=0;s<t.length;s++)0!=s&&s!=t.length-1&&o(t,s)&&e.push(s);r.shuffle(e);for(let t=0;t<e.length;t++)if(this.removeWall(s,e[t])){++this.wallsRemoved;break}}}},Maze2:h}}"object"==typeof module&&module.exports?module.exports=s(require("../main/core"),require("../main/math")):t["io/czlab/mcfud/algo/maze"]=s}(this),function(t,e){"use strict";function s(e,s){if(e||(e=t["io/czlab/mcfud/core"]()),!s)throw"Fatal: No Colors!";const{is:i,u:r}=e;function n(t,e){let s="";for(;t>0;)s+=e,--t;return s}function o(t,e){let s=c;return e&&(i.str(t)?s="any"==t||t==e?u:c:t instanceof e&&(s=u)),s}function h(t,e,s){return new Promise(((i,r)=>{let n;try{n=s.call(t),n instanceof Promise?n.then((function(t){i(`${t?u:c}: ${e}`)})):(n=n?709394==n?a:u:c,i(`${n}: ${e}`))}catch(t){n=c,i(`${n}: ${e}`)}}))}function l(t,e,s,i){return new Promise(((r,n)=>{let h;try{h=s.call(t),h=709394==h?u:o(i,null)}catch(t){h=o(i,t)}r(`${h}: ${e}`)}))}const[a,c,u]=["Skippd","Failed","Passed"];return{prn(t){const e=t.passed.length,i=t.total,o=e/i*100;console.log(s.white(n(78,"+"))),console.log(s.white.bold(t.title)),console.log(s.white(t.date)),console.log(s.white(n(78,"+"))),t.passed.length>0&&console.log(s.green(t.passed.join("\n"))),t.skippd.length>0&&console.log(s.grey(t.skippd.join("\n"))),t.failed.length>0&&console.log(s.magenta(t.failed.join("\n"))),console.log(s.white(n(78,"="))),console.log(s.yellow(["Passed: ",e,"/",i," [",0|o,"%]"].join(""))),console.log(s.magenta("Failed: "+(i-e))),console.log(s.white(["cpu-time: ",r.prettyMillis(t.duration)].join(""))),console.log(s.white(n(78,"=")))},deftest(t){let[e,s,i,r]=[null,null,null,null];const n={ensure:(t,e)=>(i.push([1,t,e]),n),eerror:(t,e)=>(i.push([911,t,e]),n),begin:t=>(r={},i=[],e=t,n),end(n){s=n;let o=function(){return new Promise(((t,n)=>{e&&e(r);let o,a=[];for(let t,e,s=0;s<i.length;++s){switch(e=i[s],e[0]){case 1:t=h(r,e[1],e[2]);break;case 911:t=l(r,e[1],e[2],"any")}o=o?o.then((function(e){return a.push(e),t})):t}o&&o.then((function(e){a.push(e),i.length=0,s&&s(r),t(a)}))}))};return(o.title=t)&&o}};return n},_run:t=>new Promise(((e,s)=>{t().then((function(t){e(t)}))})),runtest(t,e){const s=Date.now();return this._run(t).then((function(i){const r=Date.now(),n={title:e||t.title,date:(new Date).toString(),total:i.length,duration:r-s,passed:i.filter((t=>"P"==t[0])),skippd:i.filter((t=>"S"==t[0])),failed:i.filter((t=>"F"==t[0]))};return new Promise((t=>{t(n)}))}))}}}"object"==typeof module&&module.exports?module.exports=s(require("./core"),require("colors/safe")):t["io/czlab/mcfud/test"]=s}(this);