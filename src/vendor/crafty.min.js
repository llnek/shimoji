!function(t,e){"use strict";function s(s){const i=s?s.Basic:t["io/czlab/mcfud/algo/basic"](),r=s?s.Core:t["io/czlab/mcfud/core"](),{prnIter:o,Bag:n,Stack:h,Iterator:a,StdCompare:l}=i,c=Math.floor,{is:d,u:u}=r;function g(t,e,s,i,r){u.assert(t>e,"bad resize capacity");let o,n=new Array(t);for(o=s;o<i;++o)n[o]=r[o];return n}const f=(t,e,s)=>s(t,e)<0;function p(t,e,s){const i=t[e];t[e]=t[s],t[s]=i}function m(t){let e,s="";for(e=0;e<t.length;++e)s+=`${t[e]} `;console.log(s)}class y{static sort(t,e){const s=t.length;for(let i=1;i<s;++i)for(let s=i;s>0&&f(t[s],t[s-1],e);--s)p(t,s,s-1);return t}static sortRange(t,e,s,i){for(let r=e+1;r<s;++r)for(let s=r;s>e&&f(t[s],t[s-1],i);--s)p(t,s,s-1);return t}static indexSort(t,e){const s=t.length,i=u.fill(s,(t=>t));for(let r=1;r<s;++r)for(let s=r;s>0&&f(t[i[s]],t[i[s-1]],e);--s)p(i,s,s-1);return i}static test(){let t="SORTEXAMPLE".split("");m(y.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(y.sortRange(t,0,t.length,l)),t="SORTEXAMPLE".split(""),m(y.indexSort(t,l))}}class _{static sort(t,e){let s,i,r,o=t.length;for(let n,h=1;h<o;++h){for(i=0,r=h,n=t[h];i<r;)s=i+u.ndiv(r-i,2),f(n,t[s],e)?r=s:i=s+1;for(let e=h;e>i;--e)t[e]=t[e-1];t[i]=n}return t}static test(){let t="SORTEXAMPLE".split("");m(_.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(_.sort(t,l))}}class w{static sort(t,e){let s,i=t.length;for(let r=0;r<i;++r){s=r;for(let o=r+1;o<i;++o)f(t[o],t[s],e)&&(s=o);p(t,r,s)}return t}static test(){let t="SORTEXAMPLE".split("");m(w.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(w.sort(t,l))}}class N{static sort(t,e){let s=t.length,i=1,r=u.ndiv(s,3);for(;i<r;)i=3*i+1;for(;i>=1;){for(let r=i;r<s;++r)for(let s=r;s>=i&&f(t[s],t[s-i],e);s-=i)p(t,s,s-i);i=u.ndiv(i,3)}return t}static test(){let t="SORTEXAMPLE".split("");m(N.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(N.sort(t,l))}}function v(t,e,s,i,r,o){if(r<=i);else{let n=i+u.ndiv(r-i,2);v(t,e,s,i,n,o),v(t,e,s,n+1,r,o),function(t,e,s,i,r,o,n){for(let t=i;t<=o;++t)s[t]=e[t];let h=i,a=r+1;for(let l=i;l<=o;++l)h>r?e[l]=s[a++]:a>o?e[l]=s[h++]:f(t[s[a]],t[s[h]],n)?e[l]=s[a++]:e[l]=s[h++]}(t,e,s,i,n,r,o)}return t}class E{static sort(t,e){return function t(e,s,i,r,o){if(r<=i);else{let n=i+u.ndiv(r-i,2);t(e,s,i,n,o),t(e,s,n+1,r,o),function(t,e,s,i,r,o){for(let i=s;i<=r;++i)e[i]=t[i];let n=s,h=i+1;for(let a=s;a<=r;++a)n>i?t[a]=e[h++]:h>r?t[a]=e[n++]:f(e[h],e[n],o)?t[a]=e[h++]:t[a]=e[n++]}(e,s,i,n,r,o)}return e}(t,new Array(t.length),0,t.length-1,e),t}static indexSort(t,e){let s=t.length,i=u.fill(s,(t=>t));return v(t,i,new Array(s),0,s-1,e),i}static test(){let t="SORTEXAMPLE".split("");m(E.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(E.sort(t,l)),t="SORTEXAMPLE".split(""),m(E.indexSort(t,l))}}class x{static sort(t,e){const s=t.length;for(let i,r=0;r<s;++r){i=0;for(let o=s-1;o>r;--o)f(t[o],t[o-1],e)&&(p(t,o,o-1),++i);if(0==i)break}return t}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");x.sort(t,l),m(t)}}function k(t,e,s,i){let r=e,o=t[e],n=s+1;for(;;){for(;f(t[++r],o,i)&&r!=s;);for(;f(o,t[--n],i)&&n!=e;);if(r>=n)break;p(t,r,n)}return p(t,e,n),n}class S{static sort(t,e){return function t(e,s,i,r){if(i<=s);else{let o=k(e,s,i,r);t(e,s,o-1,r),t(e,o+1,i,r)}return e}(t,0,t.length-1,e),t}static select(t,e,s){if(e<0||e>=t.length)throw Error(`index is not between 0 and ${t.length}: ${e}`);let i=0,r=t.length-1;for(;r>i;){let o=k(t,i,r,s);if(o>e)r=o-1;else{if(!(o<e))return t[o];i=o+1}}return t[i]}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");m(S.sort(t,l)),t="SORTEXAMPLE".split(""),m(S.sort(t,l)),u.shuffle(t),t.forEach(((e,s)=>console.log(S.select(t,s,l))))}}const b=(t,e,s,i)=>f(t[e],t[s],i);class M{Node(t){return{key:t,order:0}}constructor(t,s){this.compare=t,this.table=new Map,this.head=e,this._min=e,this.n=0,d.vec(s)&&s.forEach((t=>this.insert(t)))}isEmpty(){return 0==this.n}size(){return this.n}insert(t){let e=this.Node(t);this.n+=1,this.head=this._insertNode(e,this.head),this._min=this._min?this._greater(this._min.key,t)?this.head:this._min:this.head}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cut(this._min,this.head);let t=this._min.child,s=this._min.key;return this._min.key=e,t&&(this.head=this._meld(this.head,t),this._min.child=e),this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),s}union(t){return this.head=this._meld(this.head,t.head),this._min=this._greater(this._min.key,t._min.key)?t._min:this._min,this.n=this.n+t.n,this}_greater(t,e){return!u.nichts(t)&&(!!u.nichts(e)||this.compare(t,e)>0)}_link(t,e){e.child=this._insertNode(t,e.child),e.order+=1}_consolidate(){this.table.clear();let t=this.head,s=e,i=e,r=0;this._min=this.head;do{for(s=t,t=t.next,i=this.table.get(s.order);i;)this.table.delete(s.order),this._greater(s.key,i.key)?(this._link(s,i),s=i):this._link(i,s),i=this.table.get(s.order);this.table.set(s.order,s),s.order>r&&(r=s.order)}while(t!==this.head);this.head=null,this.table.forEach((t=>{t&&(this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head))}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cut(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new M(this.compare),e=s=>{if(!s)return;let i=s;do{t.insert(i.key),e(i.child),i=i.next}while(i!==s)};return e(this.head),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new M(l);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",e.isEmpty(),console.log(t),console.log("min= "+e.min()),console.log(o(e.iter())),console.log("("+e.size()+" left on pq)");let s=new M(l);"ZTAK".split("").forEach((t=>s.insert(t))),s=s.union(e),console.log(o(s.iter()))}}class I{Node(t){return{key:t,order:0,index:0}}constructor(t,s){if(t<0)throw Error("Cannot create a priority queue of negative size");this.maxN=t,this.n=0,this.head=e,this._min=e,this.compare=s,this.table=new Map,this.nodes=new Array(t)}isEmpty(){return 0==this.n}contains(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");return u.echt(this.nodes[t])}size(){return this.n}insert(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(this.contains(t))throw Error("Specified index is already in the queue");let s=this.Node(e);s.index=t,this.nodes[t]=s,this.n+=1,this.head=this._insertNode(s,this.head),this._min=this._min?this._greater(this._min.key,e)?this.head:this._min:this.head}minIndex(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.index}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cutNode(this._min,this.head);let t=this._min.child,s=this._min.index;if(this._min.key=e,t){do{t.parent=e,t=t.next}while(t!==this._min.child);this.head=this._meld(this.head,t),this._min.child=e}return this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),this.nodes[s]=e,s}keyOf(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");return this.nodes[t].key}changeKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");this._greater(e,this.nodes[t].key)?this.increaseKey(t,e):this.decreaseKey(t,e)}decreaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(e,this.nodes[t].key))throw Error("Calling with this argument would not decrease the key");let s=this.nodes[t];s.key=e,this._greater(this._min.key,e)&&(this._min=s),s.parent&&this._greater(s.parent.key,e)&&this._cut(t)}increaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(this.nodes[t].key,e))throw Error("Calling with this argument would not increase the key");this.delete(t),this.insert(t,e)}delete(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");let s=this.nodes[t];if(s.key=null,s.parent&&this._cut(t),this.head=this._cutNode(s,this.head),s.child){let t=s.child;s.child=e,s=t;do{t.parent=e,t=t.next}while(t!==s);this.head=this._meld(this.head,t)}this.isEmpty()?this._min=e:this._consolidate(),this.nodes[t]=e,this.n-=1}_greater(t,e){return!u.nichts(t)&&(!!u.nichts(e)||this.compare(t,e)>0)}_link(t,e){t.parent=e,e.child=this._insertNode(t,e.child),e.order+=1}_cut(t){let s=this.nodes[t],i=s.parent;i.child=this._cutNode(s,i.child),s.parent=e,i.order-=1,this.head=this._insertNode(s,this.head),i.mark=!i.mark,!i.mark&&i.parent&&this._cut(i.index)}_consolidate(){let t=e,s=e,i=0,r=this.head;this.table.clear(),this._min=this.head;do{for(t=r,r=r.next,s=this.table.get(t.order);s;)this.table.delete(t.order),this._greater(t.key,s.key)?(this._link(t,s),t=s):this._link(s,t),s=this.table.get(t.order);this.table.set(t.order,t),t.order>i&&(i=t.order)}while(r!==this.head);this.head=e,this.table.forEach((t=>{this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head)}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cutNode(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new I(this.maxN,this.compare);return this.nodes.forEach((e=>{e&&t.insert(e.index,e.key)})),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new I(t.length,l);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(console.log("min= "+e.min()),console.log("minindex= "+e.minIndex()),console.log("size= "+e.size()),console.log("contains(3)="+e.contains(3)),console.log("keyOf(3)="+e.keyOf(3)),e.changeKey(3,"bbbb");!e.isEmpty();){let t=e.minIndex();console.log(t+" "+e.keyOf(t)),e.delMin()}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class T{constructor(t,e){if(this.comparator=t,this.n=0,d.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t,this)}else this.pq=new Array(d.num(e)?e:2);u.assert(this._isMinHeap(),"not min heap")}isEmpty(){return 0==this.n}size(){return this.n}min(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=g(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.pq[++this.n]=t,this._swim(this.n),u.assert(this._isMinHeap(),"not min heap-insert")}delMin(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return p(this.pq,1,this.n--),this._sink(1),this.pq[this.n+1]=e,this.n>0&&this.n==u.ndiv(this.pq.length-1,4)&&(this.pq=g(u.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_swim(t){for(;t>1&&this._greater(u.ndiv(t,2),t);)p(this.pq,t,u.ndiv(t,2)),t=u.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&e++,!this._greater(t,e))break;p(this.pq,t,e),t=e}}_greater(t,e){return this.comparator(this.pq[t],this.pq[e])>0}_isMinHeap(){for(let t=1;t<=this.n;++t)if(u.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(!u.nichts(this.pq[t]))return!1;return!u.echt(this.pq[0])&&this._isMinHeapOrdered(1)}_isMinHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&this._greater(t,e))&&(!(s<=this.n&&this._greater(t,s))&&(this._isMinHeapOrdered(e)&&this._isMinHeapOrdered(s)))}iter(){let t=new T(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new T(l);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}class O{constructor(t,e){if(this.comparator=t,this.n=0,d.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t)}else this.pq=new Array(d.num(e)?e:2);u.assert(this._isMaxHeap(),"not max heap")}isEmpty(){return 0==this.n}size(){return this.n}max(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=g(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.n+=1,this.pq[this.n]=t,this._swim(this.n),u.assert(this._isMaxHeap(),"not max heap-insert")}delMax(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return p(this.pq,1,this.n),this.n-=1,this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==u.ndiv(this.pq.length-1,4)&&(this.pq=g(u.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_isMaxHeap(){for(let t=1;t<=this.n;++t)if(u.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(u.echt(this.pq[t]))return!1;return!u.echt(this.pq[0])&&this._isMaxHeapOrdered(1)}_isMaxHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&b(this.pq,t,e,this.comparator))&&(!(s<=this.n&&b(this.pq,t,s,this.comparator))&&(this._isMaxHeapOrdered(e)&&this._isMaxHeapOrdered(s)))}_swim(t){for(;t>1&&b(this.pq,u.ndiv(t,2),t,this.comparator);)p(this.pq,t,u.ndiv(t,2)),t=u.ndiv(t,2)}_sink(t){let e;for(;2*t<=this.n&&(e=2*t,e<this.n&&b(this.pq,e,e+1,this.comparator)&&++e,b(this.pq,t,e,this.comparator));)p(this.pq,t,e),t=e}iter(){const t=new O(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t="",e=new O(l);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}function D(t,e,s,i){return i(t[e-1],t[s-1])<0}function A(t,e,s){const i=t[e-1];t[e-1]=t[s-1],t[s-1]=i}class z{static sort(t,e){function s(t,e,s,i){for(;2*e<=s;){let r=2*e;if(r<s&&D(t,r,r+1,i)&&++r,!D(t,e,r,i))break;A(t,e,r),e=r}}let i,r=t.length;for(i=u.ndiv(r,2);i>=1;--i)s(t,i,r,e);for(i=r;i>1;)A(t,1,i--),s(t,1,i,e);return t}static test(){let t="SORTEXAMPLE".split("");m(z.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(z.sort(t,l))}}class q{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}minIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}minKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMin(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),u.assert(t==this.pq[this.n+1],"No good"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(s<0)throw Error("Calling decreaseKey() with a key strictly greater than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(s>0)throw Error("Calling increaseKey() with a key strictly less than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_greater(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])>0}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._greater(u.ndiv(t,2),t);)this._exch(t,u.ndiv(t,2)),t=u.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&++e,!this._greater(t,e))break;this._exch(t,e),t=e}}iter(){let t=new q(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new q(t.length,l);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(;!e.isEmpty();){let s=e.delMin();console.log(s+" "+t[s])}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class C{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}maxIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}maxKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMax(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),u.assert(this.pq[this.n+1]==t,"bad delMax"),this.qp[t]=-1,this.mKeys[t]=e,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)>0)throw Error("Calling increaseKey() with a key that is strictly less than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)<0)throw Error("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_less(t,e){return f(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]],this.compare)}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._less(u.ndiv(t,2),t);)this._exch(t,u.ndiv(t,2)),t=u.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._less(e,e+1)&&++e,!this._less(t,e))break;this._exch(t,e),t=e}}iter(){let t=new C(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new C(t.length,l);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);console.log("");for(let s=0;s<t.length;++s)u.rand()<.5?e.increaseKey(s,t[s]+t[s]):e.decreaseKey(s,t[s].substring(0,1));for(;!e.isEmpty();){let t=e.maxKey(),s=e.delMax();console.log(s+" "+t)}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);let s=new Array(t.length);for(let e=0;e<t.length;++e)s[e]=e;u.shuffle(s);for(let t=0;t<s.length;++t){let i=e.keyOf(s[t]);e.delete(s[t]),console.log(s[t]+" "+i)}}}return{FibonacciMinPQ:M,IndexFibonacciMinPQ:I,Insertion:y,BinaryInsertion:_,Selection:w,Shell:N,Merge:E,Bubble:x,Quick:S,MinPQ:T,MaxPQ:O,Heap:z,IndexMinPQ:q,IndexMaxPQ:C}}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/sort"]=s}(this),function(t,e){"use strict";function s(s,i){const r=s?s.Basic:t["io/czlab/mcfud/algo/basic"](),o=s?s.Core:t["io/czlab/mcfud/core"](),n=s?s.Math:t["io/czlab/mcfud/math"]();i||(i=t["io/czlab/mcfud/algo/sort"]());const{Bag:h,Stack:a,Queue:l,StdCompare:c,prnIter:d}=r,{MinPQ:u}=i,{is:g,u:f}=(Math.floor,o);class p{static count(t,e){let s=new Map,i=0,r="",o=0;for(let r,n=0;n<t.length;++n)r=t[n],r.length<e||(++i,s.has(r)?s.set(r,s.get(r)+1):(s.set(r,1),++o));return s.set(r,0),Array.from(s.keys()).forEach((t=>{s.get(t)>s.get(r)&&(r=t)})),[r,s.get(r),[o,i]]}static test(){let t="it was the best of times it was the worst of times\n        it was the age of wisdom it was the age of foolishness\n        it was the epoch of belief it was the epoch of incredulity\n        it was the season of light it was the season of darkness\n        it was the spring of hope it was the winter of despair".split(" "),[e,s,i]=p.count(t,1);console.log(e+" "+s),console.log("distinct = "+i[0]),console.log("words= "+i[1])}}class m{constructor(){this.first=e,this.n=0}size(){return this.n}isEmpty(){return 0==this.size()}contains(t){if(f.nichts(t))throw Error("argument to contains is null");return void 0!==this.get(t)}get(t){if(f.nichts(t))throw Error("argument to get is null");for(let e=this.first;e;e=e.next)if(t==e.key)return e.val}put(t,e){if(f.nichts(t))throw Error("first argument to put is null");if(void 0===e)this.delete(t);else{let s,i;for(i=this.first;i&&!s;i=i.next)t==i.key&&(i.val=e,s=!0);s||(this.first=((t,e,s)=>({key:t,val:e,next:s}))(t,e,this.first),this.n+=1)}}delete(t){const s=(t,i)=>t?i==t.key?(this.n-=1,t.next):(t.next=s(t.next,i),t):e;if(f.nichts(t))throw Error("argument to delete is null");this.first=s(this.first,t)}keys(){let t=new l;for(let e=this.first;e;e=e.next)t.enqueue(e.key);return t.iter()}static load(t){let e=new m;return t.forEach(((t,s)=>e.put(t,s))),e}static test(){let t=m.load("SEARCHEXAMPLE".split(""));console.log(((e="",s=0,i=0)=>{for(i=t.keys();i.hasNext();)e+=`${s=i.next()}=${t.get(s)} `;return e})()),console.log("size= "+t.size()),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),t.delete("R"),t.isEmpty(),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),console.log("size= "+t.size())}}class y{constructor(t,e=2){this.mKeys=new Array(e),this.vals=new Array(e),this.compare=t,this.n=0,this._resize=t=>{let e=new Array(t),s=new Array(t);for(let t=0;t<this.n;++t)e[t]=this.mKeys[t],s[t]=this.vals[t];this.vals=s,this.mKeys=e},this._argOk=t=>f.echt(t,"Invalid argument"),this._check=()=>(()=>{for(let t=1;t<this.size();++t)if(this.compare(this.mKeys[t],this.mKeys[t-1])<0)return!1;return!0})()&&(()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0;t<this.size();++t)if(0!=this.compare(this.mKeys[t],this.select(this.rank(this.mKeys[t]))))return!1;return!0})()}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){if(this._argOk(t)&&!this.isEmpty()){let e=this.rank(t);if(e<this.n&&0==this.compare(this.mKeys[e],t))return this.vals[e]}}rank(t){let e,s,i=0,r=this.n-1;for(this._argOk(t);i<=r;)if(e=i+n.ndiv(r-i,2),s=this.compare(t,this.mKeys[e]),s<0)r=e-1;else{if(!(s>0))return e;i=e+1}return i}put(t,e){if(this._argOk(t)&&void 0===e)this.delete(t);else{let s=this.rank(t);if(s<this.n&&0==this.compare(this.mKeys[s],t))this.vals[s]=e;else{this.n==this.mKeys.length&&this._resize(2*this.mKeys.length);for(let t=this.n;t>s;--t)this.mKeys[t]=this.mKeys[t-1],this.vals[t]=this.vals[t-1];this.n+=1,this.mKeys[s]=t,this.vals[s]=e}}}delete(t){if(this._argOk(t)&&this.isEmpty());else{let s=this.rank(t);if(s==this.n||0!=this.compare(this.mKeys[s],t));else{for(let t=s;t<this.n-1;++t)this.mKeys[t]=this.mKeys[t+1],this.vals[t]=this.vals[t+1];this.n-=1,this.mKeys[this.n]=e,this.vals[this.n]=e,this.n>0&&this.n==n.ndiv(this.mKeys.length,4)&&this._resize(n.ndiv(this.mKeys.length,2)),this._check()}}}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.min())}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.max())}min(){if(this.isEmpty())throw Error("called min with empty symbol table");return this.mKeys[0]}max(){if(this.isEmpty())throw Error("called max with empty symbol table");return this.mKeys[this.n-1]}select(t){if(t<0||t>=this.size())throw Error(`called select with invalid argument: ${t}`);return this.mKeys[t]}floor(t){let e=this._argOk(t)&&this.rank(t);if(e<this.n&&0==this.compare(t,this.mKeys[e]))return this.mKeys[e];if(0==e)throw Error("argument to floor is too small");return this.mKeys[e-1]}ceiling(t){let e=this._argOk(t)&&this.rank(t);if(e==this.n)throw Error("argument to ceiling is too large");return this.mKeys[e]}size(t,e){return 0==arguments.length?this.n:(this._argOk(t)&&this._argOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}keys(t,e){0==arguments.length&&(t=this.min(),e=this.max()),this._argOk(t)&&this._argOk(e);let s=new l;if(this.compare(t,e)>0);else{for(let i=this.rank(t);i<this.rank(e);++i)s.enqueue(this.mKeys[i]);this.contains(e)&&s.enqueue(this.mKeys[this.rank(e)])}return s.iter()}static load(t,e){let s=new y(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t=y.load("SEARCHEXAMPLE".split(""),c),e=e=>{e="";for(let s,i=t.keys();i.hasNext();)s=i.next(),e+=`${s}=${t.get(s)} `;return e};console.log(e()),t.deleteMin(),console.log(e()),t.deleteMax(),t.isEmpty(),console.log(e()),console.log("floor of Q= "+t.floor("Q")),console.log("ceil of Q= "+t.ceiling("Q")),console.log("size= "+t.size()),console.log("size= "+t.size("E","P")),console.log("keys E->P = "+d(t.keys("E","P")))}}class _{constructor(t){this.compare=t,this.root=e,this._argOk=t=>f.assert(t,"Invalid argument"),this._check=()=>(this.isBST(this.root,null,null)||console.log("Not in symmetric order"),this.isSizeConsistent(this.root)||console.log("Subtree counts not consistent"),this.isRankConsistent()||console.log("Ranks not consistent"),this.isBST(this.root,null,null)&&this.isSizeConsistent(this.root)&&this.isRankConsistent()),this.isBST=(t,e,s)=>!!f.nichts(t)||!(f.echt(e)&&this.compare(t.key,e)<=0)&&(!(f.echt(s)&&this.compare(t.key,s)>=0)&&(this.isBST(t.left,e,t.key)&&this.isBST(t.right,t.key,s))),this.isSizeConsistent=t=>!!f.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(this.isSizeConsistent(t.left)&&this.isSizeConsistent(t.right)),this.isRankConsistent=()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this.rank(t))))return!1;return!0}}Node(t,e,s){return{key:t,val:e,size:s}}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){return this._getNode(this.root,t)}_getNode(t,e){if(!this._argOk(e)||!f.nichts(t)){let s=this.compare(e,t.key);return s<0?this._getNode(t.left,e):s>0?this._getNode(t.right,e):t.val}}put(t,e){this._argOk(t)&&f.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this._check())}_putNode(t,e,s){if(f.nichts(t))t=this.Node(e,s,1);else{let i=this.compare(e,t.key);i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right)}return t}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMinNode(this.root),this._check()}_deleteMinNode(t){return f.nichts(t.left)?t=t.right:(t.left=this._deleteMinNode(t.left),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMaxNode(this.root),this._check()}_deleteMaxNode(t){return f.nichts(t.right)?t=t.left:(t.right=this._deleteMaxNode(t.right),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}delete(t){this.root=this._argOk(t)&&this._deleteNode(this.root,t),this._check()}_deleteNode(t,e){if(f.echt(t)){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(f.nichts(t.right))return t.left;if(f.nichts(t.left))return t.right;let e=t;(t=this._minNode(e.right)).right=this._deleteMinNode(e.right),t.left=e.left}t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1}return t}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return f.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return f.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(f.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0)return this._floorNode(t.left,e);let i=this._floorNode(t.right,e);return f.nichts(i)?t:i}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too large");return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0){let e=this._ceilingNode(t.left,s);return e||t}return this._ceilingNode(t.right,s)}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(f.nichts(t));else{let r=this.compare(s,t.key),o=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&o>=0&&e.enqueue(t.key),o>0&&this._keysNode(t.right,e,s,i)}return e}_sizeNode(t){return f.nichts(t)?0:t.size}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}height(){return this._heightNode(this.root)}_heightNode(t){return f.nichts(t)?-1:1+Math.max(this._heightNode(t.left),this._heightNode(t.right))}levelOrder(){let t,e=[],s=new l;for(e.push(this.root);e.length>0;)t=e.pop(),f.echt(t)&&(s.enqueue(t.key),e.push(t.left,t.right));return s.iter()}static load(t,e){let s=new _(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=_.load("SEARCHEXAMPLE".split(""),c);t="";for(let s,i=e.levelOrder();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("level-order:\n"+t),t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;e.isEmpty(),console.log("keys=\n"+t),console.log("size="+e.size()),console.log("size E->Q = ",e.size("E","Q")),t="";for(let s,i=e.keys("E","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[E->Q]= "+t),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank P= "+e.rank("P")),console.log("contains X= "+e.contains("X")),console.log("contains Z= "+e.contains("Z")),e.delete("X"),console.log("get C="+e.get("C")),console.log("max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("height= "+e.height()),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank E= "+e.rank("E")),console.log("floor G= "+e.floor("G")),console.log("ceiling G= "+e.ceiling("G"))}}class w{static BLACK=!1;static RED=!0;constructor(t){this.compare=t,this.root=e,this._argOk=t=>f.assert(t,"Invalid argument"),this._check=()=>{let t=(e,s,i)=>!!f.nichts(e)||!(s&&this.compare(e.key,s)<=0)&&(!(i&&this.compare(e.key,i)>=0)&&(t(e.left,s,e.key)&&t(e.right,e.key,i))),e=t=>!!f.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(e(t.left)&&e(t.right)),s=t=>!!f.nichts(t)||!this._isRed(t.right)&&((t===this.root||!this._isRed(t)||!this._isRed(t.left))&&(s(t.left)&&s(t.right))),i=(t,e)=>f.nichts(t)?0==e:(this._isRed(t)||--e,i(t.left,e)&&i(t.right,e));return t(this.root,null,null)&&e(this.root)&&(()=>{for(let t=0;t<this.size();++t)if(t!=this._rankNode(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this._rankNode(t))))return!1;return!0})()&&s(this.root)&&(()=>{let t=0,e=this.root;for(;e;)this._isRed(e)||++t,e=e.left;return i(this.root,t)})()}}Node(t,e,s,i){return{key:t,val:e,color:s,size:i}}_isRed(t){return!f.nichts(t)&&t.color===w.RED}_sizeNode(t){return f.nichts(t)?0:t.size}isEmpty(){return f.nichts(this.root)}get(t){return this._argOk(t)&&this._getNode(this.root,t)}_getNode(t,e){for(;t;){let s=this.compare(e,t.key);if(s<0)t=t.left;else{if(!(s>0))return t.val;t=t.right}}}contains(t){return void 0!==this.get(t)}put(t,e){this._argOk(t)&&f.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.root.color=w.BLACK)}_putNode(t,e,s){if(f.nichts(t))return this.Node(e,s,w.RED,1);let i=this.compare(e,t.key);return i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}deleteMin(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=w.RED),this.root=this._deleteMinNode(this.root),this.isEmpty()||(this.root.color=w.BLACK)}_deleteMinNode(t){return f.nichts(t.left)?null:(this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteMinNode(t.left),this._balance(t))}deleteMax(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=w.RED),this.root=this._deleteMaxNode(this.root),this.isEmpty()||(this.root.color=w.BLACK)}_deleteMaxNode(t){return this._isRed(t.left)&&(t=this._rotateRight(t)),f.nichts(t.right)?null:(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),t.right=this._deleteMaxNode(t.right),this._balance(t))}delete(t){this._argOk(t)&&!this.contains(t)||(this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=w.RED),this.root=this._deleteNode(this.root,t),this.isEmpty()||(this.root.color=w.BLACK))}_deleteNode(t,e){if(this.compare(e,t.key)<0)this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteNode(t.left,e);else{if(this._isRed(t.left)&&(t=this._rotateRight(t)),0==this.compare(e,t.key)&&f.nichts(t.right))return null;if(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),0==this.compare(e,t.key)){let e=this._minNode(t.right);t.key=e.key,t.val=e.val,t.right=this._deleteMinNode(t.right)}else t.right=this._deleteNode(t.right,e)}return this._balance(t)}_rotateRight(t){if(f.nichts(t)||!this._isRed(t.left))throw Error("bad input to rotateRight");let e=t.left;return t.left=e.right,e.right=t,e.color=e.right.color,e.right.color=w.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_rotateLeft(t){if(f.nichts(t)||!this._isRed(t.right))throw Error("bad input to rotateLeft");let e=t.right;return t.right=e.left,e.left=t,e.color=e.left.color,e.left.color=w.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_flipColors(t){t.color=!t.color,t.left.color=!t.left.color,t.right.color=!t.right.color}_moveRedLeft(t){return this._flipColors(t),this._isRed(t.right.left)&&(t.right=this._rotateRight(t.right),t=this._rotateLeft(t),this._flipColors(t)),t}_moveRedRight(t){return this._flipColors(t),this._isRed(t.left.left)&&(t=this._rotateRight(t),this._flipColors(t)),t}_balance(t){return this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}height(){return this._height(this.root)}_height(t){return f.nichts(t)?-1:1+Math.max(this._height(t.left),this._height(t.right))}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return f.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return f.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(f.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(f.nichts(e))throw Error("argument to ceiling is too small");return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),o=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&o>=0&&e.enqueue(t.key),o>0&&this._keysNode(t.right,e,s,i)}return e}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}static load(t,e){let s=new w(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=w.load("SEARCHEXAMPLE".split(""),c);t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log(t),e.isEmpty(),console.log("height= "+e.height()+", size= "+e.size()),console.log("get X= "+e.get("X")),console.log("contains X= "+e.contains("X")),console.log("min= "+e.min()+",max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("min= "+e.min()+",max= "+e.max()),e.delete("R"),console.log("contains R= "+e.contains("R")),console.log("floor J= "+e.floor("J")),console.log("ceiling J= "+e.ceiling("J")),console.log("rank M= "+e.rank("M")),t="";for(let s,i=e.keys("D","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[D-Q]= "+t),console.log("size[E-P]= "+e.size("E","P"))}}class N{static indexOf(t,e){let s=0,i=t.length-1;for(;s<=i;){let r=s+n.ndiv(i-s,2);if(e<t[r])i=r-1;else{if(!(e>t[r]))return r;s=r+1}}return-1}static test(){let t="84 48 68 10 18 98 12 23 54 57 33 16 77 11 29".split(" ").map((t=>+t)).sort();"23 50 10 99 18 23 98 84 11 10 48 77 13 54 98 77 77 68".split(" ").map((t=>+t)).forEach((e=>{N.indexOf(t,e)<0&&console.log(e)}))}}class v{Node(t,e,s,i){return{key:t,val:e,height:s,size:i}}constructor(t){this.compare=t,this.root=e}isEmpty(){return f.nichts(this.root)}_sizeNode(t){return f.nichts(t)?0:t.size}height(){return this._heightNode(this.root)}_heightNode(t){return f.nichts(t)?-1:t.height}get(t){if(f.nichts(t))throw Error("argument to get() is null");let e=this._getNode(this.root,t);if(e)return e.val}_getNode(t,s){if(!t)return e;let i=this.compare(s,t.key);return i<0?this._getNode(t.left,s):i>0?this._getNode(t.right,s):t}contains(t){return void 0!==this.get(t)}put(t,e){if(f.nichts(t))throw Error("first argument to put() is null");void 0===e?this.delete(t):this.root=this._putNode(this.root,t,e)}_putNode(t,e,s){if(!t)return this.Node(e,s,0,1);let i=this.compare(e,t.key);if(i<0)t.left=this._putNode(t.left,e,s);else{if(!(i>0))return t.val=s,t;t.right=this._putNode(t.right,e,s)}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balanceNode(t)}_balanceNode(t){return this._balanceFactor(t)<-1?(this._balanceFactor(t.right)>0&&(t.right=this._rotateRight(t.right)),t=this._rotateLeft(t)):this._balanceFactor(t)>1&&(this._balanceFactor(t.left)<0&&(t.left=this._rotateLeft(t.left)),t=this._rotateRight(t)),t}_balanceFactor(t){return this._heightNode(t.left)-this._heightNode(t.right)}_rotateRight(t){let e=t.left;return t.left=e.right,e.right=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}_rotateLeft(t){let e=t.right;return t.right=e.left,e.left=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}delete(t){if(f.nichts(t))throw Error("argument to delete() is null");this.contains(t)&&(this.root=this._deleteNode(this.root,t))}_deleteNode(t,e){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(!t.left)return t.right;if(!t.right)return t.left;let e=t;(t=this.min(e.right)).right=this.deleteMin(e.right),t.left=e.left}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)}deleteMin(){if(this.isEmpty())throw Error("called deleteMin() with empty symbol table");this.root=this._deleteMinNode(this.root)}_deleteMinNode(t){return t.left?(t.left=this._deleteMinNode(t.left),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.right}deleteMax(){if(this.isEmpty())throw Error("called deleteMax() with empty symbol table");this.root=this._deleteMaxNode(this.root)}_deleteMaxNode(t){return t.right?(t.right=this._deleteMaxNode(t.right),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.left}min(){if(this.isEmpty())throw Error("called min() with empty symbol table");return this._minNode(this.root).key}_minNode(t){return t.left?this._minNode(t.left):t}max(){if(this.isEmpty())throw Error("called max() with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return t.right?this._maxNode(t.right):t}floor(t){if(f.nichts(t))throw Error("argument to floor() is null");if(this.isEmpty())throw Error("called floor() with empty symbol table");let e=this._floorNode(this.root,t);if(e)return e.key}_floorNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(f.nichts(t))throw Error("argument to ceiling() is null");if(this.isEmpty())throw Error("called ceiling() with empty symbol table");let e=this._ceilingNode(this.root,t);if(e)return e.key}_ceilingNode(t,s){if(f.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error("k is not in range 0-"+(this.size()-1));let e=this._selectNode(this.root,t);if(e)return e.key}_selectNode(t,s){if(f.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t}rank(t){if(f.nichts(t))throw Error("argument to rank() is null");return this._rankNode(t,this.root)}_rankNode(t,e){if(f.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keysInOrder(){let t=new l;return this._keysInOrderNode(this.root,t),t.iter()}_keysInOrderNode(t,e){f.nichts(t)||(this._keysInOrderNode(t.left,e),e.enqueue(t.key),this._keysInOrderNode(t.right,e))}keysLevelOrder(){let t=new l;if(!this.isEmpty()){let e=new l;for(e.enqueue(this.root);!e.isEmpty();){let s=e.dequeue();t.enqueue(s.key),s.left||e.enqueue(s.left),s.right&&e.enqueue(s.right)}}return t}keys(t,e){if(0==arguments.length)return this.keysInOrder();if(f.nichts(t))throw Error("first argument to keys() is null");if(f.nichts(e))throw Error("second argument to keys() is null");let s=new l;return this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),o=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&o>=0&&e.enqueue(t.key),o>0&&this._keysNode(t.right,e,s,i)}}size(t,e){if(0==arguments.length)return this._sizeNode(this.root);if(f.nichts(t))throw Error("first argument to size() is null");if(f.nichts(e))throw Error("second argument to size() is null");return this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}_check(){let t=this;return function e(s,i,r){return!s||!(!i&&t.compare(s.key,i)<=0)&&(!(!r&&t.compare(s.key,r)>=0)&&(e(s.left,i,s.key)&&e(s.right,s.key,r)))}(this.root,null,null)&&function e(s){if(!s)return!0;let i=t._balanceFactor(s);return!(i>1||i<-1)&&(e(s.left)&&e(s.right))}(this.root)&&function e(s){return!s||s.size==t._sizeNode(s.left)+t._sizeNode(s.right)+1&&(e(s.left)&&e(s.right))}(this.root)&&function(){for(let e=0;e<t.size();e++)if(e!=t.rank(t.select(e)))return!1;for(let e,s=t.keys().iterator();s.hasNext();)if(e=s.next(),0!=this.compare(e,t.select(t.rank(key))))return!1;return!0}()}static test(){let t=new v(c);"SEARCHEXAMPLE".split("").forEach(((e,s)=>t.put(e,s)));for(let e,s=t.keys();s.hasNext();)e=s.next(),console.log(e+" "+t.get(e))}}const E=Math.sqrt(2);function x(t,e){return{parent:e,pos:t,f:0,g:0,h:0,pid:`${t[0]},${t[1]}`,equals(t){return this.pos[0]==t.pos[0]&&this.pos[1]==t.pos[1]}}}class k{static manhattan(t,e,s=1){return s*Math.abs(t[1]-e[1])+s*Math.abs(t[0]-e[0])}static euclidean(t,e,s=1){let i=e[0]-t[0],r=e[1]-t[1];return s*(i*i+r*r)}static diagonal(t,e,s=1,i=E){let r=Math.abs(e[0]-t[0]),o=Math.abs(e[1]-t[1]);return s*(r+o)+(i-2*s)*Math.min(r,o)}constructor(t){this.grid=t}pathTo(t,e,s){return this._search(this.grid,t,e,s)}_search(t,e,s,i){const r=i.compare,o=t.length,n=t[0].length,h=new Map,a=new Map,l=new u(r,10),c=x(s),d=x(e),g=[[1,0],[-1,0],[0,1],[0,-1]],f=(t,e)=>{for(;t;t=t.parent)e.unshift(t.pos);return e};i.wantDiagonal&&g.push([1,1],[1,-1],[-1,1],[-1,-1]),a.set(d.pid,d.g),l.insert(d);let p,m=[];for(;!l.isEmpty();){if(p=l.delMin(),a.delete(p.pid),h.set(p.pid,0),p.equals(c))return f(p,[]);m.length=0;for(let t,e=0;e<g.length;++e)t=[p.pos[0]+g[e][0],p.pos[1]+g[e][1]],t[0]>n-1||t[0]<0||t[1]>o-1||t[1]<0||i.blocked(t)||m.push(x(t,p));m.forEach((t=>{h.has(t.pid)||(t.g=p.g+i.cost(),t.h=i.calcHeuristic(t.pos,c.pos),t.f=t.g+t.h,a.has(t.pid)&&t.g>a.get(t.pid)||(l.insert(t),a.set(t.pid,t.g)))}))}}static test(){let t,e,s,i=[[0,1,0,0,0,0],[0,0,0,0,0,0],[0,1,0,1,0,0],[0,1,0,0,1,0],[0,0,0,0,1,0]],r=i.length,o=i[0].length,n={wantDiagonal:!1,compare:(t,e)=>t.f-e.f,cost:()=>1,blocked:t=>0!=i[t[1]][t[0]],calcHeuristic:(t,e)=>k.euclidean(t,e)},h=new k(i).pathTo([0,0],[5,4],n);h?(s="",h.forEach((t=>{s+=`[${t[0]},${t[1]}] `})),console.log(s),e=f.fill(r,(()=>f.fill(o,"#"))),t=0,h.forEach((s=>{e[s[1]][s[0]]=""+t,++t})),e.forEach((t=>{console.log(t.toString())}))):console.log("no path")}}return{AStarGrid:k,AVLTreeST:v,RedBlackBST:w,BST:_,BinarySearch:N,BinarySearchST:y,FrequencyCounter:p,SequentialSearchST:m}}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud"),require("./sort")):t["io/czlab/mcfud/algo/search"]=s}(this),function(t,e){"use strict";function s(s,i){const r=s?s.Basic:t["io/czlab/mcfud/algo/basic"](),o=s?s.Core:t["io/czlab/mcfud/core"]();s?s.Math:t["io/czlab/mcfud/math"]();i||(i=t["io/czlab/mcfud/algo/sort"]());const{prnIter:n,TreeMap:h,Bag:a,Stack:l,Queue:c,ST:d,StdCompare:u}=r,{IndexMinPQ:g,MinPQ:f}=i,{is:p,u:m}=(Math.floor,o);function y(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`);return!0}class _{constructor(t){m.assert(t>=0,"Number of vertices must be non-negative"),this.verts=t,this.edges=0,this.adjls=m.fill(t,(()=>new a))}clone(){let t=new _(this.V());t.edges=this.E(),t.adjls=[];for(let e=0,s=this.V();e<s;++e)t.adjls.push(this.adjls[e].clone());return t}V(){return this.verts}E(){return this.edges}addEdge(t,e){y(t,this.verts),y(e,this.verts),this.edges+=1,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return y(t,this.verts)&&this.adjls[t]}degree(t){return y(t,this.verts)&&this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e=0;e<this.verts;++e)t+=`${e}: `+n(this.adjls[e].iter()),t+="\n";return t}static load(t,e){let s=new _(t);m.assert(e.length%2==0,"wanted even n# of data points");for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}static test(){let t=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);t.degree(1),console.log(t.toString());let e=t.clone();console.log("cloned=\n"+e.toString())}}class w{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.nCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.nCount}static test(){let t,e,s=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new w(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t),console.log(e.count()!=s.V()?"NOT connected":"connected")}))}}class N{constructor(t,e){this.bMarked=new Array(t.V()),y(e,this.bMarked.length);let s,i,r=m.fill(t.V(),(e=>t.adj(e).iter())),o=new l;for(this.bMarked[e]=!0,o.push(e);!o.isEmpty();)s=o.peek(),r[s].hasNext()?(i=r[s].next(),this.bMarked[i]||(this.bMarked[i]=!0,o.push(i))):o.pop()}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}static test(){let t,e,s=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new N(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t)}))}}class v{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new l;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t=_.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new v(t,0);for(let s,i,r=0;r<t.V();++r)if(e.hasPathTo(r)){s=`0 to ${r}:  `;for(let t=e.pathTo(r);t.hasNext();)i=t.next(),s+=0==i?i:`-${i}`;console.log(s)}else console.log(`0 to ${r}:  not connected\n`)}}function E(t,e,s){let i,r=[];for(i=0;i<t.V();++i)s.mDistTo[i]=1/0;for(e.forEach((t=>{s.bMarked[t]=!0,s.mDistTo[t]=0,r.push(t)}));r.length>0;){i=r.shift();for(let e,o=t.adj(i).iter();o.hasNext();)e=o.next(),s.bMarked[e]||(s.edgeTo[e]=i,s.mDistTo[e]=s.mDistTo[i]+1,s.bMarked[e]=!0,r.push(e))}}function x(t,e){if(!t||0==t.length)throw Error("argument is null or empty");return t.forEach((t=>y(t,e))),!0}class k{constructor(t,e){this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V()),p.vec(e)||(e=[e]),x(e,t.V()),E(t,e,this),function(t,e,s){if(0!=s.mDistTo[e])throw Error(`dist of source ${e} to itself = ${s.mDistTo[e]}`);for(let e=0;e<t.V();++e)for(let i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s.hasPathTo(e)!==s.hasPathTo(i))throw Error(`edge ${e}-${i}hasPathTo(${e})=${s.hasPathTo(e)}hasPathTo(${i})=${s.hasPathTo(i)}`);if(s.hasPathTo(e)&&s.mDistTo[i]>s.mDistTo[e]+1)throw Error(`edge ${e}-${i}distTo[${e}]=${s.mDistTo[e]}distTo[${i}]=${s.mDistTo[i]}`)}for(let i,r=0;r<t.V();++r)if(s.hasPathTo(r)&&r!=e&&(i=s.edgeTo[r],s.mDistTo[r]!=s.mDistTo[i]+1))throw Error(`shortest path edge ${i}-${r} distTo[${i}]= ${s.mDistTo[i]}distTo[${r}]= ${s.mDistTo[r]}`)}(t,e,this)}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new l;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t=_.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new k(t,0);for(let s,i=0;i<t.V();++i)if(e.hasPathTo(i)){s=`0 to ${i}(${e.distTo(i)}): `;for(let t,r=e.pathTo(i);r.hasNext();)t=r.next(),s+=0==t?`${t}`:`-${t}`;console.log(s)}else console.log(`0 to ${i} (-):  not connected\n`)}}class S{constructor(t,e,s){if(t<0)throw Error("vertex index must be a non-negative integer");if(e<0)throw Error("vertex index must be a non-negative integer");this.v=t,this.w=e,this._weight=s}weight(){return this._weight}either(){return this.v}other(t){if(t==this.v)return this.w;if(t==this.w)return this.v;throw Error("Illegal endpoint")}static comparator(t,e){return t._weight<e._weight?-1:t._weight>e._weight?1:0}toString(){return`${this.v}-${this.w} ${this._weight}`}static test(){console.log(new S(12,34,5.67).toString())}}class b{constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this._V=t,this._E=0,this.adjls=m.fill(t,(()=>new a))}static randGraph(t,e){let s=new b(t);if(e<0)throw Error("Number of edges must be non-negative");for(let i,r,o,n=0;n<e;++n)r=m.randInt(t),o=m.randInt(t),i=Math.round(100*m.rand())/100,s.addEdge(new S(r,o,i));return s}clone(){let t=new b(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){let e=t.either(),s=t.other(e);y(e,this._V),y(s,this._V),this.adjls[e].add(t),this.adjls[s].add(t),this._E+=1}adj(t){return y(t,this._V)&&this.adjls[t]}degree(t){return y(t,this._V)&&this.adjls[t].size()}edges(){const t=new a;for(let e,s,i,r=0;r<this._V;++r)for(s=0,e=this.adjls[r].iter();e.hasNext();)i=e.next(),i.other(r)>r?t.add(i):i.other(r)==r&&(s%2==0&&t.add(i),++s);return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()}, `;t+="\n"}return t}static load(t,e){let s=new b(t);m.assert(e.length%3==0,"Invalid data size");for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new S(e[i],e[i+1],e[i+2]));return s}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38 2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34 6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(" ").map((t=>+t)),e=b.load(8,t);console.log(e.toString())}}class M{constructor(t){this.bMarked=new Array(t.V()),this._id=new Array(t.V()),this._size=new Array(t.V()),this.nCount=0;for(let e=0;e<t.V();++e)this.bMarked[e]||(this._dfs(t,e),++this.nCount)}_dfs(t,e){this.bMarked[e]=!0,this._id[e]=this.nCount,this._size[this.nCount]+=1;for(let s,i,r=t.adj(e).iter();r.hasNext();)s=r.next(),t instanceof b?(i=s.other(e),this.bMarked[i]||this._dfs(t,i)):this.bMarked[s]||this._dfs(t,s)}id(t){return y(t,this.bMarked.length)&&this._id[t]}size(t){return y(t,this.bMarked.length)&&this._size[this._id[t]]}count(){return this.nCount}connected(t,e){return y(t,this.bMarked.length)&&y(e,this.bMarked.length)&&this.id(t)==this.id(e)}static test(){let t=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]),e=new M(t),s=e.count();console.log(s+" components");let i=m.fill(s,(()=>[]));for(let s=0;s<t.V();++s)i[e.id(s)].push(s);for(let t,e=0;e<s;++e)t="",i[e].forEach((e=>t+=e.toString()+" ")),console.log(t)}}class I{static load(t,e){if(t<0)throw Error("verts in a Digraph must be non-negative");m.assert(e.length%2==0,"expected even n# of data-length");let s=new I(t);for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}constructor(t){if(t<0)throw Error("verts in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=m.fill(t,0),this.adjls=m.fill(t,(()=>new a))}clone(){let t=this,e=new I(this.V());e._E=this.E(),e._indegree=m.fill(e.V(),(e=>t._indegree[e]));for(let t=0;t<e.V();++t)e.adjls[t]=this.adjls[t].clone();return e}V(){return this._V}E(){return this._E}addEdge(t,e){y(t,this._V)&&y(e,this._V),this.adjls[t].add(e),this._indegree[e]+=1,++this._E}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}reverse(){let t=new I(this._V);for(let e,s=0;s<this._V;++s)for(e=this.adjls[s].iter();e.hasNext();)t.addEdge(e.next(),s);return t}toString(){let t=`${this._V} vertices, ${this._E} edges\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()} `;t+="\n"}return t}static test(){let t=I.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s="";for(let i=0;i<t.V();++i)e+=`${i}=${t.indegree(i)}, `,s+=`${i}=${t.outdegree(i)},`;console.log("indegreee= "+e),console.log("outdegreee= "+s),console.log(t.toString());let i=t.clone();console.log("cloned=\n"+i.toString());let r=t.reverse();console.log("rev'ed=\n"+r.toString())}}class T{constructor(t,e){this.bMarked=new Array(t.V()),p.vec(e)||(e=[e]),x(e,t.V()),e.forEach((e=>{this.bMarked[e]||this._dfs(t,e)}))}_dfs(t,e){this.mCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.mCount}static test(){let t=I.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s=new T(t,[1,2,6]);for(let i=0;i<t.V();++i)s.marked(i)&&(e+=`${i} `);s.count(),console.log(e)}}class O{constructor(t){this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V()),this.mCycle=e;for(let e=0;e<t.V();++e)this.bMarked[e]||this.mCycle||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();){if(s=i.next(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new l;for(let t=e;t!=s;t=this.edgeTo[t])this.mCycle.push(t);this.mCycle.push(s),this.mCycle.push(e),this._check()}}else this.edgeTo[s]=e,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return!!this.mCycle}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=-1,e=-1;for(let s,i=this.cycle();i.hasNext();)s=i.next(),-1==t&&(t=s),e=s;if(t!=e)throw Error(`cycle begins with ${t} and ends with ${e}\n`)}return!0}static test(){let t="2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)),e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9\n               10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8\n               6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t));[new O(I.load(13,e)),new O(I.load(13,t))].forEach((t=>{t.hasCycle()?(console.log("Directed cycle: "),console.log(n(t.cycle()))):console.log("No directed cycle")}))}}class D{constructor(t,e,s){if(t<0)throw Error("Vertex names must be non-negative integers");if(e<0)throw Error("Vertex names must be non-negative integers");this.v=t,this.w=e,this._weight=s}from(){return this.v}to(){return this.w}weight(){return this._weight}toString(){return`${this.v}->${this.w} ${Number(this._weight).toFixed(2)}`}static test(){console.log(new D(12,34,5.67).toString())}}class A{constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=m.fill(t,(()=>new a))}static randGraph(t,e){if(e<0)throw Error("n# edges in a Digraph must be non-negative");let s=new A(t);for(let i=0;i<e;++i)s.addEdge(new D(m.randInt(t),m.randInt(t),.01*_randInt(100)));return s}static load(t,e){if(t<0)throw Error("n# vertices in a Digraph must be non-negative");m.assert(e.length%3==0,"bad data length");let s=new A(t);for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new D(e[i],e[i+1],e[i+2]));return s}clone(){let t=new A(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t._indegree[e]=this._indegree(e);for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){m.assert(t instanceof D,"Expected DirectedEdge");let e=t.to(),s=t.from();y(s,this._V),y(e,this._V),this.adjls[s].add(t),this._indegree[e]+=1,this._E++}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}edges(){const t=new a;for(let e=0;e<this._V;++e)for(let s=this.adj(e).iter();s.hasNext();)t.add(s.next());return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e=0;e<this._V;++e)t+=`${e}: `+n(this.adjls[e].iter())+"\n";return t}static test(){let t="4 5 0.35\n        5 4 0.35\n        4 7 0.37\n        5 7 0.28\n        7 5 0.28\n        5 1 0.32\n        0 4 0.38\n        0 2 0.26\n        7 3 0.39\n        1 3 0.29\n        2 7 0.34\n        6 2 0.40\n        3 6 0.52\n        6 0 0.58\n        6 4 0.93".split(/\s+/).map((t=>+t)),e=A.load(8,t);console.log(e.toString())}}class z{constructor(t){this._pre=new Array(t.V()),this._post=new Array(t.V()),this.preCounter=0,this.postCounter=0,this.postorder=new c,this.preorder=new c,this.bMarked=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.bMarked[e]=!0,this._pre[e]=this.preCounter++,this.preorder.enqueue(e);for(let s,i=t.adj(e).iter();i.hasNext();)s=t instanceof A?i.next().to():i.next(),this.bMarked[s]||this._dfs(t,s);this.postorder.enqueue(e),this._post[e]=this.postCounter++}pre(t){return y(t,this.bMarked.length)&&this._pre[t]}post(t){return y(t,this.bMarked.length)&&this._post[t]}postOrder(){return this.postorder.iter()}preOrder(){return this.preorder.iter()}reversePost(){let t=new l;for(let e=this.postorder.iter();e.hasNext();)t.push(e.next());return t.iter()}_check(){let t,e=0;for(t=this.postOrder();t.hasNext();){if(this.post(t.next())!=e)throw Error("post(v) and post() inconsistent");++e}for(e=0,t=this.preOrder();t.hasNext();){if(this.pre(t.next())!=e)throw Error("pre(v) and pre() inconsistent");++e}return!0}static test(){let t=I.load(13,"2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)));console.log(t.toString());let e=new z(t);console.log("   v  pre  post"),console.log("--------------");for(let s=0;s<t.V();++s)console.log(`    ${s}  ${e.pre(s)}  ${e.post(s)}\n`);console.log("Preorder:  "),console.log(n(e.preOrder())),console.log("Postorder:  "),console.log(n(e.postOrder())),console.log(""),console.log("Reverse postorder: "),console.log(n(e.reversePost()))}}class q{constructor(t){m.assert(t instanceof A,"Expected EdgeWeightedDigraph"),this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s=i.to(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new l;let t=i;for(;t.from()!=s;)this.mCycle.push(t),t=this.edgeTo[t.from()];return void this.mCycle.push(t)}}else this.edgeTo[s]=i,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return m.echt(this.mCycle)}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=e,s=e;for(let e,i=this.cycle();i.hasNext();){if(e=i.next(),t||(t=e),s&&s.to()!=e.from())throw Error(`cycle edges ${s} and ${e} not incident\n`);s=e}if(s.to()!=t.from())throw Error(`cycle edges ${s} and ${t} not incident\n`)}return!0}static test(){let t=13,e=new A(t);m.shuffle(m.fill(t,(t=>t)));for(let s,i,r,o=0;o<8;++o){do{i=m.randInt(t),r=m.randInt(t)}while(i>=r);s=m.rand(),e.addEdge(new D(i,r,s))}for(let s=0;s<6;++s)e.addEdge(new D(m.randInt(t),m.randInt(t),m.rand()));console.log(e.toString());let s=new q(e);s.hasCycle()?console.log("Cycle: "+n(s.cycle())):console.log("No directed cycle")}}class C{constructor(t){this.st=new d,t.forEach((t=>t.forEach(((t,e)=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this._graph=new _(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s,i=1;i<t.length;++i)s=this.st.get(t[i]),this._graph.addEdge(e,s)}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this._graph.V())&&this.keys[t]}graph(){return this._graph}static test(){let t="JFK MCO\n                  ORD DEN\n                  ORD HOU\n                  DFW PHX\n                  JFK ATL\n                  ORD DFW\n                  ORD PHX\n                  ATL HOU\n                  DEN PHX\n                  PHX LAX\n                  JFK ORD\n                  DEN LAS\n                  DFW HOU\n                  ORD ATL\n                  LAS LAX\n                  ATL MCO\n                  HOU MCO\n                  LAS PHX".split(/\s+/),e=new C(m.partition(2,t)),s=e.graph();["JFK","LAX"].forEach((t=>{if(e.contains(t)){let i=e.indexOf(t);console.log(t);for(let t=s.adj(i).iter();t.hasNext();)console.log("   "+e.nameOf(t.next()))}else console.log("input not contain '"+t+"'")}))}}class L{constructor(t){this.st=new d,t.forEach((t=>t.forEach((t=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this.graph=new I(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s=1;s<t.length;++s)this.graph.addEdge(e,this.st.get(t[s]))}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this.graph.V())&&this.keys[t]}digraph(){return this.graph}static test(){let t="JFK MCO\n              ORD DEN\n              ORD HOU\n              DFW PHX\n              JFK ATL\n              ORD DFW\n              ORD PHX\n              ATL HOU\n              DEN PHX\n              PHX LAX\n              JFK ORD\n              DEN LAS\n              DFW HOU\n              ORD ATL\n              LAS LAX\n              ATL MCO\n              HOU MCO\n              LAS PHX".split(/\s+/),e=new L(m.partition(2,t)),s=e.digraph();["JFK","ATL","LAX"].forEach((t=>{console.log(`${t}`);let i=s.adj(e.indexOf(t)).iter();for(;i.hasNext();)console.log("   "+e.nameOf(i.next()))}))}}class R{constructor(t){let s;if(this._order=e,this.rank=e,t instanceof A?s=new q(t):t instanceof I?(s=new O(t),s.hasCycle()||(this.rank=new Array(t.V()))):m.assert(!1,"bad arg for Topological"),s&&!s.hasCycle()){this._order=new c;for(let e,s=0,i=new z(t).reversePost();i.hasNext();)e=i.next(),this.rank&&(this.rank[e]=s++),this._order.enqueue(e)}}order(){return this._order.iter()}hasOrder(){return m.echt(this._order)}rank(t){return this.rank&&y(t,this.rank.length)&&this.hasOrder()?this.rank[t]:-1}static test(){let t=new L([["Algorithms","Theoretical CS","Databases","Scientific Computing"],["Introduction to CS","Advanced Programming","Algorithms"],["Advanced Programming","Scientific Computing"],["Scientific Computing","Computational Biology"],["Theoretical CS","Computational Biology","Artificial Intelligence"],["Linear Algebra","Theoretical CS"],["Calculus","Linear Algebra"],["Artificial Intelligence","Neural Networks","Robotics","Machine Learning"],["Machine Learning","Neural Networks"]]);for(let e=new R(t.digraph()).order();e.hasNext();)console.log(t.nameOf(e.next()))}}class P{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new l;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=I.load(13,e),i=new P(s,3);for(let e=0;e<s.V();++e)if(i.hasPathTo(e)){t=`3 to ${e}:  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`-${s}`;console.log(t)}else console.log(`3 to ${e}:  not connected`)}}class V{constructor(t,e){p.vec(e)||(e=[e]),this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.mDistTo[e]=1/0;x(e,t.V())&&this._bfs(t,e)}_bfs(t,e){let s=new c;for(e.forEach((t=>{this.bMarked[t]=!0,this.mDistTo[t]=0,s.enqueue(t)}));!s.isEmpty();){let e=s.dequeue();for(let i,r=t.adj(e).iter();r.hasNext();)i=r.next(),this.bMarked[i]||(this.edgeTo[i]=e,this.mDistTo[i]=this.mDistTo[e]+1,this.bMarked[i]=!0,s.enqueue(i))}}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new l;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=I.load(13,e),i=new V(s,3);for(let e=0;e<s.V();++e)if(t="",i.hasPathTo(e)){t=`3 to ${e} (${i.distTo(e)}):  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`->${s}`;console.log(t)}else console.log(`3 to ${e} (-):  not connected`)}}class ${constructor(t,e,s){m.assert(t instanceof A,"Expected EdgeWeightedDigraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw Error(`edge ${e} has negative weight`);this._distTo=new Array(t.V()),this.edgeTo=m.fill(t.V(),null),y(e,t.V());for(let e=0;e<t.V();++e)this._distTo[e]=1/0;for(this._distTo[e]=0,this.pq=new g(t.V(),s),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next())}this._check(t,e)}_relax(t){let e=t.from(),s=t.to();this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=new l;for(let s=this.edgeTo[t];s;s=this.edgeTo[s.from()])e.push(s);return e.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.to(),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],e=s.from(),i!=s.to())throw Error("bad edge");if(this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}else;return!0}static test(){let t="4 5 0.35\n                  5 4 0.35\n                  4 7 0.37\n                  5 7 0.28\n                  7 5 0.28\n                  5 1 0.32\n                  0 4 0.38\n                  0 2 0.26\n                  7 3 0.39\n                  1 3 0.29\n                  2 7 0.34\n                  6 2 0.40\n                  3 6 0.52\n                  6 0 0.58\n                  6 4 0.93".split(/\s+/).map((t=>+t)),e=A.load(8,t),s=new $(e,0,u);for(let t=0;t<e.V();++t)s.hasPathTo(t)?console.log(`0 to ${t} (${Number(s.distTo(t)).toFixed(2)})  ${n(s.pathTo(t))}`):console.log(`0 to ${t}         no path\n`)}}class j{constructor(t,e,s){m.assert(t instanceof b,"Expected EdgeWeightedGraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw new Error(`edge ${e} has negative weight`);for(this._distTo=m.fill(t.V(),(()=>1/0)),this._distTo[e]=0,this.compare=s,this.edgeTo=m.fill(t.V(),(()=>null)),y(e,t.V()),this.pq=new g(t.V(),this.compare),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next(),e)}this._check(t,e)}_relax(t,e){let s=t.other(e);this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=t,s=new l;for(let i=this.edgeTo[t];i;i=this.edgeTo[e])s.push(i),e=i.other(e);return s.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.other(e),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],i!=s.either()&&i!=s.other(s.either()))return!1;if(e=s.other(i),this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38\n                  2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34\n                  6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(/\s+/).map((t=>+t)),e=b.load(8,t),s=new j(e,6,u);for(let t,i=0;i<e.V();++i)if(s.hasPathTo(i)){t=`6 to ${i} (${Number(s.distTo(i)).toFixed(2)})  `;for(let e=s.pathTo(i);e.hasNext();)t+=`${e.next()}   `;console.log(t)}else console.log(`6 to ${i}         no path`)}}return{DepthFirstDirectedPaths:P,BreadthFirstDirectedPaths:V,SymbolGraph:C,DijkstraUndirectedSP:j,DijkstraSP:$,Topological:R,SymbolDigraph:L,EdgeWeightedDirectedCycle:q,DepthFirstOrder:z,EdgeWeightedDigraph:A,DirectedEdge:D,DirectedCycle:O,DirectedDFS:T,Digraph:I,CC:M,EdgeWeightedGraph:b,Edge:S,BreadthFirstPaths:k,DepthFirstPaths:v,NonrecursiveDFS:N,DepthFirstSearch:w,Graph:_}}"object"==typeof module&&module.exports?module.exports=s(require("@/czlab/mcfud"),require("./sort")):t["io/czlab/mcfud/algo/graph"]=s}(this),function(t){"use strict";function e(e){const s=e?e.Core:t["io/czlab/mcfud/core"](),i=e?e.Math:t["io/czlab/mcfud/math"](),{is:r,u:o}=s;function n(t,e,s){return e>t.length-1?t:`${t.substr(0,e)}${s}${t.substr(e+1)}`}function h(t,e){return+t.charAt(e)}class a{static DV={n:1,s:2,e:4,w:8};static DX={e:1,w:-1,n:0,s:0};static DY={e:0,w:0,n:-1,s:1};static OPPOSITE={e:"w",w:"e",n:"s",s:"n"};constructor(t,e){this.COLS=t,this.ROWS=e,this._getEntryNodes()}_getEntryNodes(){let t={},e=2*this.ROWS+1-2,s=2*this.COLS+1-2;t.start={x:1,y:1,gate:{x:0,y:1}},t.end={x:s,y:e,gate:{x:s+1,y:e}},this.entryNodes=t}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}generate(){this.grid=this._walk(0,0,o.fill(this.ROWS,(()=>o.fill(this.COLS,0))))}canSouth(t){return!!(t&a.DV.s)}canEast(t){return!!(t&a.DV.e)}toAscii(){let t=this.grid,e=t.length,s=[],i=t[0].length;for(let r,o=0;o<e;++o){r="|";for(let e=0;e<i;++e)r+=this.canSouth(t[o][e])?" ":"_",this.canEast(t[o][e])?r+=this.canSouth(t[o][e]|t[o][e+1])?" ":"_":r+="|";s.push(r)}return s.unshift("_".repeat(s[0].length)),s.join("\n")}_walk(t,e,s){let i,r;return o.shuffle(["n","s","e","w"]).forEach((o=>{i=t+a.DX[o],r=e+a.DY[o],r>=0&&r<s.length&&i>=0&&i<s[r].length&&0==s[r][i]&&(s[e][t]|=a.DV[o],s[r][i]|=a.DV[a.OPPOSITE[o]],this._walk(i,r,s))})),s}toGrid(){let t,e,s=this.grid,i=s.length,r=[],n=s[0].length;for(let o,h=0;h<i;++h){t=[],e=[],o=0,t[o]=1,e[o]=1;for(let i=0;i<n;++i)++o,this.canSouth(s[h][i])?(t[o]=0,e[o]=0):(t[o]=0,e[o]=1),++o,this.canEast(s[h][i])?(t[o]=0,e[o]=1):(t[o]=1,e[o]=1);r.push(t,e)}return r.unshift(o.fill(r[0].length,1)),r}}return{Maze1:class{constructor(t,e,s="D",i={}){let{bias:r,removeWalls:o,maxWallsRemove:n}=i;this.bias=r||"",this.removeWalls=o||0,this.maxWallsRemove=n||300,this.ROWS=t,this.COLS=e,this.matrix=[],this.entryNodes=this.getEntryNodes(s)}generate(){this.getMatrix(this.parseMaze(o.fill(this.COLS*this.ROWS,(()=>"01111")))),this.removeMazeWalls()}toAscii(){return""}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}toGrid(){let t,e=[];return this.matrix.forEach(((s,i)=>{t=[];for(let e=0;e<s.length;++e)t[e]="1"==s.charAt(e)?1:0;e.push(t)})),e}parseMaze(t){const e={n:1,s:2,w:3,e:4},s={n:2,s:1,w:4,e:3};let r,a,l,c=0,d=[],u=0,g=3,f=t.length-1,p=o.randInt(t.length);for(this.bias&&("H"==this.bias?g=this.COLS/100>=1?i.ndiv(this.COLS,100)+2:3:"V"==this.bias&&(g=this.ROWS/100>=1?i.ndiv(this.ROWS,100)+2:3)),t[p]=n(t[p],0,1);c<f;)if(++u,r=this.getNeighbours(p),l=Object.keys(r).filter((e=>-1!=r[e]&&!h(t[r[e]],0))),this.bias&&u!=g?l=this.biasDirections(l):u=0,l.length)++c,l.length>1&&d.push(p),a=l[o.randInt(l.length)],t[p]=n(t[p],e[a],0),p=r[a],t[p]=n(t[p],s[a],0),t[p]=n(t[p],0,1);else{if(0==d.length)break;p=d.pop()}return t}getMatrix(t){let e="",s="",i=this.COLS*this.ROWS;o.assert(t.length==i,"invalid nodes");for(let r=0;r<i;++r){if(e+=0==e.length?"1":"",s+=0==s.length?"1":"",h(t[r],1))e+="11",s+=h(t[r],4)?"01":"00";else{let i=t.hasOwnProperty(r-this.COLS)&&h(t[r-this.COLS],4),o=t.hasOwnProperty(r+1)&&h(t[r+1],1);h(t[r],4)?(e+="01",s+="01"):o||i?(e+="01",s+="00"):(e+="00",s+="00")}(r+1)%this.COLS==0&&(this.matrix.push(e,s),e="",s="")}this.matrix.push("1".repeat(2*this.COLS+1))}getEntryNodes(t){let e={},s=2*this.ROWS+1-2,i=2*this.COLS+1-2;if("D"==t&&(e.start={x:1,y:1,gate:{x:0,y:1}},e.end={x:i,y:s,gate:{x:i+1,y:s}}),"H"==t||"V"==t){let r="H"==t?s:i;r=(r-1)/2;let o=r%2==0;r=o?r+1:r;let n="H"==t?1:r,h="H"==t?r:1,a="H"==t?i:o?n:n+2,l="H"==t?o?h:h+2:s,c="H"==t?{x:0,y:h}:{x:n,y:0},d="H"==t?{x:i+1,y:l}:{x:a,y:s+1};e.start={x:n,y:h,gate:c},e.end={x:a,y:l,gate:d}}return e}biasDirections(t){let e=-1!=t.indexOf("w")||-1!=t.indexOf("e"),s=-1!=t.indexOf("n")||-1!=t.indexOf("s");return"H"==this.bias&&e?t.filter((t=>"w"==t||"e"==t)):"V"==this.bias&&s?t.filter((t=>"n"==t||"s"==t)):t}getNeighbours(t){return{w:t>0&&t%this.COLS!=0?t-1:-1,e:(t+1)%this.COLS!=0?t+1:-1,n:t-this.COLS>=0?t-this.COLS:-1,s:this.COLS*this.ROWS>t+this.COLS?t+this.COLS:-1}}removeWall(t,e){const s=t%2==0,i=e%2==0;if(!h(this.matrix[t],e))return!1;if(!s&&i){const s=t-2>0&&1==h(this.matrix[t-2],e),i=t+2<this.matrix.length&&1==h(this.matrix[t+2],e);if(s&&i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==h(this.matrix[t-1],e-1),i=1==h(this.matrix[t-1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==h(this.matrix[t+1],e-1),i=1==h(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}}else if(s&&!i){const s=1==h(this.matrix[t],e-2),i=1==h(this.matrix[t],e+2);if(s&&i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==h(this.matrix[t-1],e-1),i=1==h(this.matrix[t+1],e-1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==h(this.matrix[t-1],e+1),i=1==h(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=n(this.matrix[t],e,"0"),!0}}}removeMazeWalls(){if(0==this.removeWalls||0==this.matrix.length)return;let t,e,s=0,i=this.matrix.length-1,r=this.maxWallsRemove;for(;s<r&&(++s,!(this.wallsRemoved>=this.removeWalls));){let s=o.randInt2(1,i);s=s==i?s-1:s,e=[],t=this.matrix[s];for(let s=0;s<t.length;s++)0!=s&&s!=t.length-1&&h(t,s)&&e.push(s);o.shuffle(e);for(let t=0;t<e.length;t++)if(this.removeWall(s,e[t])){++this.wallsRemoved;break}}}},Maze2:a}}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/maze"]=e}(this),function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:i}=s;class r{constructor(t,s){this.state=e,this.other=s,this.cur=t}clone(t){const e=new r;return e.state=t(this.state),e.other=this.other,e.cur=this.cur,e}}const o=(t,e,s,i)=>t.evalScore(e,s,i);function n(t,s,r,h,a,l,c){if(0==r||t.isOver(s))return[o(t,s,r,h),e];let d=s,u=t.getStateCopier(),g=i.shuffle(t.getNextMoves(s));if(c){let e,o,f=g[0],p=-1/0;for(let m=0;m<g.length&&(t.undoMove||(i.assert(u,"Missing state copier!"),s=d.clone(u)),o=g[m],t.makeMove(s,o),e=n(t,s,r-1,h,a,l,!c)[0],t.undoMove&&t.unmakeMove(s,o),e>p&&(p=e,f=o),!(l<=(a=Math.max(e,a))));++m);return[p,f]}{let e,o,f=g[0],p=1/0;for(let m=0;m<g.length&&(t.undoMove||(i.assert(u,"Missing state copier!"),s=d.clone(u)),o=g[m],t.makeMove(s,o),e=n(t,s,r-1,h,a,l,!c)[0],t.undoMove&&t.unmakeMove(s,o),e<p&&(p=e,f=o),!((l=Math.min(e,l))<=a));++m);return[p,f]}}const h={algo:"minimax",GFrame:r,GameBoard:class{constructor(){this.aiActor=e}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t,e,s){}isStalemate(t){}isOver(t,e){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}takeGFrame(){}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=h.evalMiniMax(this)),s}},evalMiniMax(t){const e=t.takeGFrame(),s=t.depth;let[r,o]=n(t,e,s,s,-1/0,1/0,!0);return i.nichts(o)&&console.log(`evalMiniMax: score=${r}, pos= ${o}`),o}};return h}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud").Core):t["io/czlab/mcfud/algo/minimax"]=s}(this),function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:i}=s;class r{constructor(t,s){this.lastBestMove=e,this.state=e,this.other=s,this.cur=t}clone(t){const e=new r;return e.state=t(this.state),e.lastBestMove=this.lastBestMove,e.other=this.other,e.cur=this.cur,e}}function o(t,e,s,i){return t.evalScore(e,s,i)*(1+.001*s)}function n(t,e,s,r,h,a){if(0==s||t.isOver(e))return{depth:s,value:o(t,e,s,r)};let l=e,c=t.getStateCopier(),d=i.shuffle(t.getNextMoves(e));for(let o,u,g=0;g<d.length;++g)if(u=d[g],t.undoMove||(i.assert(c,"Missing state copier!"),e=l.clone(c)),t.makeMove(e,u),o=n(t,e,s-1,r,{value:-a.value,move:a.move},{value:-h.value,move:h.move}),t.undoMove&&t.unmakeMove(e,u),o.value=-o.value,o.move=u,o.value>h.value&&(h={value:o.value,move:u,depth:o.depth}),h.value>=a.value)return a;return JSON.parse(JSON.stringify(h))}function h(t,e,s,r,n,a){if(0==s||t.isOver(e))return[o(t,e,s,r),null];let l=i.shuffle(t.getNextMoves(e)),c=t.getStateCopier(),d=e,u=-1/0,g=l[0];s==r&&(d.lastBestMove=g);for(let o,f,p=0;p<l.length&&(t.undoMove||(i.assert(c,"Missing state copier!"),e=d.clone(c)),f=l[p],t.makeMove(e,f),o=-h(t,e,s-1,r,-a,-n)[0],t.undoMove&&t.unmakeMove(e,f),u<o&&(u=o,g=f),!(n<o&&(n=o,s==r&&(d.lastBestMove=f),n>=a)));++p);return[u,d.lastBestMove]}const a={algo:"negamax",GFrame:r,GameBoard:class{constructor(){}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t){}isStalemate(t){}isOver(t){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}takeGFrame(){}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=a.evalNegaMax(this)),s}},XXevalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let[r,o]=h(t,e,s,s,-1/0,1/0);return i.nichts(o)&&console.log(`evalNegaMax: score=${r}, pos= ${o}, lastBestMove=${o}`),o},evalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let{value:r,move:o}=n(t,e,s,s,{value:-1/0},{value:1/0});return i.nichts(o)&&console.log(`evalNegaMax: score= ${r}, pos= ${o}`),o}};return a}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud").Core):t["io/czlab/mcfud/algo/negamax"]=s}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());Math.floor;const{u:s,is:i}=e;function r(t){return 1/(1+Math.exp(-t))}const o={mutationRate:.1,crossOverRate:.7,probTournament:.75,NUM_HIDDEN:1,BIAS:-1,NUM_ELITES:4,TOURNAMENT_SIZE:5,MAX_PERTURBATION:.3,ACTIVATION_RESPONSE:1,NEURONS_PER_HIDDEN:10,sigmoid:r,relu:t=>Math.max(0,t),XXtanh(t){let e=Math.exp(t),s=Math.exp(-t);return(e-s)/(e+s)},tanh:t=>2*r(2*t)-1,softmax(t){let e,s=[],i=-1/0;return t.forEach((t=>t>i?i=t:0)),e=t.reduce(((t,e)=>(s.push(Math.exp(e-i)),t+s.at(-1))),0),s.map((t=>t/e))},XXsoftmax(t){s.assert(i.vec(t),"Expected array param as softmax input.");let e=t.map((t=>Math.exp(t))),r=e.reduce(((t,e)=>t+e),0);return e.map((t=>t/r))},softplus:t=>Math.log(1+Math.exp(t))};class n{#t;#e;#s;#i;#r;get avgScore(){return this.#t}set avgScore(t){this.#t=t}get totalScore(){return this.#e}set totalScore(t){this.#e=t}get bestScore(){return this.#s}set bestScore(t){this.#s=t}get worstScore(){return this.#i}set worstScore(t){this.#i=t}get alpha(){return this.#r}set alpha(t){this.#r=t}constructor(){this.#t=0,this.#e=0,this.#s=0,this.#i=0,this.#r=undefined}}class h{#o;#n;#h;#a;get age(){return this.#a}set age(t){this.#a=t}constructor(t,e,s){this.#o=s,this.#n=e,this.#h=t,this.#a=0}getScoreCalcInfo(){return[this.#n,this.#o]}_genes(){return this.#h}getGeneAt(t){return this.#h[t]}compatible(t){return this.size()==t.size()}size(){return this.#h.length}copyGenes(){let t,e=this.#h[0];try{t=i.obj(e)&&i.fun(e.clone)}catch(t){}return t?this.#h.map((t=>t.clone())):this.#h.slice()}getScore(){s.assert(!1,"Please implement getScore()")}cmpScore(t){s.assert(!1,"Please implement cmpScore()")}updateScore(t){s.assert(!1,"Please implement updateScore()")}recalcScore(){this.updateScore(this.#n(this.#h,this.#o))}compareTo(t){s.assert(!1,"Please implement compareTo()")}mutateWith(t,e){return e?t.call(e,this.#h):t(this.#h),this.recalcScore(),this}mutateSM(){if(s.rand()<o.mutationRate){let[t,e]=s.randSpan(this.#h),i=t+1,r=e-t-1;if(2==r)s.swap(this.#h,i,t+2);else if(r>2)for(let t=s.shuffle(this.#h.slice(i,e)),r=0,o=i;o<e;++o)this.#h[o]=t[r++];this.recalcScore()}}mutateDM(){if(s.rand()<o.mutationRate){let t,e,i,[r,o]=s.randSpan(this.#h),n=r+1,h=this.#h.length;o-r-1>0&&(e=this.#h.slice(n,o),i=this.#h.slice(0,n).concat(this.#h.slice(o)),t=s.randInt(i.length),e=i.slice(0,t).concat(e).concat(i.slice(t)),s.append(this.#h,e,!0),s.assert(this.#h.length==h,"mutateDM error")),this.recalcScore()}}mutateIM(){if(s.rand()<o.mutationRate){let t,e,i=s.randInt(this.#h.length),r=this.#h.length,o=this.#h[i];this.#h.splice(i,1),i=s.randInt(this.#h.length),t=this.#h.slice(0,i),e=this.#h.slice(i),s.append(this.#h,t,!0),this.#h.push(o),s.append(this.#h,e),s.assert(r==this.#h.length,"mutateIM error"),this.recalcScore()}}mutateIVM(){if(s.rand()<o.mutationRate){let t,[e,i]=s.randSpan(this.#h),r=e+1,o=this.#h.length;if(i-e-1>1){t=this.#h.slice(r,i).reverse();for(let e=0,s=r;s<i;++s)this.#h[s]=t[e++]}s.assert(o==this.#h.length,"mutateIVM error"),this.recalcScore()}}mutateDIVM(){if(s.rand()<o.mutationRate){let t,e,i,[r,o]=s.randSpan(this.#h),n=this.#h.length,h=r+1;o-r-1>0&&(e=this.#h.slice(h,o).reverse(),i=this.#h.slice(0,h).concat(this.#h.slice(o)),t=s.randInt(i.length),e=i.slice(0,t).concat(e).concat(i.slice(t)),s.append(this.#h,e,!0),s.assert(this.#h.length==n,"mutateDIVM error")),this.recalcScore()}}iterGenes(t,e){return this.#h.forEach(t,e),this}applyGenes(t,e){return e?t.call(e,this.#h):t(this.#h)}clone(){s.assert(!1,"Please implement clone()")}static crossOverOBX(t,e){let i=t.copyGenes(),r=e.copyGenes();if(s.rand()<o.crossOverRate&&t!==e){s.assert(t.compatible(e),"Chromosomes are not compatible.");let o=t.size(),n=s.toGoldenRatio(o)[1],h=s.shuffle(s.fill(o,(t=>t))).slice(0,n).sort(),a=h.map((e=>t.getGeneAt(e)));for(let t=0,e=0;e<r.length;++e)t>=a.length&&(t=0),a.find((s=>{if(r[e]==s)return r[e]=a[t++],!0}));a=h.map((t=>e.getGeneAt(t)));for(let t=0,e=0;e<i.length;++e)t>=a.length&&(t=0),a.find((s=>{if(i[e]==s)return i[e]=a[t++],!0}))}return[i,r]}static crossOverPBX(t,e){let i,r,n;return s.rand()>o.crossOverRate||t===e?(i=t.copyGenes(),r=e.copyGenes()):(s.assert(t.compatible(e),"Mismatched size of chromosomes."),n=t.size(),i=s.fill(n,null),r=s.fill(n,null),s.shuffle(s.fill(n,(t=>t))).slice(0,s.toGoldenRatio(n)[1]).sort().forEach((s=>{i[s]=t.getGeneAt(s),r[s]=e.getGeneAt(s)})),r.forEach(((s,i)=>{if(null===s){t.applyGenes((t=>t.findIndex((t=>{if(r.indexOf(t)<0)return r[i]=t,!0}))))<0&&(r[i]=e.getGeneAt(i))}})),i.forEach(((s,r)=>{if(null===s){e.applyGenes((t=>t.findIndex((t=>{if(i.indexOf(t)<0)return i[r]=t,!0}))))<0&&(i[r]=t.getGeneAt(r))}})),s.assert(!i.some((t=>null===t)),"crossOverPBX null error"),s.assert(!r.some((t=>null===t)),"crossOverPBX null error")),[i,r]}static crossOverRND(t,e){s.assert(t.compatible(e),"Mismatched chromosome sizes");let i,r,n,h=t.size();if(s.rand()>o.crossOverRate||t===e)r=t.copyGenes(),n=e.copyGenes();else{i=s.randInt(h),r=[],n=[];for(let s=0;s<i;++s)r.push(t.getGeneAt(s)),n.push(e.getGeneAt(s));for(let s=i;s<h;++s)r.push(e.getGeneAt(s)),n.push(t.getGeneAt(s))}return[r,n]}static crossOverPMX(t,e){s.assert(t.compatible(e),"Mismatched chromosome sizes");t.size();let i=t.copyGenes(),r=e.copyGenes();if(s.rand()>o.crossOverRate||t===e);else{let[o,n]=s.randSpan(t.size());for(let h,a,l,c,d=o;d<n+1;++d)l=t.getGeneAt(d),c=e.getGeneAt(d),l!=c&&(h=i.indexOf(l),a=i.indexOf(c),h>=0&&a>=0&&s.swap(i,h,a),h=r.indexOf(l),a=r.indexOf(c),h>=0&&a>=0&&s.swap(r,h,a))}return[i,r]}static crossOverAtSplits(t,e){s.assert(t.compatible(e),"Mismatched chromosome sizes");let i,r,n=t.size();if(s.rand()>o.crossOverRate||t===e)i=t.copyGenes(),r=e.copyGenes();else{let[o,h]=s.randSpan(t.size());i=[],r=[];for(let s=0;s<n;++s)s<o||s>=h?(i.push(t.getGeneAt(s)),r.push(e.getGeneAt(s))):(i.push(e.getGeneAt(s)),r.push(t.getGeneAt(s)))}return[i,r]}}class a extends h{#l;constructor(t,e,s){super(t,e,s),this.recalcScore()}getScore(){return this.#l}updateScore(t){return this.#l=t,this}cmpScore(t){return this.#l>t?1:this.#l<t?-1:0}clone(){let[t,e]=this.getScoreCalcInfo();return new a(this.copyGenes(),t,e)}compareTo(t){return this.cmpScore(t.getScore())}}function l(t,e="cycles"){let i=t.startTime=s.now();return t[e]=0,i}function c(t){return t.endTime=s.now()}function d(t,e){let s,i=0;for(;i<t.length&&(s=t[i],!(s.getScore()==e.getScore()||e.getScore()<s.getScore()));++i);return i}function u(t,e,i,r,o){let n,h=5;for(;h--&&(n=s.randInt(e.length),n==t););let a,l,c=e[t],d=e[n];return r?[a,l]=r(c,d):(a=c.copyGenes(),l=d.copyGenes()),a=i(a),l=i(l),o&&(a.mutateWith(o),a.mutateWith(o)),a.compareTo(l)>=0?a:l}function g(t,{crossOver:e,create:r,mutate:n,cycles:h}){if(i.num(t))return s.fill(t,(()=>r()));t.sort(s.comparator(s.SORT_ASC,(t=>t.getScore()),(t=>t.getScore())));let a,l,c,d,u=t.slice(t.length-o.NUM_ELITES),g=f.calcStats(t);for(;u.length<t.length;)s.randSign()>0&&void 0!==o.TOURNAMENT_SIZE?(c=f.tournamentSelection(t,o.TOURNAMENT_SIZE),d=f.tournamentSelection(t,o.TOURNAMENT_SIZE)):(c=f.chromoRoulette(t,g.totalScore),d=f.chromoRoulette(t,g.totalScore)),e?[a,l]=e(c,d):(a=c.copyGenes(),l=d.copyGenes()),a=r(a),l=r(l),n&&(a.mutateWith(n),l.mutateWith(n)),u.push(a,l);for(;u.length>t.length;)u.pop();return u}const f={ChromoNumero:a,Chromosome:h,ChromoGA:class{#c;#d;#u;#g;constructor(t,{create:e,mutate:s,crossOver:i}){this.#d={create:e,mutate:s,crossOver:i},this.#c=1,this.#u=t,this.#g=g(t,this.#d)}curGen(){return this.#c}epoch(t){s.assert(t.length==this.#g.length,"GA::Epoch(scores/ chromosomes mismatch)!"),this.#g.forEach(((e,s)=>e.updateScore(t[s]))),this.#g=g(this.#g,this.#d),this.#c+=1}createPhenotypes(){return this.#g}},runGASearch(t,e){let i,r,o=l(e),n=e.maxCycles||100,h=1e3*(e.maxSeconds||30),a=function*([t,e],{mutate:i,create:r,maxAge:o,poolSize:n,crossOver:h}){let a,l=r();yield l;let c,g,f,p,m,y=[l],_=[l];n=n||1,o=o||50;for(let t=0;t<n-1;++t)a=r(),a.compareTo(l)>0&&(yield l=a,_.push(a)),y.push(a);for(m=n-1,p=1;;)if(s.now()-t>e&&(yield l),p=p>0?p-1:m,a=y[p],g=u(p,y,r,h,i),a.compareTo(g)>0){if(void 0===o)continue;if(a.age+=1,o>a.age)continue;if(f=d(_,g,_.length),c=f/_.length,s.rand()<Math.exp(-c)){y[p]=g;continue}l.age=0,y[p]=l}else g.compareTo(a)>0?(g.age=0,y[p]=g,g.compareTo(l)>0&&(yield l=g,_.push(l))):(g.age=a.age+1,y[p]=g)}([o,h],e);for(;;){if(i=a.next().value,r=c(e),r-o>h){r=null;break}if(i.cmpScore(t)>=0)break;if(e.cycles>=n)break;e.cycles+=1}return[null===r,i]},runGACycle(t,e){let i,r,{maxCycles:o,targetScore:n,maxSeconds:h}=e,a=l(e),d=1e3*(h||30);for(o=o||100;;){if(t=g(t,e),r=c(e),r-a>d){r=null;break}if(i=f.calcStats(t),s.echt(n)&&i.bestScore>=n)break;if(e.cycles>=o)break;e.cycles+=1}return[null===r,t]},hillClimb(t,e,i,r,o,n){let h,a,d=l(n),u=1e3*(n.maxSeconds||30),g=t(o,n);for(;!i(g);)if(a=t(r(g),n),e(g,a)&&(g=a),s.now()-d>u){h=!0;break}return c(n),[h,g]},getChromoRoulette(t,e){let i=0,r=s.rand()*e;return t.find((t=>(i+=t.getScore(),i>=r)))},chromoRoulette(t,e){let i=0,r=s.rand(),o=t.map((t=>i+=t.getScore()/e));for(let e=0;e<o.length-1;++e)if(r>=o[e]&&r<=o[e+1])return t[e];return t[0]},tournamentSelectionN(t,e){let i=0,r=-1/0;for(let o,n,h=0;h<e;++h)o=s.randInt(t.length),n=t[o].getScore(),n>r&&(i=o,r=n);return t[i]},tournamentSelection(t){let[e,i]=s.randSpan(t);return s.rand()<o.probTournament?t[e].getScore()>t[i].getScore()?t[e]:t[i]:t[e].getScore()<t[i].getScore()?t[e]:t[i]},calcStats(t){let e=-1/0,s=1/0,i=new n;return t.forEach((t=>{t.getScore()>e?(e=t.getScore(),i.bestScore=e,i.alpha=t):t.getScore()<s&&(s=t.getScore(),i.worstScore=s),i.totalScore+=t.getScore()})),i.avgScore=i.totalScore/t.length,i},fitnessScaleRank:t=>(t.sort(s.comparator(s.SORT_ASC,(t=>t.getScore()),(t=>t.getScore()))),t.forEach(((t,e)=>t.updateScore(e))),f.calcStats(t)),fitnessScaleSigma(t,e){let s=t.reduce(((t,s)=>t+Math.pow(s.getScore()-e.avgScore,2)),0)/t.length,i=Math.sqrt(s),r=2*i;return t.forEach((t=>t.updateScore((t.getScore()-e.avgScore)/r))),[i,f.calcStats(t)]},fitnessScaleBoltzmann(t,e){(e-=Parmas.BOLTZMANN_DT)<Parmas.MIN_TEMP&&(e=Parmas.MIN_TEMP);let s=[],i=t.reduce(((t,i,r)=>(r=Math.exp(i.getScore()/e),s.push(r),t+r)),0)/t.length;return t.forEach(((t,e)=>t.updateScore(s[e]/i))),[e,calcStats(t)]},showBest(t,e,i){console.log(s.fill(80,"-").join("")),console.log("total time: "+s.prettyMillis(e.endTime-e.startTime)),i&&console.log("time expired"),console.log("total generations= "+e.cycles),console.log("fitness score= "+t.getScore()),console.log("best="+t.applyGenes((t=>t.join(",")))),console.log(s.fill(80,"-").join(""))},config:t=>s.inject(o,t)};return f}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud").Core):t["io/czlab/mcfud/algo/ChromoGA"]=e}(this),function(t){"use strict";function e(e){const s=e?e.Core:t["io/czlab/mcfud/core"](),{u:i,is:r}=(e?e.Math:t["io/czlab/mcfud/math"](),Math.floor,s),o={BIAS:1,actFunc:"sigmoid"},n={INPUT:1,BIAS:2,OUTPUT:3,HIDDEN:4,NONE:911,toStr(t){switch(t){case n.OUTPUT:return"output";case n.INPUT:return"input";case n.BIAS:return"bias";case n.HIDDEN:return"hidden"}return"none"}},h=["sigmoid","tanh","linear","relu","leaky_relu","step","swish","softmax","softplus"],a={sigmoid:function(t){return 1/(1+Math.exp(-t))},tanh:function(t){return Math.tanh(t)},linear:function(t){return t},relu:function(t){return Math.max(0,t)},leaky_relu:function(t,e=.01){return t>0?t:e*t},step:function(t){return t>=0?1:0},swish:function(t){return t*h.SIGMOID(t)},softmax:function(t){let e,s=[],i=-1/0;return t.forEach((t=>t>i?i=t:0)),e=t.reduce(((t,e)=>(s.push(Math.exp(e-i)),t+s.at(-1))),0),s.map((t=>t/e))},softplus:function(t){return Math.log(1+Math.exp(t))}};function l(t){return t.type==n.OUTPUT}class c{#f;#p;get x(){return this.#f}get y(){return this.#p}constructor(t=0,e=0){this.#f=t,this.#p=e}clone(){return new c(this.#f,this.#p)}toJSON(){return{x:this.#f,y:this.#p}}static dft(){return new c(0,0)}static fromJSON(t){return new c(t.x,t.y)}}class d{#m;#y;#_;get fromNode(){return this.#m}get toNode(){return this.#y}get weight(){return this.#_}set weight(t){this.#_=t}constructor(t,e,s){this.#m=e,this.#y=s,this.#_=t}clone(){return new d(this.weight,this.fromNode,this.toNode)}toJSON(){return{fromNode:this.#m.id,toNode:this.#y.id,weight:this.#_}}static add(t,e){return new d(i.randMinus1To1(),t,e)}static fromJSON(t,e){return new d(t.weight,e(t.fromNode),e(t.toNode))}}class u{#w;#N;#v;#E;#x;#k;#S;#b;#M;#I;#T;get outputValue(){return this.#x}get inputSum(){return this.#v}get type(){return this.#b}get id(){return this.#T}getBias(){return this.#M}get actFunc(){return this.#E}get posY(){return this.#I.y}get posX(){return this.#I.x}get pos(){return this.#I}get layer(){return this.#k}get errorValue(){return this.#S}set outputValue(t){this.#x=t}setBias(t){return this.#M=t,this}constructor(t,e,s,r=null){this.#I=r?r.clone():c.dft(),this.#M=i.randMinus1To1(),this.#E="sigmoid",this.#k=s,this.#b=e,this.#S=0,this.#T=t,this.#x=0,this.#v=0,this.#w=[],this.#N=[]}resetErrorValue(t){return this.#S=t,this}toJSON(){return{pos:{x:this.#I.x,y:this.#I.y},bias:this.#M,type:this.#b,id:this.#T,layer:this.#k,output:this.#x,inputSum:this.#v,actFunc:this.#E,vecLinksOut:this.#w.map((t=>t.toJSON()))}}flush(){return i.trunc(this.#w),this.#v=0,this.#x=0,this}resetInput(t=0){return this.#v=t,this}addInput(t){return this.#v+=t,this}addOutLink(t){return this.#w.push(t),this}addInLink(t){return this.#N.push(t),this}activate(t){return this.#b!=n.INPUT&&(t=t||this.#E||o.actFunc,r.str(t)&&(t=a[t]),i.assert(r.fun(t),"activation function not found"),this.#x=t(this.#v+this.#M)),this.#w.forEach((t=>t.toNode.addInput(t.weight*this.#x))),this}iterInLinks(t,e){return this.#N.forEach(t,e),this}iterOutLinks(t,e){return this.#w.forEach(t,e),this}findLinkIn(t){return this.#N.find((e=>e.fromNode.id==t.id))}setActFunc(t){return this.#E=t,this}_cpy(t,e,s,i){return this.#w=i.map((t=>t.clone())),this.#N=s.map((t=>t.clone())),this.#M=e,this.#E=t,this}clone(){return new u(this.id,this.type,this.pos)._cpy(this.#E,this.#M,this.#N,this.#w)}static fromJSON(t){let e=new u(t.id,t.type,t.layer,c.fromJSON(t.pos));return e.setActFunc(t.actFunc),e.outputValue=t.output??0,e.resetInput(t.inputSum||0),e.bias=t.bias??i.randMinus1To1(),e}}class g{#O;#D;#A;#z;#q;get cycle(){return this.#z}get status(){return this.#q}get errorSum(){return this.#A}get learnRate(){return this.#D}get tolerance(){return this.#O}constructor(t,e){this.#O=e??0,this.#D=t??0,this.#q=!1,this.#A=0,this.#z=0}setStatus(t){return this.#q=t,this}setErrorSum(t){return this.#A=t,this}addErrorSum(t){return this.#A+=t,this}addCycle(){return this.#z+=1,this}resetCycle(){return this.#z=0,this}toJSON(){return{tolerance:this.#O,errorSum:this.#A,status:this.#q,cycle:this.#z,learnRate:this.#D}}static fromJSON(t){return new g(t.learnRate,t.tolerance).setErrorSum(t.errorSum).setStatus(t.status).setCycle(t.cycle)}}class f{#C;#L;#R;#P;get errorSum(){return this.#L.errorSum}get trainCycle(){return this.#L.cycle}get trained(){return this.#L.status}get trainer(){return this.#L}get numOutputs(){return this.#P}get numInputs(){return this.#R}constructor(t,e,s){let r,o=0,h=2,a=1/(t+2),l=1/(e+1);if(s=s||{},this.#L=new g,this.#P=e,this.#R=t,this.#C=[],"json"!==s){s.layers&&(h+=s.layers.length);for(let e=0;e<t;++e)r=new u(++o,n.INPUT,0,new c((e+2)*a,0)),this.#C.push(r);for(let t=0;t<e;++t)r=new u(++o,n.OUTPUT,h-1,new c((t+1)*l,1)),this.#C.push(r.setActFunc(s.actOut));if(s.layers){let t=0,e=1/(s.layers.length+1);s.layers.forEach(((s,i)=>{a=1/(s.size+2),t+=e;for(let e=0;e<s.size;++e)r=new u(++o,n.HIDDEN,i+1,new c((e+2)*a,t)),this.#C.push(r.setActFunc(s.actFunc))}))}this.#C.sort(i.comparator(i.SORT_ASC,(t=>t.posY),(t=>t.posY)));for(let t,e,s=0;s<=h-2;++s)t=this.#C.filter((t=>t.layer==s)),e=this.#C.filter((t=>t.layer==s+1)),t.forEach((t=>e.forEach((e=>{let s=d.add(t,e);t.addOutLink(s),e.addInLink(s)}))));console.log("Debug NeuralNet..."),this.#C.forEach((t=>console.log(t.toJSON())))}}countLayers(){return this.#C.find((t=>l(t))).layer+1}iterOutputLayer(t,e){return this.#C.filter((t=>l(t))).forEach(t,e),this}iterInputLayer(t,e){return this.#C.filter((t=>function(t){return t.type==n.INPUT}(t))).forEach(t,e),this}iterNodes(t,e){return this.#C.forEach(t,e),this}iterLayer(t,e,s){return this.#C.filter((e=>e.layer==t)).forEach(e,s),this}resetTraining(t,e,s){return this.#L=new g(t,s),this.#L.setErrorSum(e),this.#C.forEach((t=>{t.iterOutLinks((t=>t.weight=i.randMinus1To1()))})),this}trainedOneCycle(){return this.#L.addCycle(),this}addError(t){return this.#L.addErrorSum(t),this}resetErrorSum(t=0){return this.#L.setErrorSum(t),this}checkTraining(){let t=!(this.#L.errorSum>this.#L.tolerance);return t&&this.#L.setStatus(!0),t}clone(){return f.fromJSON(this.toJSON())}compute(t){return this.update(t)}update(t){i.assert(t.length==this.#R,`update: expecting ${this.#R} inputs but got ${t.length}`),this.#C.forEach(((e,s)=>e.type==n.INPUT?e.outputValue=t[s]:0)),this.#C.forEach((t=>t.activate()));let e=this.#C.reduce(((t,e)=>(e.type==n.OUTPUT&&t.push(e.outputValue),t)),[]);return this.#C.forEach((t=>t.resetInput(0))),e}_injectFromJSON(t){return i.append(this.#C,t,!0),this}_injectTrainer(t){return this.#L=new g(t.learnRate,t.tolerance),this}toJSON(){let t,e=[],s={trainer:this.#L.toJSON(),outputs:this.#P,inputs:this.#R,nodes:this.#C.map((s=>(t=s.toJSON(),t.vecLinksOut.forEach((t=>e.push(t))),delete t.vecLinksOut,t))),links:[]};return i.append(s.links,e,!0),s}static fromJSON(t){let e,s=new f(t.inputs,t.outputs,"json"),r=[],o=new Map;function n(t){return o.get(t)}return t.nodes.forEach((t=>{e=u.fromJSON(t),o.set(e.id,e),r.push(e)})),s._injectFromJSON(r.sort(i.comparator(i.SORT_ASC,(t=>t.posY),(t=>t.posY)))),s._injectTrainer(t.trainer),t.links.forEach(((t,e)=>{n(t.fromNode).addOutLink(e=d.fromJSON(t,n)),n(t.toNode).addInLink(e)})),s}static trainOneCycle(t,e,s){let i,r,n=t.trainer.learnRate;t.resetErrorSum();for(let h=0;h<e.length;++h){if(r=t.update(e[h]),0==r.length)return!1;t.iterOutputLayer(((e,a)=>{i=(s[h][a]-r[a])*r[a]*(1-r[a]),e.resetErrorValue(i),e.setBias(e.getBias()+i*n*o.BIAS),e.iterInLinks((t=>{t.weight+=i*n*t.fromNode.outputValue})),t.addError((s[h][a]-r[a])*(s[h][a]-r[a]))}));for(let s=t.countLayers()-2;s>0;--s)t.iterLayer(s,((r,a)=>{i=0,t.iterLayer(2,((t,e)=>{i+=t.errorValue*t.findLinkIn(r).weight})),i*=r.outputValue*(1-r.outputValue),t.iterLayer(s-1,((t,s)=>{let o=r.findLinkIn(t);o.weight=o.weight+i*n*e[h][s]})),r.setBias(r.getBias()+i*o.BIAS)}))}return t.trainedOneCycle()}}return{NeuralNet:f,Node:u,Link:d,NodeType:n,FuncType:h,FuncTypeDB:a,configParams:t=>i.inject(o,t)}}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/NNet"]=e}(this),function(t){"use strict";function e(e){const s=e?e.Core:t["io/czlab/mcfud/core"](),{u:i,is:r}=(e?e.Math:t["io/czlab/mcfud/math"](),Math.floor,s),o={ALPHA:.1,GAMMA:.95,MAX_EPSILON:1,DECAY_RATE:.001,MIN_EPSILON:.05,MAX_STEPS:250,EPISODES:1e3,SECS_PER_EPISODE:30};return{Environment:class{#V;constructor(t){this.#V=Object.freeze(i.inject({},o,t))}getVars(){return this.#V}reset(){i.assert(!1,"Please implement reset()")}actionSpace(){i.assert(!1,"Please implement actionSpace()")}getState(){i.assert(!1,"Please implement getState()")}step(t){i.assert(!1,"Please implement step()")}},QLAgent:class{#$;#j;#K;#F;#G;#B;#H;constructor(t,e,s,r,o,n){this.#$=r,this.#j=s,this.#G=o,this.#K=t,this.#F=e,this.#B=new Map,this.#H=n??i.inject({},n),this.#H.randActionFunc||(this.#H.randActionFunc=function(t){return i.randItem(t)})}#X(t){return r.str(t)||r.num(t)||r.bool(t)?t:JSON.stringify(t)}#J(t){let e=this.#X(t);return this.#B.has(e)||this.#B.set(e,new Map),this.#B.get(e)}#U(t,e,s=0){let i=this.#J(t);return i.has(e)?i.get(e):s}getQValue(t,e){return this.#U(t,e)}updateQValue(t,e,s,i){let r=this.getQValue(t,e),o=this.#J(s).keys().toArray().sort().map((t=>this.getQValue(s,t))),n=o.length>0?function(t){let e=-1/0,s=-1;return t.forEach(((t,i)=>{t>e&&(e=t,s=i)})),[s,e]}(o)[1]:0,h=r+this.#K*(i+this.#F*n-r);this.#J(t).set(e,h)}getAction(t,e){if(i.rand()<this.#$){let t=this.#H.randActionFunc(e);return console.log(`Getting next random action... ${t}`),t}let s=-1/0,r=e.reduce(((e,i,r)=>(r=this.getQValue(t,i),e.push([i,r]),r>s&&(s=r),e)),[]).filter((t=>t[1]==s)),o=i.randItem(r)[0];return console.log(`Getting bellman's next action... ${o} with epsilon = ${this.#$}`),o}decayEpsilon(t){this.#$=this.#j+(this.#$-this.#j)*Math.exp(-this.#G*t)}prnQTableAsObj(){let t={};return this.#B.keys().toArray().sort().forEach((e=>{let s={},i=this.#B.get(e);t[e]=s,i.keys().toArray().sort().forEach((t=>{s[t]=i.get(t)}))})),JSON.stringify(t)}prnQTable(){let t=[];return this.#B.keys().toArray().sort().forEach((e=>{let s,i=this.#B.get(e);i.keys().toArray().sort().forEach((r=>{s=i.get(r),t.push(`${e},${r},${s}`)}))})),t.join("\n")}save(){return this.prnQTable()}load(t){let e,s,i=t.split("\n");e=new Map,i.forEach((t=>{s=t.split(","),e.has(s[0])||e.set(s[0],new Map),n=e.get(s[0]),n.set(s[1],s[2])})),this.#B=e}}}}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/DQL"]=e}(this),function(t,e){"use strict";function s(s){const{NodeType:i,FuncType:r,FuncTypeDB:o}=t["io/czlab/mcfud/algo/NNet"](),n=s?s.Core:t["io/czlab/mcfud/core"](),h=(s?s.Math:t["io/czlab/mcfud/math"](),Math.floor),{u:a,is:l}=n,c={NODE:2,LINK:1},d={SNAPSHOT:7770,ACTIVE:8881},u={BIAS:1,addLinkAttempts:5,findLoopedLink:5,findOldLink:5,probAddLink:.07,probAddNode:.03,chanceRecurrent:-1,probCancelLink:.75,mutationRate:.8,maxWeightJiggle:.5,probSetWeight:.1,activationMutation:.1,maxActivationJiggle:.1,compatThreshold:.26,youngFitnessBonus:1.3,youngBonusAge:10,survivalRate:0,oldAgeThreshold:50,oldAgePenalty:.7,crossOverRate:.7,noImprovements:15,maxMeshNodes:100,numBestElites:4,actFunc:"sigmoid",fitFunc:function(t=0){return new m(t)}};function g(t){return t.nodeType==i.OUTPUT}function f(t){return t.nodeType==i.BIAS}function p(t,e=!1){return t.nodeType==i.INPUT||e&&t.nodeType==i.BIAS}class m{#W;constructor(t){this.#W=t}update(t){return this.#W=t,this}score(){return this.#W}clone(){return new m(this.#W)}}class y{#f;#p;get x(){return this.#f}get y(){return this.#p}constructor(t=0,e=0){this.#f=t,this.#p=e}toJSON(){return{x:this.x,y:this.y}}clone(){return new y(this.#f,this.#p)}static dft(){return new y(0,0)}static fromJSON(t){return new y(t.x,t.y)}}class _{#Q;#Y;#E;#b;#I;#T;get activation(){return this.#Q}get nodeType(){return this.#b}get recur(){return this.#Y}get actFunc(){return this.#E}get id(){return this.#T}get pos(){return this.#I}get posY(){return this.#I.y}get posX(){return this.#I.x}set activation(t){this.#Q=t}constructor(t,e,s=null,i=!1){a.assert(t>0,`creating a node with a bad id ${t}`),this.#I=s?s.clone():y.dft(),this.#Y=!0===i,this.#Q=1,this.#T=t,this.#b=e}setActivation(t){return this.#Q=t,this}setActFunc(t){return this.#E=t,this}setRecur(t){return this.#Y=t,this}eq(t){return this.id==t.id}prn(){return`${i.toStr(this.nodeType)}#[${this.id}]`}toJSON(){return{id:this.id,nodeType:this.nodeType,pos:this.pos.toJSON(),recur:this.recur,activation:this.activation,actFunc:l.str(this.actFunc)?this.actFunc:""}}clone(){return new _(this.id,this.nodeType,this.pos,this.recur).setActFunc(this.actFunc).setActivation(this.activation)}static fromJSON(t){return new _(t.id,t.nodeType,y.fromJSON(t.pos),t.recur).setActFunc(t.actFunc).setActivation(t.activation)}}class w{#Y;#Z;#_;#tt;#et;get fromID(){return this.#tt}get toID(){return this.#et}get enabled(){return this.#Z}get weight(){return this.#_}get recur(){return this.#Y}set weight(t){this.#_=t}constructor(t,e,s=!0,i=null,r=!1){this.#tt=t,this.#et=e,this.#Y=!0===r,this.#Z=!1!==s,this.#_=null===i||isNaN(i)?a.randMinus1To1():i}eq(t){return t.fromID==this.fromID&&t.toID==this.toID}clone(){return new w(this.#tt,this.#et,this.#Z,this.#_,this.#Y)}setRecur(t){return this.#Y=t,this}setEnabled(t){return this.#Z=t,this}toJSON(){return{fromID:this.fromID,toID:this.toID,recur:this.recur,weight:this.weight,enabled:this.enabled}}static fromJSON(t){return new w(t.fromID,t.toID,t.enabled,t.weight,t.recur)}}class N{#st;#it;#rt;#ot;#tt;#et;#I;get innovType(){return this.#st}get nodeID(){return this.#ot}get IID(){return this.#rt}get pos(){return this.#I}get fromID(){return this.#tt}get toID(){return this.#et}get nodeType(){return this.#it}constructor(t,e,s,r,o=null,n=null){this.#I=n?n.clone():y.dft(),this.#rt=t.genIID(),this.#st=r,this.#tt=e,this.#et=s,l.vecN(o,2,!0)?(this.#it=o[1],this.#ot=o[0]):(this.#ot=-31,this.#it=i.NONE),t.add(this)}toJSON(){return{pos:this.pos.toJSON(),type:this.innovType,id:this.IID,fromID:this.fromID,toID:this.toID,nodeID:this.nodeID,nodeType:this.nodeType}}static fromJSON(t,e){return new N(e,t.fromID,t.toID,t.type,[t.nodeID,t.nodeType],t.pos)}static from(t,e,s,i){return new N(t,-71,-99,c.NODE,[e,s],i)}}class v{#nt;#ht;#at;get parent(){return this.#at}constructor(t){this.#nt=0,this.#ht=[],this.#at=t}genIID(){return++this.#nt}check(t,e,s){a.assert(t>0&&e>0,`checking innov with bad node ids: from: ${t}, to: ${e}`);const i=this.#ht.find((i=>i.innovType==s&&i.fromID==t&&i.toID==e));return i?i.IID:-51}add(t){return this.#ht.push(t),this}create(t,e,s,r=i.NONE,o=null){let n;return s==c.NODE?(a.assert(r!=i.NONE,"create-innov: unexpected bad neuron type"),a.assert(t>0&&e>0,`create-innov: bad neuron ids: from: ${t} to: ${e}`),n=new N(this,t,e,s,[this.parent.genNID(),r],o)):n=new N(this,t,e,s,null,o),n}getNodeID(t){const e=this.#ht.find((e=>e.IID==t));return e?e.nodeID:-41}getIID(t,e=c.LINK){return this.check(t.fromID,t.toID,e)}getInnov(t,e=c.LINK){return this.#ht.find((s=>s.innovType==e&&s.fromID==t.fromID&&s.toID==t.toID))}findInnovWithIID(t){return this.#ht.find((e=>e.IID==t))}getInnovWithNodeID(t){return this.#ht.find((e=>e.nodeID==t))}toJSON(){return{counter:this.#nt,innovs:this.#ht.map((t=>t.toJSON()))}}_fromJSON(t){this.#nt=t.counter,this.#ht=t.innovs.map((t=>N.fromJSON(t)))}static fromJSON(t,e){return new v(e)._fromJSON(t)}}class E{#_;#lt;#ct;#dt;get weight(){return this.#_}get from(){return this.#lt}get recur(){return this.#dt}constructor(t,e,s,i=!1){this.#_=t,this.#lt=e,this.#ct=s,this.#dt=!0===i}clone(){return new E(this.#_,this.#lt,this.#ct,this.#dt)}static from(t,e,s){const i=new E(t.weight,e,s,t.recur);return e.addLinkOut(i),s.addLinkIn(i),i}}class x{#w;#Q;#N;#it;#ot;#x;#I;#E;get activation(){return this.#Q}get nodeType(){return this.#it}get id(){return this.#ot}get pos(){return this.#I}get posY(){return this.#I.y}get actFunc(){return this.#E}get outputValue(){return this.#x}set outputValue(t){this.#x=t}constructor(t,e,s=null,i=1){this.#I=s?s.clone():y.dft(),this.#Q=i,this.#it=e,this.#ot=t,this.#x=0,this.#N=[],this.#w=[]}_cpy(t,e,s){return this.#w=s.map((t=>t.clone())),this.#N=e.map((t=>t.clone())),this.#x=t,this}prn(){return`node(${i.toStr(this.nodeType)})#[${this.id}]`}flush(){return this.outputValue=0,this}clone(){return new x(this.id,this.nodeType,this.pos,this.activation)._cpy(this.outputValue,this.#N,this.#w)}setActFunc(t){return this.#E=t,this}funcOverInLinks(t){return t(this.#N)}addLinkIn(t){return this.#N.push(t),this}addLinkOut(t){return this.#w.push(t),this}static from(t){return new x(t.id,t.nodeType,t.pos,t.activation)}}class k{#C;#ut;get depth(){return this.#ut}constructor(t){a.append(this.#C=[],t,!0),this.#gt()}#gt(){this.#ut=a.groupSimilar(this.#C.map((t=>t.posY)),a.feq).length}clone(){return new k(this.#C.map((t=>t.clone())))}compute(t,e=d.ACTIVE){return this.update(t,e)}update(t,e=d.ACTIVE){let s,i=[],r=e==d.SNAPSHOT?this.depth:1;function n(t){return t.reduce(((t,e)=>t+e.weight*e.from.outputValue),0)}for(;r--;)i.length=0,s=this.#C.filter((t=>p(t))),a.assert(s.length<=t.length,`NodeMesh: update with mismatched input size ${t.length}`),s.forEach(((e,s)=>{e.outputValue=t[s]})),this.#C.find((t=>f(t))).outputValue=u.BIAS,this.#C.forEach((t=>{if(!p(t,!0)){let e=t.actFunc||u.actFunc;l.fun(e)||(e=o[e||""]),e||(e=o.sigmoid),t.outputValue=e(t.funcOverInLinks(n)/t.activation),g(t)&&i.push(t.outputValue)}}));return e==d.SNAPSHOT&&this.#C.forEach((t=>t.flush())),i}}class S{#C;#ft;#pt;#mt;#l;#yt;#_t;#R;#P;#wt;#at;get spawnCnt(){return this.#_t}get adjScore(){return this.#yt}get id(){return this.#mt}get parent(){return this.#at}set spawnCnt(t){this.#_t=t}constructor(t,e=!1){this.#l=u.fitFunc(0),this.#C=[],this.#ft=[],this.#mt=-1,this.#at=t,this.#wt=0,this.#yt=0,this.#_t=0,this.#pt=[],e||(this.#mt=t.genGID(),t.naissance(this).#Nt())}#Nt(){return this.#pt=this.#C.reduce(((t,e)=>(p(e,!0)||t.push(e),t)),[]),this.#C.sort(a.comparator(a.SORT_ASC,(t=>t.posY),(t=>t.posY))),this.#vt()}#Et(){return this.#C.reduce(((t,e,s)=>t+(0==s?"":", ")+e.prn()),"")}#xt(){0}crossOverWith(t){let e=[],s=[];this.#ft.forEach(((i,r)=>{let o=!0,n=t.findInnov(this.parent.db.getIID(i));n?(a.assert(i.eq(n),`expected links to be same, but not!, ${i.fromID} to ${i.toID}, and ${n.fromID} to ${n.toID}`),i.enabled&&n.enabled||a.rand()<u.probCancelLink&&(o=!1),s.push(a.randAorB(i,n))):(o=i.enabled,s.push(i)),e.push(o)}));let i,r=[];return s.forEach(((t,e)=>{e=this.#C.find((e=>t.fromID==e.id)),a.assert(e,`unexpectedly missing node ${t.fromID} in crossOver`),r.find((t=>t.id==e.id))||r.push(e),e=this.#C.find((e=>t.toID==e.id)),a.assert(e,`unexpectedly missing node ${t.toID} in crossOver`),r.find((t=>t.id==e.id))||r.push(e)})),r=r.map((t=>t.clone())),i=s.map(((t,s)=>t.clone().setEnabled(e[s]))),new S(this.parent,!0)._inflate(r,i)}dbgState(){return`{nodes=${this.#Et()},links=${this.#ft.length}}`}adjustScore(t){return this.#yt=t,this}size(){return this.#C.length}scale(){return this.#ft.length}setScore(t){return this.#l.update(t),this}getScore(){return this.#l.score()}geneAt(t){return this.#ft[t]}nodeAt(t){return this.#C[t]}mutateGID(t){return a.assert(t>0,"bad genome id, must be positive"),this.#mt=t,this}_inflate(t,e){return a.append(this.#C,t,!0),a.append(this.#ft,e,!0),this.id<0&&(this.#mt=this.parent.genGID()),this.#Nt()}findInnov(t){let e=this.parent.db.findInnovWithIID(t);return this.#ft.find((t=>t.fromID==e.fromID&&t.toID==e.toID))}phenotype(){const t=this.#C.map((t=>x.from(t)));return this.#ft.forEach((e=>e.enabled?E.from(e,t.find((t=>t.id==e.fromID)),t.find((t=>t.id==e.toID))):0)),new k(t)}#kt(){return a.randItem(this.#C)}#St(){return a.randItem(this.#pt)}addLink(t,s,i,r){if(!(a.rand()<t))return;let o,n,h,l=!1;if(a.rand()<s){for(i=Math.min(1,i);i--;)if(h=this.#St(),!h.recur){h.setRecur(l=!0),o=n=h;break}}else for(r=Math.min(1,r);r--;){if(n=this.#St(),o=this.#kt(),!n||!o)throw"poo";if(o.id!=n.id&&!this.#bt(o.id,n.id))break;o=n=e}o&&n&&(o.posY>n.posY&&(l=!0),this.parent.db.check(o.id,n.id,c.LINK)<0&&this.parent.db.create(o.id,n.id,c.LINK),this.#ft.push(new w(o.id,n.id,!0,a.randMinus1To1(),l)))}addNode(t,e){if(!(a.rand()<t))return;let s,r,o,n=-1,l=this.scale(),d=l-1-h(Math.sqrt(l)),u=t=>!t.enabled||t.recur||f(this.#Mt(t.fromID))?-1:t.fromID;if(e=Math.min(1,e),l<this.parent.inSlots+this.parent.outSlots+5)for(;n<0&&e--;)o=this.#ft[a.randInt2(0,d)],n=u(o);else for(;n<0;)o=a.randItem(this.#ft),n=u(o);if(n<0)return;a.assert(o,"addNode: unexpected null link gene!"),o.setEnabled(!1),r=o.toID,a.assert(n>0&&r>0,`addNode: bad node ids: fromID: ${n}, toID: ${r}`);let g=o.weight,p=this.#Mt(r),m=this.#Mt(n),N=(E=m,x=p,a.assert(E&&x,`splitBetween: unexpected null params: from: ${E}, to: ${x}`),new y((E.posX+x.posX)/2,(E.posY+x.posY)/2)),v=this.parent.db.check(n,r,c.NODE);var E,x;v>0&&this.#It(this.parent.db.getNodeID(v))&&(v=-1),v<0?(s=this.parent.db.create(n,r,c.NODE,i.HIDDEN,N).nodeID,a.assert(s>0,`addNode: (+) unexpected -ve neuron id ${s}`),this.parent.db.create(n,s,c.LINK),this.parent.db.create(s,r,c.LINK)):(s=this.parent.db.getNodeID(v),a.assert(s>0,`addNode: (x) unexpected -ve neuron id ${s}`)),a.assert(this.parent.db.check(n,s,c.LINK)>0&&this.parent.db.check(s,r,c.LINK)>0,"addNode: expected innovations"),this.#C.push(new _(s,i.HIDDEN,N)),this.#ft.push(new w(n,s,!0,1),new w(s,r,!0,g))}#Mt(t){let e=this.#C.find((e=>e.id==t));return e||a.assert(!1,"Error in Genome::findNode")}#bt(t,e){return this.#ft.some((s=>s.fromID==t&&s.toID==e))}#It(t){return t>0&&this.#C.some((e=>e.id==t))}mutateWeights(t,e,s){this.#ft.forEach((i=>{a.rand()<t&&(i.weight=a.rand()<e?a.randMinus1To1():i.weight+a.randMinus1To1()*s)}))}mutateActivation(t,e){this.#C.forEach((s=>{a.rand()<t&&(s.activation+=a.randMinus1To1()*e)}))}calcCompat(t){let e,s,i,r,o=0,n=0,h=0,a=0,l=0,c=0,d=this.scale(),u=t.scale();for(;o<d||n<u;)o>=d?(++n,++a):n>=u?(++o,++a):(r=t.geneAt(n),i=this.geneAt(o),s=this.parent.db.getIID(r),e=this.parent.db.getIID(i),e==s?(++o,++n,++l,c+=Math.abs(i.weight-r.weight)):(++h,e<s?++o:e>s&&++n));let g=Math.max(this.scale(),t.scale()),f=1*a/g+1*h/g;return l>0?f+.4*c/l:f}#vt(){return this.#ft.sort(a.comparator(a.SORT_ASC,(t=>this.parent.db.getIID(t)),(t=>this.parent.db.getIID(t)))),this}_cpy(t,e,s,i,r,o,n){return this.#l=u.fitFunc(e.score()),this.#C=o.map((t=>t.clone())),this.#ft=n.map((t=>t.clone())),this.#_t=i,this.#yt=s,this.#wt=r,this.#mt=t,this.#Nt()}clone(t){return new S(this.parent,!0)._cpy(t||this.#mt,this.#l,this.#yt,this.#_t,this.#wt,this.#C,this.#ft)}morph(){return this.size()<u.maxMeshNodes&&this.addNode(u.probAddNode,u.findOldLink),this.addLink(u.probAddLink,u.chanceRecurrent,u.findLoopedLink,u.addLinkAttempts),this.mutateWeights(u.mutationRate,u.probSetWeight,u.maxWeightJiggle),this.mutateActivation(u.activationMutation,u.maxActivationJiggle),this.#Nt()}}class b{#Tt;#Ot;#Dt;#C;#H;#R;#P;#At;get outSlots(){return this.#P}get inSlots(){return this.#R}get db(){return this.#At}constructor(t,e,s){this.#Ot=0,this.#Tt=0,this.#Dt=0,this.#P=e,this.#R=t,this.#C=[],this.#At=new v(this),this.#zt(t,e,s||{})}#zt(t,e,s){let r,[o,n]=function(t,e){return[1/(t+2),1/(e+1)]}(t,e),h=0;for(let e=0;e<t;++e)r={t:i.INPUT,id:++h,co:new y((e+2)*o,0)},this.#C.push(r),N.from(this.db,r.id,r.t,r.co);r={t:i.BIAS,id:++h,co:new y(o,0)},this.#C.push(r),N.from(this.db,r.id,r.t,r.co);for(let t=0;t<e;++t)r={act:s.actOutFunc,t:i.OUTPUT,id:++h,co:new y((t+1)*n,1)},this.#C.push(r),N.from(this.db,r.id,r.t,r.co);a.assert(h==t+e+1,"bad layout - mismatched node ids"),a.assert(h==this.#C.at(-1).id,"bad layout - erroneous last node id"),this.#Dt=h,this.#H=s;{let t=this.#C.filter((t=>t.t!=i.OUTPUT)),e=this.#C.filter((t=>t.t==i.OUTPUT));t.forEach((t=>e.forEach((e=>new N(this.db,t.id,e.id,c.LINK)))))}}naissance(t){let e=this.#C.filter((t=>t.t!=i.OUTPUT)),s=this.#C.filter((t=>t.t==i.OUTPUT)),r=[],o=[];return this.#C.forEach(((t,e)=>{g(e=new _(t.id,t.t,t.co))&&e.setActFunc(this.#H.actFuncOut),r.push(e)})),e.forEach((t=>s.forEach((e=>o.push(new w(t.id,e.id)))))),t._inflate(r,o)}genSID(){return++this.#Ot}genGID(){return++this.#Tt}genNID(){return++this.#Dt}createNodeFromID(t){const e=this.db.getInnovWithNodeID(t);return a.assert(e,"unknown node id not found in innov history."),new _(t,e.nodeType,e.pos).setActFunc(this.#H.actFunc)}}class M{#qt;#at;#Ct;#a;#Lt;#Rt;#Pt;#s;get bestScore(){return this.#s}get id(){return this.#qt}get leader(){return this.#Pt}get stale(){return this.#Ct}get age(){return this.#a}get parent(){return this.#at}constructor(t,e){this.#s=e.getScore(),this.#Pt=e.clone(),this.#Rt=[e],this.#qt=t.genSID(),this.#Lt=0,this.#a=0,this.#Ct=0,this.#at=t}adjustScores(){return this.#Rt.forEach(((t,e,s)=>{e=t.getScore(),this.#a<u.youngBonusAge&&(e*=u.youngFitnessBonus),this.#a>u.oldAgeThreshold&&(e*=u.oldAgePenalty),t.adjustScore(e/s.length)})),this}addMember(t){return t.getScore()>this.#s&&(this.#s=t.getScore(),this.#Pt=t.clone(),this.#Ct=0),t.species=this.#qt,this.#Rt.push(t),this}purge(){return a.trunc(this.#Rt),this.#Lt=0,++this.#Ct,++this.#a,this}calcSpawnAmount(){return this.#Lt=this.#Rt.reduce(((t,e)=>t+e.spawnCnt),0)}spawn(){let t,e,s=this.#Rt.length;return 1==s?e=this.#Rt[0]:(t=h(u.survivalRate*s)-1,t<0&&(t=1),t>=s&&(t=s-1),e=this.#Rt[a.randInt2(0,t)]),e.clone(this.parent.genGID())}randPair(t=5){a.assert(t>=0,"bad param: tries must be positive");let s,i,r,o=this.#Rt.length;if(1==o)s=this.#Rt[0];else for(r=h(u.survivalRate*o)-1,r<0&&(r=1),r>=o&&(r=o-1),s=this.#Rt[a.randInt2(0,r)];t--&&(i=this.#Rt[a.randInt2(0,r)],s.id==i.id);)i=e;return i?[s,i]:[s,null]}numToSpawn(){return this.#Lt}size(){return this.#Rt.length}}return{NeatGA:class{#Vt;#$t;#jt;#Kt;#Ft;#Gt;#s;#u;#at;constructor(t,e,s,i){this.#Kt=0,this.#u=t,this.#Vt=[],this.#$t=[],this.#jt=[],this.#Ft=0,this.#Gt=0,this.#s=0,this.#at=new b(e,s,i)}#Bt(){return this.#jt=a.fill(this.#u,(()=>new S(this.#at)))}curGen(){return this.#Kt}epoch(t){a.assert(t.length==this.#jt.length,"NeatGA::Epoch(scores/ genomes mismatch)!");let e=this.#Xt(t).#Ht(),s=this.#u-e.length;for(;s--;)e.push(this.tournamentSelection(h(this.#u/5)).clone(this.#at.genGID()));a.assert(e.length==this.#u,"NeatGA::Epoch(new genomes count mismatch)!"),a.append(this.#jt,e,!0),this.#Kt+=1}createPhenotypes(){return(0==this.#jt.length?this.#Bt():this.#jt).map((t=>t.phenotype()))}numSpecies(){return this.#Vt.length}bestFromPrevGen(){return this.#$t.map((t=>t.phenotype()))}#Jt(t,e){let s,i;return t.getScore()>e.getScore()?(s=t,i=e):t.getScore()<e.getScore()?(s=e,i=t):a.randSign()>0?(s=t,i=e):(s=e,i=t),s.crossOverWith(i)}tournamentSelection(t){let e,s,i=0;for(a.assert(t>=0,`tournamentSelection: bad arg value: ${t}`);t--;)s=a.randItem(this.#jt),s.getScore()>i&&(e=s,i=s.getScore());return e||this.#jt[0]}#Ht(){let t,e=[];return this.#Vt.forEach((s=>{if(e.length<this.#u){let i=!1,r=a.rounded(s.numToSpawn());for(;r--;){if(i)if(1==s.size()||a.rand()>u.crossOverRate)t=s.spawn();else{let[e,i]=s.randPair(5);t=i?this.#Jt(e,i):e.clone(this.#at.genGID())}else i=!0,t=s.leader.clone(this.#at.genGID());if(e.push(t.morph())==this.#u)break}}})),e}#Xt(t){this.#Ft=0,this.#Gt=0;let e=[];this.#Vt.forEach((t=>{t.stale>u.noImprovements&&t.bestScore<this.#s||e.push(t.purge())})),a.append(this.#Vt,e,!0),this.#jt.forEach(((e,s)=>e.setScore(t[s]))),this.#jt.sort(a.comparator(a.SORT_DESC,(t=>t.getScore()),(t=>t.getScore()))),this.#s=Math.max(this.#s,this.#jt[0].getScore()),a.trunc(this.#$t);for(let t=0;t<u.numBestElites;++t)this.#$t.push(this.#jt[t]);return this.#jt.forEach(((t,e)=>{(e=this.#Vt.find((e=>t.calcCompat(e.leader)<=u.compatThreshold)))?e.addMember(t):this.#Vt.push(new M(this.#at,t))})),this.#Vt.forEach((t=>t.adjustScores())),this.#Ft=this.#jt.reduce(((t,e)=>t+e.adjScore),this.#Ft),this.#Gt=this.#Ft/this.#jt.length,this.#jt.forEach((t=>t.spawnCnt=t.adjScore/this.#Gt)),this.#Vt.forEach((t=>t.calcSpawnAmount())),this.#Vt.sort(a.comparator(a.SORT_DESC,(t=>t.bestScore),(t=>t.bestScore))),this}},NodeMesh:k,Genome:S,NodeGene:_,LinkGene:w,Link:E,Node:x,Species:M,ScoreFunc:m,InnovDB:v,NodeType:i,InnovType:c,RunType:d,configParams:t=>a.inject(u,t)}}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/NEAT"]=s}(this),function(){"use strict";console.log("@czlab/crafty version: 1.5.0")}();