!function(t,e){"use strict";function s(s){const i=s?s.Basic:t["io/czlab/mcfud/algo/basic"](),r=s?s.Core:t["io/czlab/mcfud/core"](),{prnIter:n,Bag:o,Stack:h,Iterator:a,StdCompare:l}=i,c=Math.floor,{is:u,u:d}=r;function g(t,e,s,i,r){d.assert(t>e,"bad resize capacity");let n,o=new Array(t);for(n=s;n<i;++n)o[n]=r[n];return o}const p=(t,e,s)=>s(t,e)<0;function f(t,e,s){const i=t[e];t[e]=t[s],t[s]=i}function m(t){let e,s="";for(e=0;e<t.length;++e)s+=`${t[e]} `;console.log(s)}class y{static sort(t,e){const s=t.length;for(let i=1;i<s;++i)for(let s=i;s>0&&p(t[s],t[s-1],e);--s)f(t,s,s-1);return t}static sortRange(t,e,s,i){for(let r=e+1;r<s;++r)for(let s=r;s>e&&p(t[s],t[s-1],i);--s)f(t,s,s-1);return t}static indexSort(t,e){const s=t.length,i=d.fill(s,(t=>t));for(let r=1;r<s;++r)for(let s=r;s>0&&p(t[i[s]],t[i[s-1]],e);--s)f(i,s,s-1);return i}static test(){let t="SORTEXAMPLE".split("");m(y.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(y.sortRange(t,0,t.length,l)),t="SORTEXAMPLE".split(""),m(y.indexSort(t,l))}}class _{static sort(t,e){let s,i,r,n=t.length;for(let o,h=1;h<n;++h){for(i=0,r=h,o=t[h];i<r;)s=i+d.ndiv(r-i,2),p(o,t[s],e)?r=s:i=s+1;for(let e=h;e>i;--e)t[e]=t[e-1];t[i]=o}return t}static test(){let t="SORTEXAMPLE".split("");m(_.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(_.sort(t,l))}}class N{static sort(t,e){let s,i=t.length;for(let r=0;r<i;++r){s=r;for(let n=r+1;n<i;++n)p(t[n],t[s],e)&&(s=n);f(t,r,s)}return t}static test(){let t="SORTEXAMPLE".split("");m(N.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(N.sort(t,l))}}class w{static sort(t,e){let s=t.length,i=1,r=d.ndiv(s,3);for(;i<r;)i=3*i+1;for(;i>=1;){for(let r=i;r<s;++r)for(let s=r;s>=i&&p(t[s],t[s-i],e);s-=i)f(t,s,s-i);i=d.ndiv(i,3)}return t}static test(){let t="SORTEXAMPLE".split("");m(w.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(w.sort(t,l))}}function E(t,e,s,i,r,n){if(r<=i);else{let o=i+d.ndiv(r-i,2);E(t,e,s,i,o,n),E(t,e,s,o+1,r,n),function(t,e,s,i,r,n,o){for(let t=i;t<=n;++t)s[t]=e[t];let h=i,a=r+1;for(let l=i;l<=n;++l)h>r?e[l]=s[a++]:a>n?e[l]=s[h++]:p(t[s[a]],t[s[h]],o)?e[l]=s[a++]:e[l]=s[h++]}(t,e,s,i,o,r,n)}return t}class v{static sort(t,e){return function t(e,s,i,r,n){if(r<=i);else{let o=i+d.ndiv(r-i,2);t(e,s,i,o,n),t(e,s,o+1,r,n),function(t,e,s,i,r,n){for(let i=s;i<=r;++i)e[i]=t[i];let o=s,h=i+1;for(let a=s;a<=r;++a)o>i?t[a]=e[h++]:h>r?t[a]=e[o++]:p(e[h],e[o],n)?t[a]=e[h++]:t[a]=e[o++]}(e,s,i,o,r,n)}return e}(t,new Array(t.length),0,t.length-1,e),t}static indexSort(t,e){let s=t.length,i=d.fill(s,(t=>t));return E(t,i,new Array(s),0,s-1,e),i}static test(){let t="SORTEXAMPLE".split("");m(v.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(v.sort(t,l)),t="SORTEXAMPLE".split(""),m(v.indexSort(t,l))}}class x{static sort(t,e){const s=t.length;for(let i,r=0;r<s;++r){i=0;for(let n=s-1;n>r;--n)p(t[n],t[n-1],e)&&(f(t,n,n-1),++i);if(0==i)break}return t}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");x.sort(t,l),m(t)}}function k(t,e,s,i){let r=e,n=t[e],o=s+1;for(;;){for(;p(t[++r],n,i)&&r!=s;);for(;p(n,t[--o],i)&&o!=e;);if(r>=o)break;f(t,r,o)}return f(t,e,o),o}class b{static sort(t,e){return function t(e,s,i,r){if(i<=s);else{let n=k(e,s,i,r);t(e,s,n-1,r),t(e,n+1,i,r)}return e}(t,0,t.length-1,e),t}static select(t,e,s){if(e<0||e>=t.length)throw Error(`index is not between 0 and ${t.length}: ${e}`);let i=0,r=t.length-1;for(;r>i;){let n=k(t,i,r,s);if(n>e)r=n-1;else{if(!(n<e))return t[n];i=n+1}}return t[i]}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");m(b.sort(t,l)),t="SORTEXAMPLE".split(""),m(b.sort(t,l)),d.shuffle(t),t.forEach(((e,s)=>console.log(b.select(t,s,l))))}}const S=(t,e,s,i)=>p(t[e],t[s],i);class M{Node(t){return{key:t,order:0}}constructor(t,s){this.compare=t,this.table=new Map,this.head=e,this._min=e,this.n=0,u.vec(s)&&s.forEach((t=>this.insert(t)))}isEmpty(){return 0==this.n}size(){return this.n}insert(t){let e=this.Node(t);this.n+=1,this.head=this._insertNode(e,this.head),this._min=this._min?this._greater(this._min.key,t)?this.head:this._min:this.head}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cut(this._min,this.head);let t=this._min.child,s=this._min.key;return this._min.key=e,t&&(this.head=this._meld(this.head,t),this._min.child=e),this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),s}union(t){return this.head=this._meld(this.head,t.head),this._min=this._greater(this._min.key,t._min.key)?t._min:this._min,this.n=this.n+t.n,this}_greater(t,e){return!d.nichts(t)&&(!!d.nichts(e)||this.compare(t,e)>0)}_link(t,e){e.child=this._insertNode(t,e.child),e.order+=1}_consolidate(){this.table.clear();let t=this.head,s=e,i=e,r=0;this._min=this.head;do{for(s=t,t=t.next,i=this.table.get(s.order);i;)this.table.delete(s.order),this._greater(s.key,i.key)?(this._link(s,i),s=i):this._link(i,s),i=this.table.get(s.order);this.table.set(s.order,s),s.order>r&&(r=s.order)}while(t!==this.head);this.head=null,this.table.forEach((t=>{t&&(this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head))}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cut(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new M(this.compare),e=s=>{if(!s)return;let i=s;do{t.insert(i.key),e(i.child),i=i.next}while(i!==s)};return e(this.head),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new M(l);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",e.isEmpty(),console.log(t),console.log("min= "+e.min()),console.log(n(e.iter())),console.log("("+e.size()+" left on pq)");let s=new M(l);"ZTAK".split("").forEach((t=>s.insert(t))),s=s.union(e),console.log(n(s.iter()))}}class T{Node(t){return{key:t,order:0,index:0}}constructor(t,s){if(t<0)throw Error("Cannot create a priority queue of negative size");this.maxN=t,this.n=0,this.head=e,this._min=e,this.compare=s,this.table=new Map,this.nodes=new Array(t)}isEmpty(){return 0==this.n}contains(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");return d.echt(this.nodes[t])}size(){return this.n}insert(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(this.contains(t))throw Error("Specified index is already in the queue");let s=this.Node(e);s.index=t,this.nodes[t]=s,this.n+=1,this.head=this._insertNode(s,this.head),this._min=this._min?this._greater(this._min.key,e)?this.head:this._min:this.head}minIndex(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.index}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cutNode(this._min,this.head);let t=this._min.child,s=this._min.index;if(this._min.key=e,t){do{t.parent=e,t=t.next}while(t!==this._min.child);this.head=this._meld(this.head,t),this._min.child=e}return this.n-=1,this.isEmpty()?this._min=e:this._consolidate(),this.nodes[s]=e,s}keyOf(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");return this.nodes[t].key}changeKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");this._greater(e,this.nodes[t].key)?this.increaseKey(t,e):this.decreaseKey(t,e)}decreaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(e,this.nodes[t].key))throw Error("Calling with this argument would not decrease the key");let s=this.nodes[t];s.key=e,this._greater(this._min.key,e)&&(this._min=s),s.parent&&this._greater(s.parent.key,e)&&this._cut(t)}increaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(this.nodes[t].key,e))throw Error("Calling with this argument would not increase the key");this.delete(t),this.insert(t,e)}delete(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");let s=this.nodes[t];if(s.key=null,s.parent&&this._cut(t),this.head=this._cutNode(s,this.head),s.child){let t=s.child;s.child=e,s=t;do{t.parent=e,t=t.next}while(t!==s);this.head=this._meld(this.head,t)}this.isEmpty()?this._min=e:this._consolidate(),this.nodes[t]=e,this.n-=1}_greater(t,e){return!d.nichts(t)&&(!!d.nichts(e)||this.compare(t,e)>0)}_link(t,e){t.parent=e,e.child=this._insertNode(t,e.child),e.order+=1}_cut(t){let s=this.nodes[t],i=s.parent;i.child=this._cutNode(s,i.child),s.parent=e,i.order-=1,this.head=this._insertNode(s,this.head),i.mark=!i.mark,!i.mark&&i.parent&&this._cut(i.index)}_consolidate(){let t=e,s=e,i=0,r=this.head;this.table.clear(),this._min=this.head;do{for(t=r,r=r.next,s=this.table.get(t.order);s;)this.table.delete(t.order),this._greater(t.key,s.key)?(this._link(t,s),t=s):this._link(s,t),s=this.table.get(t.order);this.table.set(t.order,t),t.order>i&&(i=t.order)}while(r!==this.head);this.head=e,this.table.forEach((t=>{this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head)}))}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cutNode(t,s){if(t.next===t)return t.next=e,t.prev=e,e;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=e,t.prev=e,s===t?i:s}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new T(this.maxN,this.compare);return this.nodes.forEach((e=>{e&&t.insert(e.index,e.key)})),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new T(t.length,l);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(console.log("min= "+e.min()),console.log("minindex= "+e.minIndex()),console.log("size= "+e.size()),console.log("contains(3)="+e.contains(3)),console.log("keyOf(3)="+e.keyOf(3)),e.changeKey(3,"bbbb");!e.isEmpty();){let t=e.minIndex();console.log(t+" "+e.keyOf(t)),e.delMin()}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class I{constructor(t,e){if(this.comparator=t,this.n=0,u.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t,this)}else this.pq=new Array(u.num(e)?e:2);d.assert(this._isMinHeap(),"not min heap")}isEmpty(){return 0==this.n}size(){return this.n}min(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=g(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.pq[++this.n]=t,this._swim(this.n),d.assert(this._isMinHeap(),"not min heap-insert")}delMin(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return f(this.pq,1,this.n--),this._sink(1),this.pq[this.n+1]=e,this.n>0&&this.n==d.ndiv(this.pq.length-1,4)&&(this.pq=g(d.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_swim(t){for(;t>1&&this._greater(d.ndiv(t,2),t);)f(this.pq,t,d.ndiv(t,2)),t=d.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&e++,!this._greater(t,e))break;f(this.pq,t,e),t=e}}_greater(t,e){return this.comparator(this.pq[t],this.pq[e])>0}_isMinHeap(){for(let t=1;t<=this.n;++t)if(d.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(!d.nichts(this.pq[t]))return!1;return!d.echt(this.pq[0])&&this._isMinHeapOrdered(1)}_isMinHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&this._greater(t,e))&&(!(s<=this.n&&this._greater(t,s))&&(this._isMinHeapOrdered(e)&&this._isMinHeapOrdered(s)))}iter(){let t=new I(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new I(l);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMin()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}class O{constructor(t,e){if(this.comparator=t,this.n=0,u.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=c(this.n/2);t>=1;--t)this._sink(t)}else this.pq=new Array(u.num(e)?e:2);d.assert(this._isMaxHeap(),"not max heap")}isEmpty(){return 0==this.n}size(){return this.n}max(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=g(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.n+=1,this.pq[this.n]=t,this._swim(this.n),d.assert(this._isMaxHeap(),"not max heap-insert")}delMax(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return f(this.pq,1,this.n),this.n-=1,this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==d.ndiv(this.pq.length-1,4)&&(this.pq=g(d.ndiv(this.pq.length,2),this.n,1,this.n+1,this.pq)),t}_isMaxHeap(){for(let t=1;t<=this.n;++t)if(d.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(d.echt(this.pq[t]))return!1;return!d.echt(this.pq[0])&&this._isMaxHeapOrdered(1)}_isMaxHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&S(this.pq,t,e,this.comparator))&&(!(s<=this.n&&S(this.pq,t,s,this.comparator))&&(this._isMaxHeapOrdered(e)&&this._isMaxHeapOrdered(s)))}_swim(t){for(;t>1&&S(this.pq,d.ndiv(t,2),t,this.comparator);)f(this.pq,t,d.ndiv(t,2)),t=d.ndiv(t,2)}_sink(t){let e;for(;2*t<=this.n&&(e=2*t,e<this.n&&S(this.pq,e,e+1,this.comparator)&&++e,S(this.pq,t,e,this.comparator));)f(this.pq,t,e),t=e}iter(){const t=new O(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t="",e=new O(l);"PQE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","XAM".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ","PLE".split("").forEach((t=>e.insert(t))),t+=e.delMax()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}function A(t,e,s,i){return i(t[e-1],t[s-1])<0}function z(t,e,s){const i=t[e-1];t[e-1]=t[s-1],t[s-1]=i}class D{static sort(t,e){function s(t,e,s,i){for(;2*e<=s;){let r=2*e;if(r<s&&A(t,r,r+1,i)&&++r,!A(t,e,r,i))break;z(t,e,r),e=r}}let i,r=t.length;for(i=d.ndiv(r,2);i>=1;--i)s(t,i,r,e);for(i=r;i>1;)z(t,1,i--),s(t,1,i,e);return t}static test(){let t="SORTEXAMPLE".split("");m(D.sort(t,l)),t="bed bug dad yes zoo all bad yet".split(" "),m(D.sort(t,l))}}class q{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}minIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}minKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMin(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),d.assert(t==this.pq[this.n+1],"No good"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(s<0)throw Error("Calling decreaseKey() with a key strictly greater than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(s>0)throw Error("Calling increaseKey() with a key strictly less than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_greater(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])>0}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._greater(d.ndiv(t,2),t);)this._exch(t,d.ndiv(t,2)),t=d.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&++e,!this._greater(t,e))break;this._exch(t,e),t=e}}iter(){let t=new q(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new q(t.length,l);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(;!e.isEmpty();){let s=e.delMin();console.log(s+" "+t[s])}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class R{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}maxIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}maxKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMax(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),d.assert(this.pq[this.n+1]==t,"bad delMax"),this.qp[t]=-1,this.mKeys[t]=e,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)>0)throw Error("Calling increaseKey() with a key that is strictly less than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)<0)throw Error("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.qp[t];this._exch(s,this.n--),this._swim(s),this._sink(s),this.mKeys[t]=e,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_less(t,e){return p(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]],this.compare)}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._less(d.ndiv(t,2),t);)this._exch(t,d.ndiv(t,2)),t=d.ndiv(t,2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._less(e,e+1)&&++e,!this._less(t,e))break;this._exch(t,e),t=e}}iter(){let t=new R(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new R(t.length,l);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);console.log("");for(let s=0;s<t.length;++s)d.rand()<.5?e.increaseKey(s,t[s]+t[s]):e.decreaseKey(s,t[s].substring(0,1));for(;!e.isEmpty();){let t=e.maxKey(),s=e.delMax();console.log(s+" "+t)}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);let s=new Array(t.length);for(let e=0;e<t.length;++e)s[e]=e;d.shuffle(s);for(let t=0;t<s.length;++t){let i=e.keyOf(s[t]);e.delete(s[t]),console.log(s[t]+" "+i)}}}return{FibonacciMinPQ:M,IndexFibonacciMinPQ:T,Insertion:y,BinaryInsertion:_,Selection:N,Shell:w,Merge:v,Bubble:x,Quick:b,MinPQ:I,MaxPQ:O,Heap:D,IndexMinPQ:q,IndexMaxPQ:R}}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/sort"]=s}(this),function(t,e){"use strict";function s(s,i){const r=s?s.Basic:t["io/czlab/mcfud/algo/basic"](),n=s?s.Core:t["io/czlab/mcfud/core"](),o=s?s.Math:t["io/czlab/mcfud/math"]();i||(i=t["io/czlab/mcfud/algo/sort"]());const{Bag:h,Stack:a,Queue:l,StdCompare:c,prnIter:u}=r,{MinPQ:d}=i,{is:g,u:p}=(Math.floor,n);class f{static count(t,e){let s=new Map,i=0,r="",n=0;for(let r,o=0;o<t.length;++o)r=t[o],r.length<e||(++i,s.has(r)?s.set(r,s.get(r)+1):(s.set(r,1),++n));return s.set(r,0),Array.from(s.keys()).forEach((t=>{s.get(t)>s.get(r)&&(r=t)})),[r,s.get(r),[n,i]]}static test(){let t="it was the best of times it was the worst of times\n        it was the age of wisdom it was the age of foolishness\n        it was the epoch of belief it was the epoch of incredulity\n        it was the season of light it was the season of darkness\n        it was the spring of hope it was the winter of despair".split(" "),[e,s,i]=f.count(t,1);console.log(e+" "+s),console.log("distinct = "+i[0]),console.log("words= "+i[1])}}class m{constructor(){this.first=e,this.n=0}size(){return this.n}isEmpty(){return 0==this.size()}contains(t){if(p.nichts(t))throw Error("argument to contains is null");return void 0!==this.get(t)}get(t){if(p.nichts(t))throw Error("argument to get is null");for(let e=this.first;e;e=e.next)if(t==e.key)return e.val}put(t,e){if(p.nichts(t))throw Error("first argument to put is null");if(void 0===e)this.delete(t);else{let s,i;for(i=this.first;i&&!s;i=i.next)t==i.key&&(i.val=e,s=!0);s||(this.first=((t,e,s)=>({key:t,val:e,next:s}))(t,e,this.first),this.n+=1)}}delete(t){const s=(t,i)=>t?i==t.key?(this.n-=1,t.next):(t.next=s(t.next,i),t):e;if(p.nichts(t))throw Error("argument to delete is null");this.first=s(this.first,t)}keys(){let t=new l;for(let e=this.first;e;e=e.next)t.enqueue(e.key);return t.iter()}static load(t){let e=new m;return t.forEach(((t,s)=>e.put(t,s))),e}static test(){let t=m.load("SEARCHEXAMPLE".split(""));console.log(((e="",s=0,i=0)=>{for(i=t.keys();i.hasNext();)e+=`${s=i.next()}=${t.get(s)} `;return e})()),console.log("size= "+t.size()),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),t.delete("R"),t.isEmpty(),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),console.log("size= "+t.size())}}class y{constructor(t,e=2){this.mKeys=new Array(e),this.vals=new Array(e),this.compare=t,this.n=0,this._resize=t=>{let e=new Array(t),s=new Array(t);for(let t=0;t<this.n;++t)e[t]=this.mKeys[t],s[t]=this.vals[t];this.vals=s,this.mKeys=e},this._argOk=t=>p.echt(t,"Invalid argument"),this._check=()=>(()=>{for(let t=1;t<this.size();++t)if(this.compare(this.mKeys[t],this.mKeys[t-1])<0)return!1;return!0})()&&(()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0;t<this.size();++t)if(0!=this.compare(this.mKeys[t],this.select(this.rank(this.mKeys[t]))))return!1;return!0})()}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){if(this._argOk(t)&&!this.isEmpty()){let e=this.rank(t);if(e<this.n&&0==this.compare(this.mKeys[e],t))return this.vals[e]}}rank(t){let e,s,i=0,r=this.n-1;for(this._argOk(t);i<=r;)if(e=i+o.ndiv(r-i,2),s=this.compare(t,this.mKeys[e]),s<0)r=e-1;else{if(!(s>0))return e;i=e+1}return i}put(t,e){if(this._argOk(t)&&void 0===e)this.delete(t);else{let s=this.rank(t);if(s<this.n&&0==this.compare(this.mKeys[s],t))this.vals[s]=e;else{this.n==this.mKeys.length&&this._resize(2*this.mKeys.length);for(let t=this.n;t>s;--t)this.mKeys[t]=this.mKeys[t-1],this.vals[t]=this.vals[t-1];this.n+=1,this.mKeys[s]=t,this.vals[s]=e}}}delete(t){if(this._argOk(t)&&this.isEmpty());else{let s=this.rank(t);if(s==this.n||0!=this.compare(this.mKeys[s],t));else{for(let t=s;t<this.n-1;++t)this.mKeys[t]=this.mKeys[t+1],this.vals[t]=this.vals[t+1];this.n-=1,this.mKeys[this.n]=e,this.vals[this.n]=e,this.n>0&&this.n==o.ndiv(this.mKeys.length,4)&&this._resize(o.ndiv(this.mKeys.length,2)),this._check()}}}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.min())}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.max())}min(){if(this.isEmpty())throw Error("called min with empty symbol table");return this.mKeys[0]}max(){if(this.isEmpty())throw Error("called max with empty symbol table");return this.mKeys[this.n-1]}select(t){if(t<0||t>=this.size())throw Error(`called select with invalid argument: ${t}`);return this.mKeys[t]}floor(t){let e=this._argOk(t)&&this.rank(t);if(e<this.n&&0==this.compare(t,this.mKeys[e]))return this.mKeys[e];if(0==e)throw Error("argument to floor is too small");return this.mKeys[e-1]}ceiling(t){let e=this._argOk(t)&&this.rank(t);if(e==this.n)throw Error("argument to ceiling is too large");return this.mKeys[e]}size(t,e){return 0==arguments.length?this.n:(this._argOk(t)&&this._argOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}keys(t,e){0==arguments.length&&(t=this.min(),e=this.max()),this._argOk(t)&&this._argOk(e);let s=new l;if(this.compare(t,e)>0);else{for(let i=this.rank(t);i<this.rank(e);++i)s.enqueue(this.mKeys[i]);this.contains(e)&&s.enqueue(this.mKeys[this.rank(e)])}return s.iter()}static load(t,e){let s=new y(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t=y.load("SEARCHEXAMPLE".split(""),c),e=e=>{e="";for(let s,i=t.keys();i.hasNext();)s=i.next(),e+=`${s}=${t.get(s)} `;return e};console.log(e()),t.deleteMin(),console.log(e()),t.deleteMax(),t.isEmpty(),console.log(e()),console.log("floor of Q= "+t.floor("Q")),console.log("ceil of Q= "+t.ceiling("Q")),console.log("size= "+t.size()),console.log("size= "+t.size("E","P")),console.log("keys E->P = "+u(t.keys("E","P")))}}class _{constructor(t){this.compare=t,this.root=e,this._argOk=t=>p.assert(t,"Invalid argument"),this._check=()=>(this.isBST(this.root,null,null)||console.log("Not in symmetric order"),this.isSizeConsistent(this.root)||console.log("Subtree counts not consistent"),this.isRankConsistent()||console.log("Ranks not consistent"),this.isBST(this.root,null,null)&&this.isSizeConsistent(this.root)&&this.isRankConsistent()),this.isBST=(t,e,s)=>!!p.nichts(t)||!(p.echt(e)&&this.compare(t.key,e)<=0)&&(!(p.echt(s)&&this.compare(t.key,s)>=0)&&(this.isBST(t.left,e,t.key)&&this.isBST(t.right,t.key,s))),this.isSizeConsistent=t=>!!p.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(this.isSizeConsistent(t.left)&&this.isSizeConsistent(t.right)),this.isRankConsistent=()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this.rank(t))))return!1;return!0}}Node(t,e,s){return{key:t,val:e,size:s}}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){return this._getNode(this.root,t)}_getNode(t,e){if(!this._argOk(e)||!p.nichts(t)){let s=this.compare(e,t.key);return s<0?this._getNode(t.left,e):s>0?this._getNode(t.right,e):t.val}}put(t,e){this._argOk(t)&&p.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this._check())}_putNode(t,e,s){if(p.nichts(t))t=this.Node(e,s,1);else{let i=this.compare(e,t.key);i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right)}return t}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMinNode(this.root),this._check()}_deleteMinNode(t){return p.nichts(t.left)?t=t.right:(t.left=this._deleteMinNode(t.left),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMaxNode(this.root),this._check()}_deleteMaxNode(t){return p.nichts(t.right)?t=t.left:(t.right=this._deleteMaxNode(t.right),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}delete(t){this.root=this._argOk(t)&&this._deleteNode(this.root,t),this._check()}_deleteNode(t,e){if(p.echt(t)){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(p.nichts(t.right))return t.left;if(p.nichts(t.left))return t.right;let e=t;(t=this._minNode(e.right)).right=this._deleteMinNode(e.right),t.left=e.left}t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1}return t}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return p.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return p.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(p.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(p.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0)return this._floorNode(t.left,e);let i=this._floorNode(t.right,e);return p.nichts(i)?t:i}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(p.nichts(e))throw Error("argument to floor is too large");return e.key}_ceilingNode(t,s){if(p.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0){let e=this._ceilingNode(t.left,s);return e||t}return this._ceilingNode(t.right,s)}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(p.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(p.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(p.nichts(t));else{let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}_sizeNode(t){return p.nichts(t)?0:t.size}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}height(){return this._heightNode(this.root)}_heightNode(t){return p.nichts(t)?-1:1+Math.max(this._heightNode(t.left),this._heightNode(t.right))}levelOrder(){let t,e=[],s=new l;for(e.push(this.root);e.length>0;)t=e.pop(),p.echt(t)&&(s.enqueue(t.key),e.push(t.left,t.right));return s.iter()}static load(t,e){let s=new _(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=_.load("SEARCHEXAMPLE".split(""),c);t="";for(let s,i=e.levelOrder();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("level-order:\n"+t),t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;e.isEmpty(),console.log("keys=\n"+t),console.log("size="+e.size()),console.log("size E->Q = ",e.size("E","Q")),t="";for(let s,i=e.keys("E","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[E->Q]= "+t),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank P= "+e.rank("P")),console.log("contains X= "+e.contains("X")),console.log("contains Z= "+e.contains("Z")),e.delete("X"),console.log("get C="+e.get("C")),console.log("max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("height= "+e.height()),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank E= "+e.rank("E")),console.log("floor G= "+e.floor("G")),console.log("ceiling G= "+e.ceiling("G"))}}class N{static BLACK=!1;static RED=!0;constructor(t){this.compare=t,this.root=e,this._argOk=t=>p.assert(t,"Invalid argument"),this._check=()=>{let t=(e,s,i)=>!!p.nichts(e)||!(s&&this.compare(e.key,s)<=0)&&(!(i&&this.compare(e.key,i)>=0)&&(t(e.left,s,e.key)&&t(e.right,e.key,i))),e=t=>!!p.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(e(t.left)&&e(t.right)),s=t=>!!p.nichts(t)||!this._isRed(t.right)&&((t===this.root||!this._isRed(t)||!this._isRed(t.left))&&(s(t.left)&&s(t.right))),i=(t,e)=>p.nichts(t)?0==e:(this._isRed(t)||--e,i(t.left,e)&&i(t.right,e));return t(this.root,null,null)&&e(this.root)&&(()=>{for(let t=0;t<this.size();++t)if(t!=this._rankNode(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this._rankNode(t))))return!1;return!0})()&&s(this.root)&&(()=>{let t=0,e=this.root;for(;e;)this._isRed(e)||++t,e=e.left;return i(this.root,t)})()}}Node(t,e,s,i){return{key:t,val:e,color:s,size:i}}_isRed(t){return!p.nichts(t)&&t.color===N.RED}_sizeNode(t){return p.nichts(t)?0:t.size}isEmpty(){return p.nichts(this.root)}get(t){return this._argOk(t)&&this._getNode(this.root,t)}_getNode(t,e){for(;t;){let s=this.compare(e,t.key);if(s<0)t=t.left;else{if(!(s>0))return t.val;t=t.right}}}contains(t){return void 0!==this.get(t)}put(t,e){this._argOk(t)&&p.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.root.color=N.BLACK)}_putNode(t,e,s){if(p.nichts(t))return this.Node(e,s,N.RED,1);let i=this.compare(e,t.key);return i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}deleteMin(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=N.RED),this.root=this._deleteMinNode(this.root),this.isEmpty()||(this.root.color=N.BLACK)}_deleteMinNode(t){return p.nichts(t.left)?null:(this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteMinNode(t.left),this._balance(t))}deleteMax(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=N.RED),this.root=this._deleteMaxNode(this.root),this.isEmpty()||(this.root.color=N.BLACK)}_deleteMaxNode(t){return this._isRed(t.left)&&(t=this._rotateRight(t)),p.nichts(t.right)?null:(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),t.right=this._deleteMaxNode(t.right),this._balance(t))}delete(t){this._argOk(t)&&!this.contains(t)||(this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=N.RED),this.root=this._deleteNode(this.root,t),this.isEmpty()||(this.root.color=N.BLACK))}_deleteNode(t,e){if(this.compare(e,t.key)<0)this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteNode(t.left,e);else{if(this._isRed(t.left)&&(t=this._rotateRight(t)),0==this.compare(e,t.key)&&p.nichts(t.right))return null;if(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),0==this.compare(e,t.key)){let e=this._minNode(t.right);t.key=e.key,t.val=e.val,t.right=this._deleteMinNode(t.right)}else t.right=this._deleteNode(t.right,e)}return this._balance(t)}_rotateRight(t){if(p.nichts(t)||!this._isRed(t.left))throw Error("bad input to rotateRight");let e=t.left;return t.left=e.right,e.right=t,e.color=e.right.color,e.right.color=N.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_rotateLeft(t){if(p.nichts(t)||!this._isRed(t.right))throw Error("bad input to rotateLeft");let e=t.right;return t.right=e.left,e.left=t,e.color=e.left.color,e.left.color=N.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_flipColors(t){t.color=!t.color,t.left.color=!t.left.color,t.right.color=!t.right.color}_moveRedLeft(t){return this._flipColors(t),this._isRed(t.right.left)&&(t.right=this._rotateRight(t.right),t=this._rotateLeft(t),this._flipColors(t)),t}_moveRedRight(t){return this._flipColors(t),this._isRed(t.left.left)&&(t=this._rotateRight(t),this._flipColors(t)),t}_balance(t){return this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}height(){return this._height(this.root)}_height(t){return p.nichts(t)?-1:1+Math.max(this._height(t.left),this._height(t.right))}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return p.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return p.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(p.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,s){if(p.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(p.nichts(e))throw Error("argument to ceiling is too small");return e.key}_ceilingNode(t,s){if(p.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error(`argument to select is invalid: ${t}`);return this._selectNode(this.root,t)}_selectNode(t,s){if(p.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(p.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new l;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}static load(t,e){let s=new N(e);return t.forEach(((t,e)=>s.put(t,e))),s}static test(){let t,e=N.load("SEARCHEXAMPLE".split(""),c);t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log(t),e.isEmpty(),console.log("height= "+e.height()+", size= "+e.size()),console.log("get X= "+e.get("X")),console.log("contains X= "+e.contains("X")),console.log("min= "+e.min()+",max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("min= "+e.min()+",max= "+e.max()),e.delete("R"),console.log("contains R= "+e.contains("R")),console.log("floor J= "+e.floor("J")),console.log("ceiling J= "+e.ceiling("J")),console.log("rank M= "+e.rank("M")),t="";for(let s,i=e.keys("D","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[D-Q]= "+t),console.log("size[E-P]= "+e.size("E","P"))}}class w{static indexOf(t,e){let s=0,i=t.length-1;for(;s<=i;){let r=s+o.ndiv(i-s,2);if(e<t[r])i=r-1;else{if(!(e>t[r]))return r;s=r+1}}return-1}static test(){let t="84 48 68 10 18 98 12 23 54 57 33 16 77 11 29".split(" ").map((t=>+t)).sort();"23 50 10 99 18 23 98 84 11 10 48 77 13 54 98 77 77 68".split(" ").map((t=>+t)).forEach((e=>{w.indexOf(t,e)<0&&console.log(e)}))}}class E{Node(t,e,s,i){return{key:t,val:e,height:s,size:i}}constructor(t){this.compare=t,this.root=e}isEmpty(){return p.nichts(this.root)}_sizeNode(t){return p.nichts(t)?0:t.size}height(){return this._heightNode(this.root)}_heightNode(t){return p.nichts(t)?-1:t.height}get(t){if(p.nichts(t))throw Error("argument to get() is null");let e=this._getNode(this.root,t);if(e)return e.val}_getNode(t,s){if(!t)return e;let i=this.compare(s,t.key);return i<0?this._getNode(t.left,s):i>0?this._getNode(t.right,s):t}contains(t){return void 0!==this.get(t)}put(t,e){if(p.nichts(t))throw Error("first argument to put() is null");void 0===e?this.delete(t):this.root=this._putNode(this.root,t,e)}_putNode(t,e,s){if(!t)return this.Node(e,s,0,1);let i=this.compare(e,t.key);if(i<0)t.left=this._putNode(t.left,e,s);else{if(!(i>0))return t.val=s,t;t.right=this._putNode(t.right,e,s)}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balanceNode(t)}_balanceNode(t){return this._balanceFactor(t)<-1?(this._balanceFactor(t.right)>0&&(t.right=this._rotateRight(t.right)),t=this._rotateLeft(t)):this._balanceFactor(t)>1&&(this._balanceFactor(t.left)<0&&(t.left=this._rotateLeft(t.left)),t=this._rotateRight(t)),t}_balanceFactor(t){return this._heightNode(t.left)-this._heightNode(t.right)}_rotateRight(t){let e=t.left;return t.left=e.right,e.right=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}_rotateLeft(t){let e=t.right;return t.right=e.left,e.left=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}delete(t){if(p.nichts(t))throw Error("argument to delete() is null");this.contains(t)&&(this.root=this._deleteNode(this.root,t))}_deleteNode(t,e){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(!t.left)return t.right;if(!t.right)return t.left;let e=t;(t=this.min(e.right)).right=this.deleteMin(e.right),t.left=e.left}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)}deleteMin(){if(this.isEmpty())throw Error("called deleteMin() with empty symbol table");this.root=this._deleteMinNode(this.root)}_deleteMinNode(t){return t.left?(t.left=this._deleteMinNode(t.left),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.right}deleteMax(){if(this.isEmpty())throw Error("called deleteMax() with empty symbol table");this.root=this._deleteMaxNode(this.root)}_deleteMaxNode(t){return t.right?(t.right=this._deleteMaxNode(t.right),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.left}min(){if(this.isEmpty())throw Error("called min() with empty symbol table");return this._minNode(this.root).key}_minNode(t){return t.left?this._minNode(t.left):t}max(){if(this.isEmpty())throw Error("called max() with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return t.right?this._maxNode(t.right):t}floor(t){if(p.nichts(t))throw Error("argument to floor() is null");if(this.isEmpty())throw Error("called floor() with empty symbol table");let e=this._floorNode(this.root,t);if(e)return e.key}_floorNode(t,s){if(p.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,s);let r=this._floorNode(t.right,s);return r||t}ceiling(t){if(p.nichts(t))throw Error("argument to ceiling() is null");if(this.isEmpty())throw Error("called ceiling() with empty symbol table");let e=this._ceilingNode(this.root,t);if(e)return e.key}_ceilingNode(t,s){if(p.nichts(t))return e;let i=this.compare(s,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,s);let r=this._ceilingNode(t.left,s);return r||t}select(t){if(t<0||t>=this.size())throw Error("k is not in range 0-"+(this.size()-1));let e=this._selectNode(this.root,t);if(e)return e.key}_selectNode(t,s){if(p.nichts(t))return e;let i=this._sizeNode(t.left);return i>s?this._selectNode(t.left,s):i<s?this._selectNode(t.right,s-i-1):t}rank(t){if(p.nichts(t))throw Error("argument to rank() is null");return this._rankNode(t,this.root)}_rankNode(t,e){if(p.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keysInOrder(){let t=new l;return this._keysInOrderNode(this.root,t),t.iter()}_keysInOrderNode(t,e){p.nichts(t)||(this._keysInOrderNode(t.left,e),e.enqueue(t.key),this._keysInOrderNode(t.right,e))}keysLevelOrder(){let t=new l;if(!this.isEmpty()){let e=new l;for(e.enqueue(this.root);!e.isEmpty();){let s=e.dequeue();t.enqueue(s.key),s.left||e.enqueue(s.left),s.right&&e.enqueue(s.right)}}return t}keys(t,e){if(0==arguments.length)return this.keysInOrder();if(p.nichts(t))throw Error("first argument to keys() is null");if(p.nichts(e))throw Error("second argument to keys() is null");let s=new l;return this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}}size(t,e){if(0==arguments.length)return this._sizeNode(this.root);if(p.nichts(t))throw Error("first argument to size() is null");if(p.nichts(e))throw Error("second argument to size() is null");return this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}_check(){let t=this;return function e(s,i,r){return!s||!(!i&&t.compare(s.key,i)<=0)&&(!(!r&&t.compare(s.key,r)>=0)&&(e(s.left,i,s.key)&&e(s.right,s.key,r)))}(this.root,null,null)&&function e(s){if(!s)return!0;let i=t._balanceFactor(s);return!(i>1||i<-1)&&(e(s.left)&&e(s.right))}(this.root)&&function e(s){return!s||s.size==t._sizeNode(s.left)+t._sizeNode(s.right)+1&&(e(s.left)&&e(s.right))}(this.root)&&function(){for(let e=0;e<t.size();e++)if(e!=t.rank(t.select(e)))return!1;for(let e,s=t.keys().iterator();s.hasNext();)if(e=s.next(),0!=this.compare(e,t.select(t.rank(key))))return!1;return!0}()}static test(){let t=new E(c);"SEARCHEXAMPLE".split("").forEach(((e,s)=>t.put(e,s)));for(let e,s=t.keys();s.hasNext();)e=s.next(),console.log(e+" "+t.get(e))}}const v=Math.sqrt(2);function x(t,e){return{parent:e,pos:t,f:0,g:0,h:0,pid:`${t[0]},${t[1]}`,equals(t){return this.pos[0]==t.pos[0]&&this.pos[1]==t.pos[1]}}}class k{static manhattan(t,e,s=1){return s*Math.abs(t[1]-e[1])+s*Math.abs(t[0]-e[0])}static euclidean(t,e,s=1){let i=e[0]-t[0],r=e[1]-t[1];return s*(i*i+r*r)}static diagonal(t,e,s=1,i=v){let r=Math.abs(e[0]-t[0]),n=Math.abs(e[1]-t[1]);return s*(r+n)+(i-2*s)*Math.min(r,n)}constructor(t){this.grid=t}pathTo(t,e,s){return this._search(this.grid,t,e,s)}_search(t,e,s,i){const r=i.compare,n=t.length,o=t[0].length,h=new Map,a=new Map,l=new d(r,10),c=x(s),u=x(e),g=[[1,0],[-1,0],[0,1],[0,-1]],p=(t,e)=>{for(;t;t=t.parent)e.unshift(t.pos);return e};i.wantDiagonal&&g.push([1,1],[1,-1],[-1,1],[-1,-1]),a.set(u.pid,u.g),l.insert(u);let f,m=[];for(;!l.isEmpty();){if(f=l.delMin(),a.delete(f.pid),h.set(f.pid,0),f.equals(c))return p(f,[]);m.length=0;for(let t,e=0;e<g.length;++e)t=[f.pos[0]+g[e][0],f.pos[1]+g[e][1]],t[0]>o-1||t[0]<0||t[1]>n-1||t[1]<0||i.blocked(t)||m.push(x(t,f));m.forEach((t=>{h.has(t.pid)||(t.g=f.g+i.cost(),t.h=i.calcHeuristic(t.pos,c.pos),t.f=t.g+t.h,a.has(t.pid)&&t.g>a.get(t.pid)||(l.insert(t),a.set(t.pid,t.g)))}))}}static test(){let t,e,s,i=[[0,1,0,0,0,0],[0,0,0,0,0,0],[0,1,0,1,0,0],[0,1,0,0,1,0],[0,0,0,0,1,0]],r=i.length,n=i[0].length,o={wantDiagonal:!1,compare:(t,e)=>t.f-e.f,cost:()=>1,blocked:t=>0!=i[t[1]][t[0]],calcHeuristic:(t,e)=>k.euclidean(t,e)},h=new k(i).pathTo([0,0],[5,4],o);h?(s="",h.forEach((t=>{s+=`[${t[0]},${t[1]}] `})),console.log(s),e=p.fill(r,(()=>p.fill(n,"#"))),t=0,h.forEach((s=>{e[s[1]][s[0]]=""+t,++t})),e.forEach((t=>{console.log(t.toString())}))):console.log("no path")}}return{AStarGrid:k,AVLTreeST:E,RedBlackBST:N,BST:_,BinarySearch:w,BinarySearchST:y,FrequencyCounter:f,SequentialSearchST:m}}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud"),require("./sort")):t["io/czlab/mcfud/algo/search"]=s}(this),function(t,e){"use strict";function s(s,i){const r=s?s.Basic:t["io/czlab/mcfud/algo/basic"](),n=s?s.Core:t["io/czlab/mcfud/core"]();s?s.Math:t["io/czlab/mcfud/math"]();i||(i=t["io/czlab/mcfud/algo/sort"]());const{prnIter:o,TreeMap:h,Bag:a,Stack:l,Queue:c,ST:u,StdCompare:d}=r,{IndexMinPQ:g,MinPQ:p}=i,{is:f,u:m}=(Math.floor,n);function y(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`);return!0}class _{constructor(t){m.assert(t>=0,"Number of vertices must be non-negative"),this.verts=t,this.edges=0,this.adjls=m.fill(t,(()=>new a))}clone(){let t=new _(this.V());t.edges=this.E(),t.adjls=[];for(let e=0,s=this.V();e<s;++e)t.adjls.push(this.adjls[e].clone());return t}V(){return this.verts}E(){return this.edges}addEdge(t,e){y(t,this.verts),y(e,this.verts),this.edges+=1,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return y(t,this.verts)&&this.adjls[t]}degree(t){return y(t,this.verts)&&this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e=0;e<this.verts;++e)t+=`${e}: `+o(this.adjls[e].iter()),t+="\n";return t}static load(t,e){let s=new _(t);m.assert(e.length%2==0,"wanted even n# of data points");for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}static test(){let t=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);t.degree(1),console.log(t.toString());let e=t.clone();console.log("cloned=\n"+e.toString())}}class N{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.nCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.nCount}static test(){let t,e,s=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new N(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t),console.log(e.count()!=s.V()?"NOT connected":"connected")}))}}class w{constructor(t,e){this.bMarked=new Array(t.V()),y(e,this.bMarked.length);let s,i,r=m.fill(t.V(),(e=>t.adj(e).iter())),n=new l;for(this.bMarked[e]=!0,n.push(e);!n.isEmpty();)s=n.peek(),r[s].hasNext()?(i=r[s].next(),this.bMarked[i]||(this.bMarked[i]=!0,n.push(i))):n.pop()}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}static test(){let t,e,s=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach((i=>{e=new w(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=`${i} `);console.log(t)}))}}class E{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new l;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t=_.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new E(t,0);for(let s,i,r=0;r<t.V();++r)if(e.hasPathTo(r)){s=`0 to ${r}:  `;for(let t=e.pathTo(r);t.hasNext();)i=t.next(),s+=0==i?i:`-${i}`;console.log(s)}else console.log(`0 to ${r}:  not connected\n`)}}function v(t,e,s){let i,r=[];for(i=0;i<t.V();++i)s.mDistTo[i]=1/0;for(e.forEach((t=>{s.bMarked[t]=!0,s.mDistTo[t]=0,r.push(t)}));r.length>0;){i=r.shift();for(let e,n=t.adj(i).iter();n.hasNext();)e=n.next(),s.bMarked[e]||(s.edgeTo[e]=i,s.mDistTo[e]=s.mDistTo[i]+1,s.bMarked[e]=!0,r.push(e))}}function x(t,e){if(!t||0==t.length)throw Error("argument is null or empty");return t.forEach((t=>y(t,e))),!0}class k{constructor(t,e){this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V()),f.vec(e)||(e=[e]),x(e,t.V()),v(t,e,this),function(t,e,s){if(0!=s.mDistTo[e])throw Error(`dist of source ${e} to itself = ${s.mDistTo[e]}`);for(let e=0;e<t.V();++e)for(let i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s.hasPathTo(e)!==s.hasPathTo(i))throw Error(`edge ${e}-${i}hasPathTo(${e})=${s.hasPathTo(e)}hasPathTo(${i})=${s.hasPathTo(i)}`);if(s.hasPathTo(e)&&s.mDistTo[i]>s.mDistTo[e]+1)throw Error(`edge ${e}-${i}distTo[${e}]=${s.mDistTo[e]}distTo[${i}]=${s.mDistTo[i]}`)}for(let i,r=0;r<t.V();++r)if(s.hasPathTo(r)&&r!=e&&(i=s.edgeTo[r],s.mDistTo[r]!=s.mDistTo[i]+1))throw Error(`shortest path edge ${i}-${r} distTo[${i}]= ${s.mDistTo[i]}distTo[${r}]= ${s.mDistTo[r]}`)}(t,e,this)}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new l;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t=_.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new k(t,0);for(let s,i=0;i<t.V();++i)if(e.hasPathTo(i)){s=`0 to ${i}(${e.distTo(i)}): `;for(let t,r=e.pathTo(i);r.hasNext();)t=r.next(),s+=0==t?`${t}`:`-${t}`;console.log(s)}else console.log(`0 to ${i} (-):  not connected\n`)}}class b{constructor(t,e,s){if(t<0)throw Error("vertex index must be a non-negative integer");if(e<0)throw Error("vertex index must be a non-negative integer");this.v=t,this.w=e,this._weight=s}weight(){return this._weight}either(){return this.v}other(t){if(t==this.v)return this.w;if(t==this.w)return this.v;throw Error("Illegal endpoint")}static comparator(t,e){return t._weight<e._weight?-1:t._weight>e._weight?1:0}toString(){return`${this.v}-${this.w} ${this._weight}`}static test(){console.log(new b(12,34,5.67).toString())}}class S{constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this._V=t,this._E=0,this.adjls=m.fill(t,(()=>new a))}static randGraph(t,e){let s=new S(t);if(e<0)throw Error("Number of edges must be non-negative");for(let i,r,n,o=0;o<e;++o)r=m.randInt(t),n=m.randInt(t),i=Math.round(100*m.rand())/100,s.addEdge(new b(r,n,i));return s}clone(){let t=new S(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){let e=t.either(),s=t.other(e);y(e,this._V),y(s,this._V),this.adjls[e].add(t),this.adjls[s].add(t),this._E+=1}adj(t){return y(t,this._V)&&this.adjls[t]}degree(t){return y(t,this._V)&&this.adjls[t].size()}edges(){const t=new a;for(let e,s,i,r=0;r<this._V;++r)for(s=0,e=this.adjls[r].iter();e.hasNext();)i=e.next(),i.other(r)>r?t.add(i):i.other(r)==r&&(s%2==0&&t.add(i),++s);return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()}, `;t+="\n"}return t}static load(t,e){let s=new S(t);m.assert(e.length%3==0,"Invalid data size");for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new b(e[i],e[i+1],e[i+2]));return s}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38 2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34 6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(" ").map((t=>+t)),e=S.load(8,t);console.log(e.toString())}}class M{constructor(t){this.bMarked=new Array(t.V()),this._id=new Array(t.V()),this._size=new Array(t.V()),this.nCount=0;for(let e=0;e<t.V();++e)this.bMarked[e]||(this._dfs(t,e),++this.nCount)}_dfs(t,e){this.bMarked[e]=!0,this._id[e]=this.nCount,this._size[this.nCount]+=1;for(let s,i,r=t.adj(e).iter();r.hasNext();)s=r.next(),t instanceof S?(i=s.other(e),this.bMarked[i]||this._dfs(t,i)):this.bMarked[s]||this._dfs(t,s)}id(t){return y(t,this.bMarked.length)&&this._id[t]}size(t){return y(t,this.bMarked.length)&&this._size[this._id[t]]}count(){return this.nCount}connected(t,e){return y(t,this.bMarked.length)&&y(e,this.bMarked.length)&&this.id(t)==this.id(e)}static test(){let t=_.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]),e=new M(t),s=e.count();console.log(s+" components");let i=m.fill(s,(()=>[]));for(let s=0;s<t.V();++s)i[e.id(s)].push(s);for(let t,e=0;e<s;++e)t="",i[e].forEach((e=>t+=e.toString()+" ")),console.log(t)}}class T{static load(t,e){if(t<0)throw Error("verts in a Digraph must be non-negative");m.assert(e.length%2==0,"expected even n# of data-length");let s=new T(t);for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}constructor(t){if(t<0)throw Error("verts in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=m.fill(t,0),this.adjls=m.fill(t,(()=>new a))}clone(){let t=this,e=new T(this.V());e._E=this.E(),e._indegree=m.fill(e.V(),(e=>t._indegree[e]));for(let t=0;t<e.V();++t)e.adjls[t]=this.adjls[t].clone();return e}V(){return this._V}E(){return this._E}addEdge(t,e){y(t,this._V)&&y(e,this._V),this.adjls[t].add(e),this._indegree[e]+=1,++this._E}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}reverse(){let t=new T(this._V);for(let e,s=0;s<this._V;++s)for(e=this.adjls[s].iter();e.hasNext();)t.addEdge(e.next(),s);return t}toString(){let t=`${this._V} vertices, ${this._E} edges\n`;for(let e,s=0;s<this._V;++s){for(t+=`${s}: `,e=this.adjls[s].iter();e.hasNext();)t+=`${e.next()} `;t+="\n"}return t}static test(){let t=T.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s="";for(let i=0;i<t.V();++i)e+=`${i}=${t.indegree(i)}, `,s+=`${i}=${t.outdegree(i)},`;console.log("indegreee= "+e),console.log("outdegreee= "+s),console.log(t.toString());let i=t.clone();console.log("cloned=\n"+i.toString());let r=t.reverse();console.log("rev'ed=\n"+r.toString())}}class I{constructor(t,e){this.bMarked=new Array(t.V()),f.vec(e)||(e=[e]),x(e,t.V()),e.forEach((e=>{this.bMarked[e]||this._dfs(t,e)}))}_dfs(t,e){this.mCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return y(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.mCount}static test(){let t=T.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t))),e="",s=new I(t,[1,2,6]);for(let i=0;i<t.V();++i)s.marked(i)&&(e+=`${i} `);s.count(),console.log(e)}}class O{constructor(t){this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V()),this.mCycle=e;for(let e=0;e<t.V();++e)this.bMarked[e]||this.mCycle||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();){if(s=i.next(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new l;for(let t=e;t!=s;t=this.edgeTo[t])this.mCycle.push(t);this.mCycle.push(s),this.mCycle.push(e),this._check()}}else this.edgeTo[s]=e,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return!!this.mCycle}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=-1,e=-1;for(let s,i=this.cycle();i.hasNext();)s=i.next(),-1==t&&(t=s),e=s;if(t!=e)throw Error(`cycle begins with ${t} and ends with ${e}\n`)}return!0}static test(){let t="2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)),e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9\n               10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8\n               6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t));[new O(T.load(13,e)),new O(T.load(13,t))].forEach((t=>{t.hasCycle()?(console.log("Directed cycle: "),console.log(o(t.cycle()))):console.log("No directed cycle")}))}}class A{constructor(t,e,s){if(t<0)throw Error("Vertex names must be non-negative integers");if(e<0)throw Error("Vertex names must be non-negative integers");this.v=t,this.w=e,this._weight=s}from(){return this.v}to(){return this.w}weight(){return this._weight}toString(){return`${this.v}->${this.w} ${Number(this._weight).toFixed(2)}`}static test(){console.log(new A(12,34,5.67).toString())}}class z{constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=m.fill(t,(()=>new a))}static randGraph(t,e){if(e<0)throw Error("n# edges in a Digraph must be non-negative");let s=new z(t);for(let i=0;i<e;++i)s.addEdge(new A(m.randInt(t),m.randInt(t),.01*_randInt(100)));return s}static load(t,e){if(t<0)throw Error("n# vertices in a Digraph must be non-negative");m.assert(e.length%3==0,"bad data length");let s=new z(t);for(let i=0;i<e.length;i+=3)y(e[i],t)&&y(e[i+1],t)&&s.addEdge(new A(e[i],e[i+1],e[i+2]));return s}clone(){let t=new z(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t._indegree[e]=this._indegree(e);for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){m.assert(t instanceof A,"Expected DirectedEdge");let e=t.to(),s=t.from();y(s,this._V),y(e,this._V),this.adjls[s].add(t),this._indegree[e]+=1,this._E++}adj(t){return y(t,this._V)&&this.adjls[t]}outdegree(t){return y(t,this._V)&&this.adjls[t].size()}indegree(t){return y(t,this._V)&&this._indegree[t]}edges(){const t=new a;for(let e=0;e<this._V;++e)for(let s=this.adj(e).iter();s.hasNext();)t.add(s.next());return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e=0;e<this._V;++e)t+=`${e}: `+o(this.adjls[e].iter())+"\n";return t}static test(){let t="4 5 0.35\n        5 4 0.35\n        4 7 0.37\n        5 7 0.28\n        7 5 0.28\n        5 1 0.32\n        0 4 0.38\n        0 2 0.26\n        7 3 0.39\n        1 3 0.29\n        2 7 0.34\n        6 2 0.40\n        3 6 0.52\n        6 0 0.58\n        6 4 0.93".split(/\s+/).map((t=>+t)),e=z.load(8,t);console.log(e.toString())}}class D{constructor(t){this._pre=new Array(t.V()),this._post=new Array(t.V()),this.preCounter=0,this.postCounter=0,this.postorder=new c,this.preorder=new c,this.bMarked=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.bMarked[e]=!0,this._pre[e]=this.preCounter++,this.preorder.enqueue(e);for(let s,i=t.adj(e).iter();i.hasNext();)s=t instanceof z?i.next().to():i.next(),this.bMarked[s]||this._dfs(t,s);this.postorder.enqueue(e),this._post[e]=this.postCounter++}pre(t){return y(t,this.bMarked.length)&&this._pre[t]}post(t){return y(t,this.bMarked.length)&&this._post[t]}postOrder(){return this.postorder.iter()}preOrder(){return this.preorder.iter()}reversePost(){let t=new l;for(let e=this.postorder.iter();e.hasNext();)t.push(e.next());return t.iter()}_check(){let t,e=0;for(t=this.postOrder();t.hasNext();){if(this.post(t.next())!=e)throw Error("post(v) and post() inconsistent");++e}for(e=0,t=this.preOrder();t.hasNext();){if(this.pre(t.next())!=e)throw Error("pre(v) and pre() inconsistent");++e}return!0}static test(){let t=T.load(13,"2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map((t=>+t)));console.log(t.toString());let e=new D(t);console.log("   v  pre  post"),console.log("--------------");for(let s=0;s<t.V();++s)console.log(`    ${s}  ${e.pre(s)}  ${e.post(s)}\n`);console.log("Preorder:  "),console.log(o(e.preOrder())),console.log("Postorder:  "),console.log(o(e.postOrder())),console.log(""),console.log("Reverse postorder: "),console.log(o(e.reversePost()))}}class q{constructor(t){m.assert(t instanceof z,"Expected EdgeWeightedDigraph"),this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s=i.to(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new l;let t=i;for(;t.from()!=s;)this.mCycle.push(t),t=this.edgeTo[t.from()];return void this.mCycle.push(t)}}else this.edgeTo[s]=i,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return m.echt(this.mCycle)}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=e,s=e;for(let e,i=this.cycle();i.hasNext();){if(e=i.next(),t||(t=e),s&&s.to()!=e.from())throw Error(`cycle edges ${s} and ${e} not incident\n`);s=e}if(s.to()!=t.from())throw Error(`cycle edges ${s} and ${t} not incident\n`)}return!0}static test(){let t=13,e=new z(t);m.shuffle(m.fill(t,(t=>t)));for(let s,i,r,n=0;n<8;++n){do{i=m.randInt(t),r=m.randInt(t)}while(i>=r);s=m.rand(),e.addEdge(new A(i,r,s))}for(let s=0;s<6;++s)e.addEdge(new A(m.randInt(t),m.randInt(t),m.rand()));console.log(e.toString());let s=new q(e);s.hasCycle()?console.log("Cycle: "+o(s.cycle())):console.log("No directed cycle")}}class R{constructor(t){this.st=new u,t.forEach((t=>t.forEach(((t,e)=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this._graph=new _(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s,i=1;i<t.length;++i)s=this.st.get(t[i]),this._graph.addEdge(e,s)}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this._graph.V())&&this.keys[t]}graph(){return this._graph}static test(){let t="JFK MCO\n                  ORD DEN\n                  ORD HOU\n                  DFW PHX\n                  JFK ATL\n                  ORD DFW\n                  ORD PHX\n                  ATL HOU\n                  DEN PHX\n                  PHX LAX\n                  JFK ORD\n                  DEN LAS\n                  DFW HOU\n                  ORD ATL\n                  LAS LAX\n                  ATL MCO\n                  HOU MCO\n                  LAS PHX".split(/\s+/),e=new R(m.partition(2,t)),s=e.graph();["JFK","LAX"].forEach((t=>{if(e.contains(t)){let i=e.indexOf(t);console.log(t);for(let t=s.adj(i).iter();t.hasNext();)console.log("   "+e.nameOf(t.next()))}else console.log("input not contain '"+t+"'")}))}}class C{constructor(t){this.st=new u,t.forEach((t=>t.forEach((t=>{this.st.contains(t)||this.st.put(t,this.st.size())})))),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this.graph=new T(this.st.size()),t.forEach((t=>{let e=this.st.get(t[0]);for(let s=1;s<t.length;++s)this.graph.addEdge(e,this.st.get(t[s]))}))}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return y(t,this.graph.V())&&this.keys[t]}digraph(){return this.graph}static test(){let t="JFK MCO\n              ORD DEN\n              ORD HOU\n              DFW PHX\n              JFK ATL\n              ORD DFW\n              ORD PHX\n              ATL HOU\n              DEN PHX\n              PHX LAX\n              JFK ORD\n              DEN LAS\n              DFW HOU\n              ORD ATL\n              LAS LAX\n              ATL MCO\n              HOU MCO\n              LAS PHX".split(/\s+/),e=new C(m.partition(2,t)),s=e.digraph();["JFK","ATL","LAX"].forEach((t=>{console.log(`${t}`);let i=s.adj(e.indexOf(t)).iter();for(;i.hasNext();)console.log("   "+e.nameOf(i.next()))}))}}class P{constructor(t){let s;if(this._order=e,this.rank=e,t instanceof z?s=new q(t):t instanceof T?(s=new O(t),s.hasCycle()||(this.rank=new Array(t.V()))):m.assert(!1,"bad arg for Topological"),s&&!s.hasCycle()){this._order=new c;for(let e,s=0,i=new D(t).reversePost();i.hasNext();)e=i.next(),this.rank&&(this.rank[e]=s++),this._order.enqueue(e)}}order(){return this._order.iter()}hasOrder(){return m.echt(this._order)}rank(t){return this.rank&&y(t,this.rank.length)&&this.hasOrder()?this.rank[t]:-1}static test(){let t=new C([["Algorithms","Theoretical CS","Databases","Scientific Computing"],["Introduction to CS","Advanced Programming","Algorithms"],["Advanced Programming","Scientific Computing"],["Scientific Computing","Computational Biology"],["Theoretical CS","Computational Biology","Artificial Intelligence"],["Linear Algebra","Theoretical CS"],["Calculus","Linear Algebra"],["Artificial Intelligence","Neural Networks","Robotics","Machine Learning"],["Machine Learning","Neural Networks"]]);for(let e=new P(t.digraph()).order();e.hasNext();)console.log(t.nameOf(e.next()))}}class L{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,y(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new l;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=T.load(13,e),i=new L(s,3);for(let e=0;e<s.V();++e)if(i.hasPathTo(e)){t=`3 to ${e}:  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`-${s}`;console.log(t)}else console.log(`3 to ${e}:  not connected`)}}class ${constructor(t,e){f.vec(e)||(e=[e]),this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.mDistTo[e]=1/0;x(e,t.V())&&this._bfs(t,e)}_bfs(t,e){let s=new c;for(e.forEach((t=>{this.bMarked[t]=!0,this.mDistTo[t]=0,s.enqueue(t)}));!s.isEmpty();){let e=s.dequeue();for(let i,r=t.adj(e).iter();r.hasNext();)i=r.next(),this.bMarked[i]||(this.edgeTo[i]=e,this.mDistTo[i]=this.mDistTo[e]+1,this.bMarked[i]=!0,s.enqueue(i))}}hasPathTo(t){return y(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return y(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(y(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new l;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map((t=>+t)),s=T.load(13,e),i=new $(s,3);for(let e=0;e<s.V();++e)if(t="",i.hasPathTo(e)){t=`3 to ${e} (${i.distTo(e)}):  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?`${s}`:`->${s}`;console.log(t)}else console.log(`3 to ${e} (-):  not connected`)}}class V{constructor(t,e,s){m.assert(t instanceof z,"Expected EdgeWeightedDigraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw Error(`edge ${e} has negative weight`);this._distTo=new Array(t.V()),this.edgeTo=m.fill(t.V(),null),y(e,t.V());for(let e=0;e<t.V();++e)this._distTo[e]=1/0;for(this._distTo[e]=0,this.pq=new g(t.V(),s),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next())}this._check(t,e)}_relax(t){let e=t.from(),s=t.to();this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=new l;for(let s=this.edgeTo[t];s;s=this.edgeTo[s.from()])e.push(s);return e.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.to(),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],e=s.from(),i!=s.to())throw Error("bad edge");if(this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}else;return!0}static test(){let t="4 5 0.35\n                  5 4 0.35\n                  4 7 0.37\n                  5 7 0.28\n                  7 5 0.28\n                  5 1 0.32\n                  0 4 0.38\n                  0 2 0.26\n                  7 3 0.39\n                  1 3 0.29\n                  2 7 0.34\n                  6 2 0.40\n                  3 6 0.52\n                  6 0 0.58\n                  6 4 0.93".split(/\s+/).map((t=>+t)),e=z.load(8,t),s=new V(e,0,d);for(let t=0;t<e.V();++t)s.hasPathTo(t)?console.log(`0 to ${t} (${Number(s.distTo(t)).toFixed(2)})  ${o(s.pathTo(t))}`):console.log(`0 to ${t}         no path\n`)}}class G{constructor(t,e,s){m.assert(t instanceof S,"Expected EdgeWeightedGraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw new Error(`edge ${e} has negative weight`);for(this._distTo=m.fill(t.V(),(()=>1/0)),this._distTo[e]=0,this.compare=s,this.edgeTo=m.fill(t.V(),(()=>null)),y(e,t.V()),this.pq=new g(t.V(),this.compare),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next(),e)}this._check(t,e)}_relax(t,e){let s=t.other(e);this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return y(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return y(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(y(t,this._distTo.length)&&this.hasPathTo(t)){let e=t,s=new l;for(let i=this.edgeTo[t];i;i=this.edgeTo[e])s.push(i),e=i.other(e);return s.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&!this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.other(e),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(this.edgeTo[i]){if(s=this.edgeTo[i],i!=s.either()&&i!=s.other(s.either()))return!1;if(e=s.other(i),this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38\n                  2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34\n                  6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(/\s+/).map((t=>+t)),e=S.load(8,t),s=new G(e,6,d);for(let t,i=0;i<e.V();++i)if(s.hasPathTo(i)){t=`6 to ${i} (${Number(s.distTo(i)).toFixed(2)})  `;for(let e=s.pathTo(i);e.hasNext();)t+=`${e.next()}   `;console.log(t)}else console.log(`6 to ${i}         no path`)}}return{DepthFirstDirectedPaths:L,BreadthFirstDirectedPaths:$,SymbolGraph:R,DijkstraUndirectedSP:G,DijkstraSP:V,Topological:P,SymbolDigraph:C,EdgeWeightedDirectedCycle:q,DepthFirstOrder:D,EdgeWeightedDigraph:z,DirectedEdge:A,DirectedCycle:O,DirectedDFS:I,Digraph:T,CC:M,EdgeWeightedGraph:S,Edge:b,BreadthFirstPaths:k,DepthFirstPaths:E,NonrecursiveDFS:w,DepthFirstSearch:N,Graph:_}}"object"==typeof module&&module.exports?module.exports=s(require("@/czlab/mcfud"),require("./sort")):t["io/czlab/mcfud/algo/graph"]=s}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());Math.floor;const{u:s,is:i}=e;function r(t){return 1/(1+Math.exp(-t))}const n={mutationRate:.1,crossOverRate:.7,probTournament:.75,NUM_HIDDEN:1,BIAS:-1,NUM_ELITES:4,TOURNAMENT_SIZE:5,MAX_PERTURBATION:.3,ACTIVATION_RESPONSE:1,NEURONS_PER_HIDDEN:10,sigmoid:r,relu:t=>Math.max(0,t),XXtanh(t){let e=Math.exp(t),s=Math.exp(-t);return(e-s)/(e+s)},tanh:t=>2*r(2*t)-1,softmax(t){let e,s=[],i=-1/0;return t.forEach((t=>t>i?i=t:0)),e=t.reduce(((t,e)=>(s.push(Math.exp(e-i)),t+s.at(-1))),0),s.map((t=>t/e))},XXsoftmax(t){s.assert(i.vec(t),"Expected array param as softmax input.");let e=t.map((t=>Math.exp(t))),r=e.reduce(((t,e)=>t+e),0);return e.map((t=>t/r))},softplus:t=>Math.log(1+Math.exp(t))};class o{#t;#e;#s;#i;#r;get avgScore(){return this.#t}set avgScore(t){this.#t=t}get totalScore(){return this.#e}set totalScore(t){this.#e=t}get bestScore(){return this.#s}set bestScore(t){this.#s=t}get worstScore(){return this.#i}set worstScore(t){this.#i=t}get alpha(){return this.#r}set alpha(t){this.#r=t}constructor(){this.#t=0,this.#e=0,this.#s=0,this.#i=0,this.#r=undefined}}class h{#n;#o;#h;#a;#l;get activation(){return this.#n}set activation(t){this.#n=t}get error(){return this.#a}set error(t){this.#a=t}constructor(t,e,i=!0){const r=s.fill(e,(()=>s.randMinus1To1()));i&&r.push(s.randMinus1To1()),this.#h=t,this.#n=0,this.#o=r,this.#a=0,this.#l=i}hasBias(){return this.#l}numInputs(){return this.#o.length}getBias(){return this.#l?this.#o.at(-1):void 0}setBias(t){return this.#l&&this.#o.with(-1,t),this}getWeight(t){return this.#o[t]}setWeight(t,e){return s.assert(t>=0&&t<this.#o.length,"bad index into weights"),this.#o[t]=e,this}iterWeights(t,e){return this.#o.forEach(t,e),this}applyWeights(t,e){return e?t.call(e,this.#o):t(this.#o)}update(t,e){let i=this.#l?this.#o.length-1:this.#o.length,r=0;s.assert(t.length>=i,"Incompatible input size for neuron update.");for(let e=0;e<i;++e)r+=this.#o[e]*t[e];return this.#l&&(r+=this.#o.at(-1)*n.BIAS),this.#n=e(r/n.ACTIVATION_RESPONSE)}}class a{#c;#u;#d;get numNeurons(){return this.#u.length}constructor(t,e,i,r=!0){this.#u=s.fill(t,(()=>new h(this,e,r))),this.#d=i}neuronAt(t){return this.#u[t]}iterNeurons(t,e){return this.#u.forEach(t,e),this}applyNeurons(t,e){return e?t.call(e,this.#u):t(this.#u)}update(t){return this.#u.map((e=>e.update(t,this.#d)))}}class l{#g;#p;#f;#m;get age(){return this.#m}set age(t){this.#m=t}constructor(t,e,s){this.#g=s,this.#p=e,this.#f=t,this.#m=0}getScoreCalcInfo(){return[this.#p,this.#g]}_genes(){return this.#f}getGeneAt(t){return this.#f[t]}compatible(t){return this.size()==t.size()}size(){return this.#f.length}copyGenes(){let t,e=this.#f[0];try{t=i.obj(e)&&i.fun(e.clone)}catch(t){}return t?this.#f.map((t=>t.clone())):this.#f.slice()}getScore(){s.assert(!1,"Please implement getScore()")}cmpScore(t){s.assert(!1,"Please implement cmpScore()")}updateScore(t){s.assert(!1,"Please implement updateScore()")}recalcScore(){this.updateScore(this.#p(this.#f,this.#g))}compareTo(t){s.assert(!1,"Please implement compareTo()")}mutateWith(t,e){return e?t.call(e,this.#f):t(this.#f),this.recalcScore(),this}mutateSM(){if(s.rand()<n.mutationRate){let[t,e]=s.randSpan(this.#f),i=t+1,r=e-t-1;if(2==r)s.swap(this.#f,i,t+2);else if(r>2)for(let t=s.shuffle(this.#f.slice(i,e)),r=0,n=i;n<e;++n)this.#f[n]=t[r++];this.recalcScore()}}mutateDM(){if(s.rand()<n.mutationRate){let t,e,i,[r,n]=s.randSpan(this.#f),o=r+1,h=this.#f.length;n-r-1>0&&(e=this.#f.slice(o,n),i=this.#f.slice(0,o).concat(this.#f.slice(n)),t=s.randInt(i.length),e=i.slice(0,t).concat(e).concat(i.slice(t)),s.append(this.#f,e,!0),s.assert(this.#f.length==h,"mutateDM error")),this.recalcScore()}}mutateIM(){if(s.rand()<n.mutationRate){let t,e,i=s.randInt(this.#f.length),r=this.#f.length,n=this.#f[i];this.#f.splice(i,1),i=s.randInt(this.#f.length),t=this.#f.slice(0,i),e=this.#f.slice(i),s.append(this.#f,t,!0),this.#f.push(n),s.append(this.#f,e),s.assert(r==this.#f.length,"mutateIM error"),this.recalcScore()}}mutateIVM(){if(s.rand()<n.mutationRate){let t,[e,i]=s.randSpan(this.#f),r=e+1,n=this.#f.length;if(i-e-1>1){t=this.#f.slice(r,i).reverse();for(let e=0,s=r;s<i;++s)this.#f[s]=t[e++]}s.assert(n==this.#f.length,"mutateIVM error"),this.recalcScore()}}mutateDIVM(){if(s.rand()<n.mutationRate){let t,e,i,[r,n]=s.randSpan(this.#f),o=this.#f.length,h=r+1;n-r-1>0&&(e=this.#f.slice(h,n).reverse(),i=this.#f.slice(0,h).concat(this.#f.slice(n)),t=s.randInt(i.length),e=i.slice(0,t).concat(e).concat(i.slice(t)),s.append(this.#f,e,!0),s.assert(this.#f.length==o,"mutateDIVM error")),this.recalcScore()}}iterGenes(t,e){return this.#f.forEach(t,e),this}applyGenes(t,e){return e?t.call(e,this.#f):t(this.#f)}clone(){s.assert(!1,"Please implement clone()")}static crossOverOBX(t,e){let i=t.copyGenes(),r=e.copyGenes();if(s.rand()<n.crossOverRate&&t!==e){s.assert(t.compatible(e),"Chromosomes are not compatible.");let n=t.size(),o=s.toGoldenRatio(n)[1],h=s.shuffle(s.fill(n,(t=>t))).slice(0,o).sort(),a=h.map((e=>t.getGeneAt(e)));for(let t=0,e=0;e<r.length;++e)t>=a.length&&(t=0),a.find((s=>{if(r[e]==s)return r[e]=a[t++],!0}));a=h.map((t=>e.getGeneAt(t)));for(let t=0,e=0;e<i.length;++e)t>=a.length&&(t=0),a.find((s=>{if(i[e]==s)return i[e]=a[t++],!0}))}return[i,r]}static crossOverPBX(t,e){let i,r,o;return s.rand()>n.crossOverRate||t===e?(i=t.copyGenes(),r=e.copyGenes()):(s.assert(t.compatible(e),"Mismatched size of chromosomes."),o=t.size(),i=s.fill(o,null),r=s.fill(o,null),s.shuffle(s.fill(o,(t=>t))).slice(0,s.toGoldenRatio(o)[1]).sort().forEach((s=>{i[s]=t.getGeneAt(s),r[s]=e.getGeneAt(s)})),r.forEach(((s,i)=>{if(null===s){t.applyGenes((t=>t.findIndex((t=>{if(r.indexOf(t)<0)return r[i]=t,!0}))))<0&&(r[i]=e.getGeneAt(i))}})),i.forEach(((s,r)=>{if(null===s){e.applyGenes((t=>t.findIndex((t=>{if(i.indexOf(t)<0)return i[r]=t,!0}))))<0&&(i[r]=t.getGeneAt(r))}})),s.assert(!i.some((t=>null===t)),"crossOverPBX null error"),s.assert(!r.some((t=>null===t)),"crossOverPBX null error")),[i,r]}static crossOverRND(t,e){s.assert(t.compatible(e),"Mismatched chromosome sizes");let i,r,o,h=t.size();if(s.rand()>n.crossOverRate||t===e)r=t.copyGenes(),o=e.copyGenes();else{i=s.randInt(h),r=[],o=[];for(let s=0;s<i;++s)r.push(t.getGeneAt(s)),o.push(e.getGeneAt(s));for(let s=i;s<h;++s)r.push(e.getGeneAt(s)),o.push(t.getGeneAt(s))}return[r,o]}static crossOverPMX(t,e){s.assert(t.compatible(e),"Mismatched chromosome sizes");t.size();let i=t.copyGenes(),r=e.copyGenes();if(s.rand()>n.crossOverRate||t===e);else{let[n,o]=s.randSpan(t.size());for(let h,a,l,c,u=n;u<o+1;++u)l=t.getGeneAt(u),c=e.getGeneAt(u),l!=c&&(h=i.indexOf(l),a=i.indexOf(c),h>=0&&a>=0&&s.swap(i,h,a),h=r.indexOf(l),a=r.indexOf(c),h>=0&&a>=0&&s.swap(r,h,a))}return[i,r]}static crossOverAtSplits(t,e){s.assert(t.compatible(e),"Mismatched chromosome sizes");let i,r,o=t.size();if(s.rand()>n.crossOverRate||t===e)i=t.copyGenes(),r=e.copyGenes();else{let[n,h]=s.randSpan(t.size());i=[],r=[];for(let s=0;s<o;++s)s<n||s>=h?(i.push(t.getGeneAt(s)),r.push(e.getGeneAt(s))):(i.push(e.getGeneAt(s)),r.push(t.getGeneAt(s)))}return[i,r]}}class c extends l{#y;constructor(t,e,s){super(t,e,s),this.recalcScore()}getScore(){return this.#y}updateScore(t){return this.#y=t,this}cmpScore(t){return this.#y>t?1:this.#y<t?-1:0}clone(){let[t,e]=this.getScoreCalcInfo();return new c(this.copyGenes(),t,e)}compareTo(t){return this.cmpScore(t.getScore())}}function u(t,e="cycles"){let i=t.startTime=s.now();return t[e]=0,i}function d(t){return t.endTime=s.now()}function g(t,e){let s,i=0;for(;i<t.length&&(s=t[i],!(s.getScore()==e.getScore()||e.getScore()<s.getScore()));++i);return i}function p(t,e,i,r,n){let o,h=5;for(;h--&&(o=s.randInt(e.length),o==t););let a,l,c=e[t],u=e[o];return r?[a,l]=r(c,u):(a=c.copyGenes(),l=u.copyGenes()),a=i(a),l=i(l),n&&(a.mutateWith(n),a.mutateWith(n)),a.compareTo(l)>=0?a:l}function f(t,{crossOver:e,create:r,mutate:o,cycles:h}){if(i.num(t))return s.fill(t,(()=>r()));t.sort(s.comparator(s.SORT_ASC,(t=>t.getScore()),(t=>t.getScore())));let a,l,c,u,d=t.slice(t.length-n.NUM_ELITES),g=m.calcStats(t);for(;d.length<t.length;)s.randSign()>0&&void 0!==n.TOURNAMENT_SIZE?(c=m.tournamentSelection(t,n.TOURNAMENT_SIZE),u=m.tournamentSelection(t,n.TOURNAMENT_SIZE)):(c=m.chromoRoulette(t,g.totalScore),u=m.chromoRoulette(t,g.totalScore)),e?[a,l]=e(c,u):(a=c.copyGenes(),l=u.copyGenes()),a=r(a),l=r(l),o&&(a.mutateWith(o),l.mutateWith(o)),d.push(a,l);for(;d.length>t.length;)d.pop();return d}const m={NeuronLayer:a,Neuron:h,NeuralNet:class{#_;#N;#w;#E;#v;#d;#x;get numOutputs(){return this.#w}get numInputs(){return this.#E}constructor(t,e,[i,r,o],h=null,l=!0){h=h||n.sigmoid,o=o||n.sigmoid,i=i||0,r=r||0,this.#x=function(n){if(i>0){n.push(new a(r,t,o,l));for(let t=0;t<i-1;++t)n.push(new a(r,r,o,l))}return s.conj(n,new a(e,i>0?r:t,h,l))}([]),this.#_=r,this.#N=i,this.#E=t,this.#w=e,this.#v=this.#x.reduce(((t,e)=>t+e.applyNeurons((t=>t.reduce(((t,e)=>t+e.numInputs()))))),0)}iterLayers(t,e){return this.#x.forEach(t,e),this}getLayer(t){return this.#x[t]}putWeights(t){s.assert(t.length>=this.#v,"bad input to putWeights");let e=0;this.#x.forEach((s=>s.iterNeurons((s=>s.iterWeights(((s,i,r)=>{r[i]=t[e++]}))))))}getWeights(){const t=[];for(let e,s=0,i=this.#N+1;s<i;++s)e=this.#x[s],e.iterNeurons((e=>e.iterWeights((e=>t.push(e)))));return t}getNumberOfWeights(){return this.#v}feedForward(t){return this.update(t)}update(t){s.assert(t.length>=this.#E,"invalid input size");let e=[];return this.#x.forEach(((s,i)=>{i>0&&(t=e),e=s.update(t)})),s.assert(e.length==this.#w,"out length incorrect")?e:[]}calcSplitPoints(){let t=[],e=0;return this.#x.forEach((s=>s.iterNeurons((s=>{e+=s.numInputs(),t.push(e-1)})))),t}},ChromoNumero:c,Chromosome:l,NeuralGA:class{#k;#b;#S;#M;constructor(t,{create:e,mutate:s,crossOver:i}){this.#b={create:e,mutate:s,crossOver:i},this.#k=1,this.#S=t,this.#M=f(t,this.#b)}curGen(){return this.#k}epoch(t){return s.assert(t.length==this.#M.length,"GA::Epoch(scores/ chromosomes mismatch)!"),this.#M.forEach(((e,s)=>e.updateScore(t[s]))),this.#M=f(this.#M,this.#b),this.#k+=1,this.createPhenotypes()}createPhenotypes(){return this.#M}},runGASearch(t,e){let i,r,n=u(e),o=e.maxCycles||100,h=1e3*(e.maxSeconds||30),a=function*([t,e],{mutate:i,create:r,maxAge:n,poolSize:o,crossOver:h}){let a,l=r();yield l;let c,u,d,f,m,y=[l],_=[l];o=o||1,n=n||50;for(let t=0;t<o-1;++t)a=r(),a.compareTo(l)>0&&(yield l=a,_.push(a)),y.push(a);for(m=o-1,f=1;;)if(s.now()-t>e&&(yield l),f=f>0?f-1:m,a=y[f],u=p(f,y,r,h,i),a.compareTo(u)>0){if(void 0===n)continue;if(a.age+=1,n>a.age)continue;if(d=g(_,u,_.length),c=d/_.length,s.rand()<Math.exp(-c)){y[f]=u;continue}l.age=0,y[f]=l}else u.compareTo(a)>0?(u.age=0,y[f]=u,u.compareTo(l)>0&&(yield l=u,_.push(l))):(u.age=a.age+1,y[f]=u)}([n,h],e);for(;;){if(i=a.next().value,r=d(e),r-n>h){r=null;break}if(i.cmpScore(t)>=0)break;if(e.cycles>=o)break;e.cycles+=1}return[null===r,i]},runGACycle(t,e){let i,r,{maxCycles:n,targetScore:o,maxSeconds:h}=e,a=u(e),l=1e3*(h||30);for(n=n||100;;){if(t=f(t,e),r=d(e),r-a>l){r=null;break}if(i=m.calcStats(t),s.echt(o)&&i.bestScore>=o)break;if(e.cycles>=n)break;e.cycles+=1}return[null===r,t]},hillClimb(t,e,i,r,n,o){let h,a,l=u(o),c=1e3*(o.maxSeconds||30),g=t(n,o);for(;!i(g);)if(a=t(r(g),o),e(g,a)&&(g=a),s.now()-l>c){h=!0;break}return d(o),[h,g]},getChromoRoulette(t,e){let i=0,r=s.rand()*e;return t.find((t=>(i+=t.getScore(),i>=r)))},chromoRoulette(t,e){let i=0,r=s.rand(),n=t.map((t=>i+=t.getScore()/e));for(let e=0;e<n.length-1;++e)if(r>=n[e]&&r<=n[e+1])return t[e];return t[0]},tournamentSelectionN(t,e){let i=0,r=-1/0;for(let n,o,h=0;h<e;++h)n=s.randInt(t.length),o=t[n].getScore(),o>r&&(i=n,r=o);return t[i]},tournamentSelection(t){let[e,i]=s.randSpan(t);return s.rand()<n.probTournament?t[e].getScore()>t[i].getScore()?t[e]:t[i]:t[e].getScore()<t[i].getScore()?t[e]:t[i]},calcStats(t){let e=-1/0,s=1/0,i=new o;return t.forEach((t=>{t.getScore()>e?(e=t.getScore(),i.bestScore=e,i.alpha=t):t.getScore()<s&&(s=t.getScore(),i.worstScore=s),i.totalScore+=t.getScore()})),i.avgScore=i.totalScore/t.length,i},fitnessScaleRank:t=>(t.sort(s.comparator(s.SORT_ASC,(t=>t.getScore()),(t=>t.getScore()))),t.forEach(((t,e)=>t.updateScore(e))),m.calcStats(t)),fitnessScaleSigma(t,e){let s=t.reduce(((t,s)=>t+Math.pow(s.getScore()-e.avgScore,2)),0)/t.length,i=Math.sqrt(s),r=2*i;return t.forEach((t=>t.updateScore((t.getScore()-e.avgScore)/r))),[i,m.calcStats(t)]},fitnessScaleBoltzmann(t,e){(e-=Parmas.BOLTZMANN_DT)<Parmas.MIN_TEMP&&(e=Parmas.MIN_TEMP);let s=[],i=t.reduce(((t,i,r)=>(r=Math.exp(i.getScore()/e),s.push(r),t+r)),0)/t.length;return t.forEach(((t,e)=>t.updateScore(s[e]/i))),[e,calcStats(t)]},showBest(t,e,i){console.log(s.fill(80,"-").join("")),console.log("total time: "+s.prettyMillis(e.endTime-e.startTime)),i&&console.log("time expired"),console.log("total generations= "+e.cycles),console.log("fitness score= "+t.getScore()),console.log("best="+t.applyGenes((t=>t.join(",")))),console.log(s.fill(80,"-").join(""))},config:t=>s.inject(n,t)};return m}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud").Core):t["io/czlab/mcfud/algo/NNetGA"]=e}(this),function(t){"use strict";function e(e){const s=e?e.Core:t["io/czlab/mcfud/core"](),{u:i,is:r}=(e?e.Math:t["io/czlab/mcfud/math"](),Math.floor,s),o={ALPHA:.1,GAMMA:.95,MAX_EPSILON:1,DECAY_RATE:.001,MIN_EPSILON:.05,MAX_STEPS:250,EPISODES:1e3,SECS_PER_EPISODE:30};return{Environment:class{#T;constructor(t){this.#T=Object.freeze(i.inject({},o,t))}getVars(){return this.#T}reset(){i.assert(!1,"Please implement reset()")}actionSpace(){i.assert(!1,"Please implement actionSpace()")}getState(){i.assert(!1,"Please implement getState()")}step(t){i.assert(!1,"Please implement step()")}},QLAgent:class{#I;#O;#A;#z;#D;#q;#R;constructor(t,e,s,r,n,o){this.#I=r,this.#O=s,this.#D=n,this.#A=t,this.#z=e,this.#q=new Map,this.#R=o??i.inject({},o),this.#R.randActionFunc||(this.#R.randActionFunc=function(t){return i.randItem(t)})}#C(t){return r.str(t)||r.num(t)||r.bool(t)?t:JSON.stringify(t)}#P(t){let e=this.#C(t);return this.#q.has(e)||this.#q.set(e,new Map),this.#q.get(e)}#L(t,e,s=0){let i=this.#P(t);return i.has(e)?i.get(e):s}getQValue(t,e){return this.#L(t,e)}updateQValue(t,e,s,i){let r=this.getQValue(t,e),n=this.#P(s).keys().toArray().sort().map((t=>this.getQValue(s,t))),o=n.length>0?function(t){let e=-1/0,s=-1;return t.forEach(((t,i)=>{t>e&&(e=t,s=i)})),[s,e]}(n)[1]:0,h=r+this.#A*(i+this.#z*o-r);this.#P(t).set(e,h)}getAction(t,e){if(i.rand()<this.#I){let t=this.#R.randActionFunc(e);return console.log(`Getting next random action... ${t}`),t}let s=-1/0,r=e.reduce(((e,i,r)=>(r=this.getQValue(t,i),e.push([i,r]),r>s&&(s=r),e)),[]).filter((t=>t[1]==s)),n=i.randItem(r)[0];return console.log(`Getting bellman's next action... ${n} with epsilon = ${this.#I}`),n}decayEpsilon(t){this.#I=this.#O+(this.#I-this.#O)*Math.exp(-this.#D*t)}prnQTableAsObj(){let t={};return this.#q.keys().toArray().sort().forEach((e=>{let s={},i=this.#q.get(e);t[e]=s,i.keys().toArray().sort().forEach((t=>{s[t]=i.get(t)}))})),JSON.stringify(t)}prnQTable(){let t=[];return this.#q.keys().toArray().sort().forEach((e=>{let s,i=this.#q.get(e);i.keys().toArray().sort().forEach((r=>{s=i.get(r),t.push(`${e},${r},${s}`)}))})),t.join("\n")}save(){return this.prnQTable()}load(t){let e,s,i=t.split("\n");e=new Map,i.forEach((t=>{s=t.split(","),e.has(s[0])||e.set(s[0],new Map),n=e.get(s[0]),n.set(s[1],s[2])})),this.#q=e}}}}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/DQL"]=e}(this),function(t){"use strict";function e(e){const s=e?e.Core:t["io/czlab/mcfud/core"](),i=e?e.Math:t["io/czlab/mcfud/math"](),{is:r,u:n}=s;function o(t,e,s){return e>t.length-1?t:`${t.substr(0,e)}${s}${t.substr(e+1)}`}function h(t,e){return+t.charAt(e)}class a{static DV={n:1,s:2,e:4,w:8};static DX={e:1,w:-1,n:0,s:0};static DY={e:0,w:0,n:-1,s:1};static OPPOSITE={e:"w",w:"e",n:"s",s:"n"};constructor(t,e){this.COLS=t,this.ROWS=e,this._getEntryNodes()}_getEntryNodes(){let t={},e=2*this.ROWS+1-2,s=2*this.COLS+1-2;t.start={x:1,y:1,gate:{x:0,y:1}},t.end={x:s,y:e,gate:{x:s+1,y:e}},this.entryNodes=t}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}generate(){this.grid=this._walk(0,0,n.fill(this.ROWS,(()=>n.fill(this.COLS,0))))}canSouth(t){return!!(t&a.DV.s)}canEast(t){return!!(t&a.DV.e)}toAscii(){let t=this.grid,e=t.length,s=[],i=t[0].length;for(let r,n=0;n<e;++n){r="|";for(let e=0;e<i;++e)r+=this.canSouth(t[n][e])?" ":"_",this.canEast(t[n][e])?r+=this.canSouth(t[n][e]|t[n][e+1])?" ":"_":r+="|";s.push(r)}return s.unshift("_".repeat(s[0].length)),s.join("\n")}_walk(t,e,s){let i,r;return n.shuffle(["n","s","e","w"]).forEach((n=>{i=t+a.DX[n],r=e+a.DY[n],r>=0&&r<s.length&&i>=0&&i<s[r].length&&0==s[r][i]&&(s[e][t]|=a.DV[n],s[r][i]|=a.DV[a.OPPOSITE[n]],this._walk(i,r,s))})),s}toGrid(){let t,e,s=this.grid,i=s.length,r=[],o=s[0].length;for(let n,h=0;h<i;++h){t=[],e=[],n=0,t[n]=1,e[n]=1;for(let i=0;i<o;++i)++n,this.canSouth(s[h][i])?(t[n]=0,e[n]=0):(t[n]=0,e[n]=1),++n,this.canEast(s[h][i])?(t[n]=0,e[n]=1):(t[n]=1,e[n]=1);r.push(t,e)}return r.unshift(n.fill(r[0].length,1)),r}}return{Maze1:class{constructor(t,e,s="D",i={}){let{bias:r,removeWalls:n,maxWallsRemove:o}=i;this.bias=r||"",this.removeWalls=n||0,this.maxWallsRemove=o||300,this.ROWS=t,this.COLS=e,this.matrix=[],this.entryNodes=this.getEntryNodes(s)}generate(){this.getMatrix(this.parseMaze(n.fill(this.COLS*this.ROWS,(()=>"01111")))),this.removeMazeWalls()}toAscii(){return""}getIO(){let t=this.entryNodes.end.gate,e=this.entryNodes.start.gate;return{start:[e.x,e.y],end:[t.x,t.y]}}toGrid(){let t,e=[];return this.matrix.forEach(((s,i)=>{t=[];for(let e=0;e<s.length;++e)t[e]="1"==s.charAt(e)?1:0;e.push(t)})),e}parseMaze(t){const e={n:1,s:2,w:3,e:4},s={n:2,s:1,w:4,e:3};let r,a,l,c=0,u=[],d=0,g=3,p=t.length-1,f=n.randInt(t.length);for(this.bias&&("H"==this.bias?g=this.COLS/100>=1?i.ndiv(this.COLS,100)+2:3:"V"==this.bias&&(g=this.ROWS/100>=1?i.ndiv(this.ROWS,100)+2:3)),t[f]=o(t[f],0,1);c<p;)if(++d,r=this.getNeighbours(f),l=Object.keys(r).filter((e=>-1!=r[e]&&!h(t[r[e]],0))),this.bias&&d!=g?l=this.biasDirections(l):d=0,l.length)++c,l.length>1&&u.push(f),a=l[n.randInt(l.length)],t[f]=o(t[f],e[a],0),f=r[a],t[f]=o(t[f],s[a],0),t[f]=o(t[f],0,1);else{if(0==u.length)break;f=u.pop()}return t}getMatrix(t){let e="",s="",i=this.COLS*this.ROWS;n.assert(t.length==i,"invalid nodes");for(let r=0;r<i;++r){if(e+=0==e.length?"1":"",s+=0==s.length?"1":"",h(t[r],1))e+="11",s+=h(t[r],4)?"01":"00";else{let i=t.hasOwnProperty(r-this.COLS)&&h(t[r-this.COLS],4),n=t.hasOwnProperty(r+1)&&h(t[r+1],1);h(t[r],4)?(e+="01",s+="01"):n||i?(e+="01",s+="00"):(e+="00",s+="00")}(r+1)%this.COLS==0&&(this.matrix.push(e,s),e="",s="")}this.matrix.push("1".repeat(2*this.COLS+1))}getEntryNodes(t){let e={},s=2*this.ROWS+1-2,i=2*this.COLS+1-2;if("D"==t&&(e.start={x:1,y:1,gate:{x:0,y:1}},e.end={x:i,y:s,gate:{x:i+1,y:s}}),"H"==t||"V"==t){let r="H"==t?s:i;r=(r-1)/2;let n=r%2==0;r=n?r+1:r;let o="H"==t?1:r,h="H"==t?r:1,a="H"==t?i:n?o:o+2,l="H"==t?n?h:h+2:s,c="H"==t?{x:0,y:h}:{x:o,y:0},u="H"==t?{x:i+1,y:l}:{x:a,y:s+1};e.start={x:o,y:h,gate:c},e.end={x:a,y:l,gate:u}}return e}biasDirections(t){let e=-1!=t.indexOf("w")||-1!=t.indexOf("e"),s=-1!=t.indexOf("n")||-1!=t.indexOf("s");return"H"==this.bias&&e?t.filter((t=>"w"==t||"e"==t)):"V"==this.bias&&s?t.filter((t=>"n"==t||"s"==t)):t}getNeighbours(t){return{w:t>0&&t%this.COLS!=0?t-1:-1,e:(t+1)%this.COLS!=0?t+1:-1,n:t-this.COLS>=0?t-this.COLS:-1,s:this.COLS*this.ROWS>t+this.COLS?t+this.COLS:-1}}removeWall(t,e){const s=t%2==0,i=e%2==0;if(!h(this.matrix[t],e))return!1;if(!s&&i){const s=t-2>0&&1==h(this.matrix[t-2],e),i=t+2<this.matrix.length&&1==h(this.matrix[t+2],e);if(s&&i)return this.matrix[t]=o(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==h(this.matrix[t-1],e-1),i=1==h(this.matrix[t-1],e+1);if(s||i)return this.matrix[t]=o(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==h(this.matrix[t+1],e-1),i=1==h(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=o(this.matrix[t],e,"0"),!0}}else if(s&&!i){const s=1==h(this.matrix[t],e-2),i=1==h(this.matrix[t],e+2);if(s&&i)return this.matrix[t]=o(this.matrix[t],e,"0"),!0;if(!s&&i){const s=1==h(this.matrix[t-1],e-1),i=1==h(this.matrix[t+1],e-1);if(s||i)return this.matrix[t]=o(this.matrix[t],e,"0"),!0}else if(!i&&s){const s=1==h(this.matrix[t-1],e+1),i=1==h(this.matrix[t+1],e+1);if(s||i)return this.matrix[t]=o(this.matrix[t],e,"0"),!0}}}removeMazeWalls(){if(0==this.removeWalls||0==this.matrix.length)return;let t,e,s=0,i=this.matrix.length-1,r=this.maxWallsRemove;for(;s<r&&(++s,!(this.wallsRemoved>=this.removeWalls));){let s=n.randInt2(1,i);s=s==i?s-1:s,e=[],t=this.matrix[s];for(let s=0;s<t.length;s++)0!=s&&s!=t.length-1&&h(t,s)&&e.push(s);n.shuffle(e);for(let t=0;t<e.length;t++)if(this.removeWall(s,e[t])){++this.wallsRemoved;break}}}},Maze2:a}}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/maze"]=e}(this),function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:i}=s;class r{constructor(t,s){this.state=e,this.other=s,this.cur=t}clone(t){const e=new r;return e.state=t(this.state),e.other=this.other,e.cur=this.cur,e}}const n=(t,e,s,i)=>t.evalScore(e,s,i);function o(t,s,r,h,a,l,c){if(0==r||t.isOver(s))return[n(t,s,r,h),e];let u=s,d=t.getStateCopier(),g=i.shuffle(t.getNextMoves(s));if(c){let e,n,p=g[0],f=-1/0;for(let m=0;m<g.length&&(t.undoMove||(i.assert(d,"Missing state copier!"),s=u.clone(d)),n=g[m],t.makeMove(s,n),e=o(t,s,r-1,h,a,l,!c)[0],t.undoMove&&t.unmakeMove(s,n),e>f&&(f=e,p=n),!(l<=(a=Math.max(e,a))));++m);return[f,p]}{let e,n,p=g[0],f=1/0;for(let m=0;m<g.length&&(t.undoMove||(i.assert(d,"Missing state copier!"),s=u.clone(d)),n=g[m],t.makeMove(s,n),e=o(t,s,r-1,h,a,l,!c)[0],t.undoMove&&t.unmakeMove(s,n),e<f&&(f=e,p=n),!((l=Math.min(e,l))<=a));++m);return[f,p]}}const h={algo:"minimax",GFrame:r,GameBoard:class{constructor(){this.aiActor=e}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t,e,s){}isStalemate(t){}isOver(t,e){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}takeGFrame(){}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=h.evalMiniMax(this)),s}},evalMiniMax(t){const e=t.takeGFrame(),s=t.depth;let[r,n]=o(t,e,s,s,-1/0,1/0,!0);return i.nichts(n)&&console.log(`evalMiniMax: score=${r}, pos= ${n}`),n}};return h}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud").Core):t["io/czlab/mcfud/algo/minimax"]=s}(this),function(t,e){"use strict";function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:i}=s;class r{constructor(t,s){this.lastBestMove=e,this.state=e,this.other=s,this.cur=t}clone(t){const e=new r;return e.state=t(this.state),e.lastBestMove=this.lastBestMove,e.other=this.other,e.cur=this.cur,e}}function n(t,e,s,i){return t.evalScore(e,s,i)*(1+.001*s)}function o(t,e,s,r,h,a){if(0==s||t.isOver(e))return{depth:s,value:n(t,e,s,r)};let l=e,c=t.getStateCopier(),u=i.shuffle(t.getNextMoves(e));for(let n,d,g=0;g<u.length;++g)if(d=u[g],t.undoMove||(i.assert(c,"Missing state copier!"),e=l.clone(c)),t.makeMove(e,d),n=o(t,e,s-1,r,{value:-a.value,move:a.move},{value:-h.value,move:h.move}),t.undoMove&&t.unmakeMove(e,d),n.value=-n.value,n.move=d,n.value>h.value&&(h={value:n.value,move:d,depth:n.depth}),h.value>=a.value)return a;return JSON.parse(JSON.stringify(h))}function h(t,e,s,r,o,a){if(0==s||t.isOver(e))return[n(t,e,s,r),null];let l=i.shuffle(t.getNextMoves(e)),c=t.getStateCopier(),u=e,d=-1/0,g=l[0];s==r&&(u.lastBestMove=g);for(let n,p,f=0;f<l.length&&(t.undoMove||(i.assert(c,"Missing state copier!"),e=u.clone(c)),p=l[f],t.makeMove(e,p),n=-h(t,e,s-1,r,-a,-o)[0],t.undoMove&&t.unmakeMove(e,p),d<n&&(d=n,g=p),!(o<n&&(o=n,s==r&&(u.lastBestMove=p),o>=a)));++f);return[d,u.lastBestMove]}const a={algo:"negamax",GFrame:r,GameBoard:class{constructor(){}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t){}isStalemate(t){}isOver(t){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}takeGFrame(){}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=a.evalNegaMax(this)),s}},XXevalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let[r,n]=h(t,e,s,s,-1/0,1/0);return i.nichts(n)&&console.log(`evalNegaMax: score=${r}, pos= ${n}, lastBestMove=${n}`),n},evalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let{value:r,move:n}=o(t,e,s,s,{value:-1/0},{value:1/0});return i.nichts(n)&&console.log(`evalNegaMax: score= ${r}, pos= ${n}`),n}};return a}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud").Core):t["io/czlab/mcfud/algo/negamax"]=s}(this),function(t){"use strict";function e(e){const s=e?e.Core:t["io/czlab/mcfud/core"](),i=e?e.Math:t["io/czlab/mcfud/math"](),r=Math.floor,{u:n,is:o}=s,h=0,a=1,l=2,c=3,u={nextInnov:42,BIAS:1,probMutateWeight:.1,probMutateLink:.8,probAddLink:.05,probAddNode:.01,probCancelLink:.75,maxPerturbation:50,crossOverRate:.25,staleLimit:15,excessCoeff:1,weightDiffCoeff:.5,compatibilityThreshold:3};class d{#$;#V;#G;#K;#j;get from(){return this.#$}get to(){return this.#V}get weight(){return this.#K}get innovID(){return this.#G}set weight(t){this.#K=t}get enabled(){return this.#j}turnOff(){return this.#j=!1,this}turnOn(){return this.#j=!0,this}toggle(t){return this.#j=t,this}constructor(t,e,s,i,r=!0){this.#$=t,this.#V=e,this.#K=s,this.#G=i,this.#j=!1!==r}mutate(){return this.#K=n.rand()<u.probMutateWeight?n.randMinus1To1():i.clamp(-1,1,this.#K+n.randGaussian()/u.maxPerturbation),this}clone(t,e){return new d(t,e,this.#K,this.#G,this.#j)}}class g{#B;#F;#H;#G;constructor(t,e,s,i){this.#B=t,this.#F=e,this.#G=s,n.append(this.#H=[],i,!0)}size(){return this.#H.length}matches(t,e,s){return t.size()==this.size()&&e.id==this.#B&&s.id==this.#F&&t.match(this.#H)}}class p{#U;constructor(){this.#U=[]}getAt(t){return this.#U[t]}find(t){return this.#U.find(t)}append(t){return this.#U.push(t),this}}class f{#W;#X;#Q;#J;#Y;#Z;get output(){return this.#W}set output(t){this.#W=t}get inputSum(){return this.#Q}get id(){return this.#Z}get type(){return this.#Y}get layer(){return this.#J}static checkSibling(t,e){return t.layer<e.layer?-1:t.layer>e.layer?1:0}static isSibling(t,e){return t.layer==e.layer}constructor(t,e,s){this.#X=[],this.#Q=0,this.#W=0,this.#J=s,this.#Y=e,this.#Z=t}moveTo(t){return this.#J=t,this}flush(){return n.trunc(this.#X),this.#W=0,this.#Q=0,this}resetInput(t){return this.#Q=t,this}addInput(t){return this.#Q+=t,this}addOutLink(t){return this.#X.push(t),this}activate(){return this.#J!=h&&(this.#W=this.#tt(this.#Q)),this.#X.forEach((t=>t.enabled?t.to.addInput(t.weight*this.#W):0)),this}#tt(t){return 1/(1+Math.pow(Math.E,-4.9*t))}_olinks(){return this.#X}isLinked(t){let e=f.checkSibling(t,this);return e<0?t._olinks().find((t=>t.to.id==this.id)):e>0&&this.#X.find((e=>e.to.id==t.id))}clone(){return new f(this.#Z,this.#Y,this.#J)}}class m{#et;#st;#it;#rt;#nt;constructor(t){this.#it=t.copyNodes(),this.#rt=[],this.#nt=this.#it.reduce(((t,e)=>e.type==h?t+1:t),0),this.#et=this.#it.reduce(((t,e)=>e.type==a?t+1:t),0);for(let e=0;e<t.depth;++e)this.#it.forEach((t=>{t.type==l&&(this.#st=t),t.layer==e&&this.#rt.push(t)}));n.assert(this.#st,`no bias? with depth= ${t.depth}`)}compute(t){return this.update(t)}update(t){n.assert(t.length==this.#nt,`update: expecting ${this.#nt} inputs but got ${t.length}`),this.#it.forEach(((e,s)=>e.type==h?e.output=t[s]:0)),this.#st.output=u.BIAS,this.#rt.forEach((t=>t.activate()));let e=this.#it.reduce(((t,e)=>e.type==a?t.push(e.output)&&t:t),[]);return this.#it.forEach((t=>t.resetInput(0))),e}}class y{#ot;#et;#nt;#f;#it;#x;#ht;#at;get depth(){return this.#x}constructor(t,e){this.#et=e,this.#nt=t,this.#lt()}#lt(){this.#f=[],this.#it=[],this.#x=0,this.#ot=1,this.#at=0}build(){this.#lt();for(let t=0;t<this.#nt;++t)this.#it.push(new f(this.#ct(),h,0));this.#x+=1;for(let t=0;t<this.#et;++t)this.#it.push(new f(this.#ct(),a,1));return this.#x+=1,this.#it.push(new f(this.#ct(),l,0)),this}geneAt(t){return this.#f[t]}nodeAt(t){return this.#it[t]}biasNode(){return this.#it.find((t=>t.type==l))}copyNodes(){return this.#it.map((t=>t))}isEmpty(){return 0==this.#f.length}size(){return this.#f.length}getScore(){return this.#at}setScore(t){return this.#at=t,this}getNode(t){return this.#it.find((e=>e.id==t))}#ut(){return this.#it.forEach((t=>t.flush())),this.#f.forEach((t=>t.from.addOutLink(t))),this}reify(){return this.#ut(),new m(this)}addLink(t){if(!this.#dt()){let e,s=n.randItem(this.#it),i=n.randItem(this.#it),r=(t,e)=>t.layer==e.layer||t.isLinked(e);for(;r(s,i);)s=n.randItem(this.#it),i=n.randItem(this.#it);s.layer>i.layer&&(e=i,i=s,s=e),this.#f.push(new d(s,i,n.randMinus1To1(),this.getInnov(t,s,i))),this.#ut()}return this}addNode(t){if(this.isEmpty())return this.addLink(t);let e,s=this.biasNode(),i=n.randItem(this.#f);for(;i.from.id==s.id&&this.size()>1;)i=n.randItem(this.#f);if(i.turnOff(),this.#it.push(e=new f(this.#ct(),c,2)),this.#f.push(new d(i.from,e,1,this.getInnov(t,i.from,e))),this.#f.push(new d(e,i.to,i.weight,this.getInnov(t,e,i.to))),e.moveTo(i.from.layer+1),this.#f.push(new d(s,e,0,this.getInnov(t,s,e))),f.isSibling(e,i.to)){for(let t,s=0;s<this.#it.length-1;++s)t=this.#it[s],f.checkSibling(t,e)>=0&&t.moveTo(t.layer+1);++this.#x}return this.#ut()}getInnov(t,e,s){let i=u.nextInnov,r=t.find((t=>t.matches(this,e,s)));return r||(t.append(new g(e.id,s.id,i,this.#f.map((t=>t.innovID)))),++u.nextInnov),r?r.innovID:i}#dt(){let t=0,e=[];for(let t=0;t<this.#x;++t)e[t]=0;this.#it.forEach((t=>e[t.layer]+=1));for(let s,i=0;i<this.#x-1;++i){s=0;for(let t=i+1;t<this.#x;++t)s+=e[t];t+=e[i]*s}return t<=this.size()}mutate(t){return this.isEmpty()&&this.addLink(t),n.rand<u.probMutateLink&&this.#f.forEach((t=>t.mutate())),n.rand()<u.probAddLink&&this.addLink(t),n.rand()<u.probAddNode&&this.addNode(t),this}_introspect(){let t=0,e=0;return this.#it.forEach((s=>{s.layer>t&&(t=s.layer),s.id>e&&(e=s.id)})),this.#ot=e+1,this.#x=t+1,this}cloneNode(t){return this.#it.push(t.clone()),this}cloneGene(t,e){return this.#f.push(t.clone(this.getNode(t.from.id),this.getNode(t.to.id)).toggle(e)),this}crossOver(t){let e=[],s=[],i=new y(this.#nt,this.#et);return this.#f.forEach((i=>{let r=!0,o=t.findGene(i.innovID);o?(i.enabled&&o.enabled||n.rand()<u.probCancelLink&&(r=!1),s.push(n.randAorB(i,o))):(r=i.enabled,s.push(i)),e.push(r)})),this.#it.forEach((t=>i.cloneNode(t))),s.forEach(((t,s)=>i.cloneGene(t,e[s]))),i._introspect().#ut()}findGene(t){return this.#f.find((e=>e.innovID==t))}clone(){let t=new y(this.#nt,this.#et);return this.#it.forEach((e=>t.cloneNode(e))),this.#f.forEach((e=>t.cloneGene(e,e.enabled))),t._introspect().#ut()}match(t){return this.#f.every((e=>t.includes(e.innovID)))}countMatching(t){let e=0;return this.#f.forEach((s=>t.findGene(s.innovID)?++e:0)),e}#ct(){return this.#ot++}}class _{#s;#gt;#pt;#A;#ft;get avgScore(){return this.#gt}get alpha(){return this.#A}get bestScore(){return this.#s}constructor(t){this.#s=t.getScore(),this.#A=t.clone(),this.#pt=[],this.#gt=0,this.#ft=0,this.#pt.push(t)}compatible(t){let e=this.#mt(t,this.#A),s=this.#yt(t,this.#A),i=t.size()-20;return i<1&&(i=1),u.compatibilityThreshold>u.excessCoeff*e/i+u.weightDiffCoeff*s}add(t){this.#pt.push(t)}#mt(t,e){return t.size()+e.size()-2*t.countMatching(e)}#yt(t,e){let s=0,i=0;for(let r=0;r<t.size();++r)for(let n=0;n<e.size();++n)if(t.geneAt(r).innovID==e.geneAt(n).innovID){++i,s+=Math.abs(t.geneAt(r).weight-e.geneAt(n).weight);break}return 0==i?t.isEmpty()||e.isEmpty()?0:100:s/i}sort(){return this.#pt.sort(n.comparator(n.SORT_DESC,(t=>t.getScore()),(t=>t.getScore()))),0==this.#pt.length?this.#ft=200:this.#pt[0].getScore()>this.#s?(this.#s=this.#pt[0].getScore(),this.#A=this.#pt[0].clone(),this.#ft=0):++this.stale,this}isEmpty(){return 0==this.#pt.length}size(){return this.#pt.length}setAverage(){return this.#gt=this.#pt.reduce(((t,e)=>t+e.getScore()),0)/this.size(),this}spawn(t){let e;if(n.rand()<u.crossOverRate)e=this.#_t().clone();else{let t=this.#_t(),s=this.#_t();e=t.getScore()<s.getScore()?s.crossOver(t):t.crossOver(s)}return e.mutate(t)}#_t(){let t=this.#pt.reduce(((t,e)=>t+e.getScore()),0)*n.rand(),e=0;return this.#pt.find((s=>{if(e+=s.getScore(),e>t)return!0}))||this.#pt[0]}cull(){if(this.#pt.length>2)for(let t=this.#pt.length/2;t<this.#pt.length;++t)this.#pt.splice(t,1),--t;return this}flush(){return n.trunc(this.#pt),this}normalize(){return this.#pt.forEach((t=>t.setScore(t.getScore()/this.size()))),this.#gt=this.#pt.reduce(((t,e)=>t+e.getScore()),0)/this.size(),this}}return{NeatGA:class{#w;#E;#U;#Nt;#wt;#Et;#vt;get popSize(){return this.#Et}constructor(t,e,s){this.#w=s,this.#E=e,this.#Et=t,this.#U=new p,this.#vt=1,this.#Nt=[],this.#wt=[];for(let i=0;i<t;++i)this.#Nt=n.fill(t,(()=>new y(e,s).build().mutate(this.#U)))}curGen(){return this.#vt}createPhenotypes(){return this.#Nt.map((t=>t.reify()))}epoch(t){1==this.#vt||this.#Nt[0];this.#xt(),this.#kt(t),this.#bt(),this.#St(),this.#Mt(),this.#Tt();let e=[],s=this.#It();for(this.#wt.forEach((t=>{e.push(t.alpha.clone());let i=r(t.avgScore/s*this.popSize)-1;for(let s=0;s<i;++s)e.push(t.spawn(this.#U))})),e.length<this.popSize&&e.push(this.#wt[0].alpha.clone());e.length<this.popSize;)e.push(this.#wt[0].spawn(this.#U));return n.append(this.#Nt,e,!0),this.#vt+=1,this.createPhenotypes()}#xt(){this.#wt.forEach((t=>t.flush())),this.#Nt.forEach(((t,e)=>{(e=this.#wt.find((e=>e.compatible(t))))?e.add(t):this.#wt.push(new _(t))}))}#kt(t){return this.#Nt.forEach(((e,s)=>e.setScore(t[s]))),this}#bt(){this.#wt.forEach((t=>t.sort())),this.#wt.sort(n.comparator(n.SORT_DESC,(t=>t.bestScore),(t=>t.bestScore)))}#Mt(){for(let t=2;t<this.#wt.length;++t)this.#wt[t].stale>=u.staleLimit&&(this.#wt.splice(t,1),--t)}#Tt(){let t=this.popSize,e=this.#It();for(let s=1;s<this.#wt.length;++s)this.#wt[s].avgScore/e*t<1&&(this.#wt.splice(s,1),--s)}#It(){return this.#wt.reduce(((t,e)=>t+e.avgScore),0)}#St(){return this.#wt.forEach((t=>t.cull().normalize())),this}},Genome:y,Link:d,Node:f,Species:_,Innovation:g,InnovHistory:p,configParams:t=>n.inject(u,t)}}"object"==typeof module&&module.exports?module.exports=e(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/NEAT_CBullet"]=e}(this),function(t,e){"use strict";function s(s){const i=s?s.Core:t["io/czlab/mcfud/core"](),r=(s?s.Math:t["io/czlab/mcfud/math"](),Math.floor),{u:n,is:o}=i,h={INPUT:1,BIAS:2,HIDDEN:3,OUTPUT:4,NONE:911},a={NEURON:0,LINK:1},l={SNAPSHOT:7770,ACTIVE:8881},c={numInputs:0,numOutputs:0,BIAS:1,sigmoidResponse:1,addLinkAttempts:5,findLoopedLink:5,findOldLink:5,chanceAddLink:.07,chanceAddNode:.03,chanceRecurrent:-1,mutationRate:.8,maxWeightJiggle:.5,chanceSetWeight:.1,activationMutation:.1,maxActivationJiggle:.1,compatThreshold:.26,youngFitnessBonus:1.3,youngBonusAge:10,survivalRate:0,oldAgeThreshold:50,oldAgePenalty:.7,crossOverRate:.7,noImprovements:15,maxNNetNeurons:100,numBestElites:4,fitFunc:function(t=0){return new p(t)},sigmoid:function(t){return 1/(1+Math.exp(-t))}};function u(t){return t.neuronType==h.OUTPUT}function d(t){return t.neuronType==h.BIAS}function g(t,e=!1){return t.neuronType==h.INPUT||e&&t.neuronType==h.BIAS}class p{#Ot;constructor(t){this.#Ot=t}update(t){return this.#Ot=t,this}score(){return this.#Ot}clone(){return new p(this.#Ot)}}class f{#At;#zt;get x(){return this.#At}get y(){return this.#zt}constructor(t=0,e=0){this.#At=t,this.#zt=e}clone(){return new f(this.#At,this.#zt)}static dft(){return new f(0,0)}}function m(t){switch(t){case h.INPUT:return"input";case h.BIAS:return"bias";case h.HIDDEN:return"hidden";case h.OUTPUT:return"output"}n.assert(!1,`bad node type ${t}`)}class y{#n;#Dt;#Y;#qt;#Z;get activation(){return this.#n}get neuronType(){return this.#Y}get recur(){return this.#Dt}get id(){return this.#Z}get posY(){return this.#qt.y}get posX(){return this.#qt.x}set activation(t){this.#n=t}constructor(t,e,s=null,i=!1){n.assert(t>0,`creating a neuron with a bad id ${t}`),this.#qt=s?s.clone():f.dft(),this.#Dt=!0===i,this.#n=1,this.#Z=t,this.#Y=e}prn(){return`${m(this.#Y)}#[${this.#Z}]`}setRecur(t){return this.#Dt=t,this}clone(){const t=new y(this.#Z,this.#Y,this.#qt,this.#Dt);return t.activation=this.#n,t}}class _{#Rt;#Ct;#Dt;#j;#K;get fromNeuron(){return this.#Rt}get toNeuron(){return this.#Ct}get enabled(){return this.#j}get weight(){return this.#K}get recur(){return this.#Dt}set weight(t){this.#K=t}constructor(t,e,s=!0,i=null,r=!1){this.#Rt=t,this.#Ct=e,this.#Dt=!0===r,this.#j=!1!==s,this.#K=null===i||isNaN(i)?n.randMinus1To1():i}clone(){return new _(this.#Rt,this.#Ct,this.#j,this.#K,this.#Dt)}setRecur(t){return this.#Dt=t,this}setEnabled(t){return this.#j=t,this}}class N{#Pt;#Lt;#$t;#qt;#Vt;#Gt;#Kt;get innovType(){return this.#Pt}get neuronID(){return this.#$t}get IID(){return this.#Lt}get pos(){return this.#qt}get neuronIn(){return this.#Gt}get neuronOut(){return this.#Kt}get neuronType(){return this.#Vt}constructor(t,e,s,i,r=null,n=null){this.#qt=n?n.clone():f.dft(),this.#Lt=t.nextIID(),this.#Pt=i,this.#Gt=e,this.#Kt=s,o.vecN(r,2,!0)?(this.#$t=r[0],this.#Vt=r[1]):(this.#$t=-31,this.#Vt=h.NONE),t.add(this)}static from(t,e,s,i){return new N(t,-71,-99,a.NEURON,[e,s],i)}}class w{#jt;#Bt;#nt;#et;#Ft;#Ht;constructor(t,e){let s,[i,r]=function(t,e){return[1/(t+2),1/(e+1)]}(t,e),o=0;this.#jt=0,this.#Bt=0,this.#et=e,this.#nt=t,this.#Ht=[],this.#Ft=[];for(let e=0;e<t;++e)s={t:h.INPUT,id:++o,co:new f((e+2)*i,0)},this.#Ft.push(s),N.from(this,s.id,s.t,s.co);s={t:h.BIAS,id:++o,co:new f(i,0)},this.#Ft.push(s),N.from(this,s.id,s.t,s.co);for(let t=0;t<e;++t)s={t:h.OUTPUT,id:++o,co:new f((t+1)*r,1)},this.#Ft.push(s),N.from(this,s.id,s.t,s.co);n.assert(o==t+e+1,"bad history db ctor - mismatched neuron ids"),n.assert(o==this.#Ft.at(-1).id,"bad history db ctor - erroneous last neuron id"),this.#jt=o,e=this.#Ft.filter((t=>t.t==h.OUTPUT)),(t=this.#Ft.filter((t=>t.t!=h.OUTPUT))).forEach((t=>e.forEach((e=>new N(this,t.id,e.id,a.LINK)))))}sample(t,e){let s=this.#Ft.filter((t=>t.t!=h.OUTPUT)),i=this.#Ft.filter((t=>t.t==h.OUTPUT));return this.#Ft.forEach((e=>t.push(new y(e.id,e.t,e.co)))),s.forEach((t=>i.forEach((s=>e.push(new _(t.id,s.id)))))),this}#ct(){return++this.#jt}nextIID(){return++this.#Bt}check(t,e,s){n.assert(t>0&&e>0,`checking innov with bad neuron ids: from: ${t}, to: ${e}`);const i=this.#Ht.find((i=>i.innovType==s&&i.neuronIn==t&&i.neuronOut==e));return i?i.IID:-51}add(t){this.#Ht.push(t)}create(t,e,s,i=h.NONE,r=null){let o;return s==a.NEURON?(n.assert(i!=h.NONE,"create-innov: unexpected bad neuron type"),n.assert(t>0&&e>0,`create-innov: bad neuron ids: from: ${t} to: ${e}`),o=new N(this,t,e,s,[this.#ct(),i],r)):o=new N(this,t,e,s,null,r),o}createNeuronFromID(t){const e=this.#Ht.find((e=>e.neuronID==t));return e?new y(t,e.neuronType,e.pos):n.assert(!1,"unknown neuron id not found in history.")}getNeuronID(t){const e=this.#Ht.find((e=>e.IID==t));return e?e.neuronID:-41}getIID(t,e=a.LINK){return this.check(t.fromNeuron,t.toNeuron,e)}getInnov(t,e=a.LINK){return this.#Ht.find((s=>s.innovType==e&&s.neuronIn==t.fromNeuron&&s.neuronOut==t.toNeuron))}countInputs(){return this.#nt}countOutputs(){return this.#et}}class E{#K;#Ut;#Wt;#Dt;get weight(){return this.#K}get from(){return this.#Ut}constructor(t,e,s,i=!1){this.#K=t,this.#Ut=e,this.#Wt=s,this.#Dt=!0===i}clone(){return new E(this.#K,this.#Ut,this.#Wt,this.#Dt)}static from(t,e,s){const i=new E(t.weight,e,s,t.recur);return e.addLinkOut(i),s.addLinkIn(i),i}}class v{#Xt;#n;#Qt;#Vt;#$t;#Jt;#qt;get activation(){return this.#n}get neuronType(){return this.#Vt}get id(){return this.#$t}get output(){return this.#Jt}set output(t){this.#Jt=t}constructor(t,e,s,i){this.#qt=s?s.clone():f.dft(),this.#n=i,this.#Vt=e,this.#$t=t,this.#Jt=0,this.#Qt=[],this.#Xt=[]}_cpy(t,e,s){return this.#Xt=s.map((t=>t.clone())),this.#Qt=e.map((t=>t.clone())),this.#Jt=t,this}prn(){return`node(${m(this.#Vt)})#[${this.#$t}]`}flush(){return this.#Jt=0,this}clone(){return new v(this.#$t,this.#Vt,this.#qt,this.#n)._cpy(this.#Jt,this.#Qt,this.#Xt)}funcOverInLinks(t){return t(this.#Qt)}addLinkIn(t){return this.#Qt.push(t),this}addLinkOut(t){return this.#Xt.push(t),this}static from(t){return new v(t.id,t.neuronType,t.pos,t.activation)}}class x{#Yt;#Zt;constructor(t,e){n.append(this.#Yt=[],t,!0),this.#Zt=e,t.length=0}clone(){return new x(this.#Yt.map((t=>t.clone())),this.#Zt)}compute(t,e=l.ACTIVE){return this.update(t,e)}update(t,e=l.ACTIVE){let s,i,r=[],o=e==l.SNAPSHOT?this.#Zt:1;function h(t){return t.reduce(((t,e)=>t+e.weight*e.from.output),0)}for(;o--;){r.length=0,i=0,s=0;for(let e,r=0;r<this.#Yt.length&&(e=this.#Yt[r],g(e)?(n.assert(s<t.length,`NeuralNet: update with mismatched input size ${t.length}`),e.output=t[s++],s==t.length&&++i):d(e)&&(e.output=c.BIAS,++i),2!=i);++r);this.#Yt.forEach((t=>{g(t,!0)||(t.output=c.sigmoid(t.funcOverInLinks(h)/t.activation),u(t)&&r.push(t.output))}))}return e==l.SNAPSHOT&&this.#Yt.forEach((t=>t.flush())),r}}class k{#Yt;#te;#ee;#se;#U;#ie;#at;#re;#ne;#nt;#et;#wt;get spawnCnt(){return this.#ne}get adjScore(){return this.#re}get id(){return this.#ie}set spawnCnt(t){this.#ne=t}constructor(t,e){this.#at=c.fitFunc(0),this.#Yt=[],this.#te=[],this.#ie=e,this.#wt=0,this.#U=t,this.#re=0,this.#ne=0,this.#nt=t.countInputs(),this.#et=t.countOutputs(),e>0&&t.sample(this.#Yt,this.#te),this.#oe()}#oe(){this.#he(),this.#ee=[],this.#se=[],this.#ae(),this.#Yt.forEach((t=>g(t,!0)?this.#se.push(t):this.#ee.push(t)))}#le(){return this.#Yt.reduce(((t,e,s)=>t+(0==s?"":", ")+e.prn()),"")}#he(){0}dbgState(){return`{nodes=${this.#le()},links=${this.#te.length}}`}adjustScore(t){return this.#re=t,this}numNeurons(){return this.#Yt.length}numGenes(){return this.#te.length}setScore(t){return this.#at.update(t),this}getScore(){return this.#at.score()}geneAt(t){return this.#te[t]}neuronAt(t){return this.#Yt[t]}mutateGID(t){return n.assert(t>0,"bad genome id, must be positive"),this.#ie=t,this}_specialClone(t,e,s){return this.#ee=[],this.#se=[],e.forEach((t=>g(t,!0)?this.#se.push(t):this.#ee.push(t))),n.append(this.#Yt,e,!0),n.append(this.#te,s,!0),this.#ie=t,e.length=0,s.length=0,this}createPhenotype(t){const e=this.#Yt.map((t=>v.from(t)));return this.#te.forEach((t=>t.enabled?E.from(t,e.find((e=>e.id==t.fromNeuron)),e.find((e=>e.id==t.toNeuron))):0)),new x(e,t)}history(){return this.#U}#_t(){return n.randItem(this.#Yt)}#ce(){return n.randItem(this.#ee)}addLink(t,s,i,r){if(n.assert(i>=0,"bad param: triesToFindLoop"),n.assert(r>=0,"bad param: triesToAddLink"),n.rand()>t)return;let o,h,l,c=!1;if(n.rand()<s){for(;i--;)if(l=this.#ce(),!l.recur){l.setRecur(c=!0),o=h=l;break}}else for(;r--&&(h=this.#ce(),o=this.#_t(),o.id==h.id||this.#ue(o.id,h.id));)o=h=e;o&&h&&(o.posY>h.posY&&(c=!0),this.#U.check(o.id,h.id,a.LINK)<0&&this.#U.create(o.id,h.id,a.LINK),this.#te.push(new _(o.id,h.id,!0,n.randMinus1To1(),c)),this.#ae())}addNeuron(t,e){if(n.assert(e>=0,"bad param: triesToFindOldLink"),n.rand()>t)return;let s,i,o,l=-1,c=this.numGenes(),u=c-1-r(Math.sqrt(c)),g=t=>!t.enabled||t.recur||d(this.#de(t.fromNeuron))?-1:t.fromNeuron;if(c<this.#nt+this.#et+5)for(;l<0&&e--;)i=this.#te[n.randInt2(0,u)],l=g(i);else for(;l<0;)i=n.randItem(this.#te),l=g(i);if(l<0)return;n.assert(i,"addNeuron: unexpected null link gene!"),i.setEnabled(!1),s=i.toNeuron,n.assert(l>0&&s>0,`addNeuron: bad neuron ids: fromID: ${l}, toID: ${s}`);let p=i.weight,m=this.#de(s),N=this.#de(l),w=(v=N,x=m,n.assert(v&&x,`splitBetween: unexpected null params: from: ${v}, to: ${x}`),new f((v.posX+x.posX)/2,(v.posY+x.posY)/2)),E=this.#U.check(l,s,a.NEURON);var v,x;E>0&&this.#ge(this.#U.getNeuronID(E))&&(E=-1),E<0?(o=this.#U.create(l,s,a.NEURON,h.HIDDEN,w).neuronID,n.assert(o>0,`addNeuron: (+) unexpected -ve neuron id ${o}`),this.#U.create(l,o,a.LINK),this.#U.create(o,s,a.LINK)):(o=this.#U.getNeuronID(E),n.assert(o>0,`addNeuron: (x) unexpected -ve neuron id ${o}`)),n.assert(this.#U.check(l,o,a.LINK)>0&&this.#U.check(o,s,a.LINK)>0,"addNeuron: expected innovations"),this.#Yt.push(new y(o,h.HIDDEN,w)),this.#ee.push(this.#Yt.at(-1)),this.#te.push(new _(l,o,!0,1),new _(o,s,!0,p)),this.#ae()}#de(t){let e=this.#Yt.find((e=>e.id==t));return e||n.assert(!1,"Error in Genome::findNeuron")}#ue(t,e){return this.#te.some((s=>s.fromNeuron==t&&s.toNeuron==e))}#ge(t){return t>0&&this.#Yt.some((e=>e.id==t))}mutateWeights(t,e,s){this.#te.forEach((i=>{n.rand()<t&&(i.weight=n.rand()<e?n.randMinus1To1():i.weight+n.randMinus1To1()*s)}))}mutateActivation(t,e){this.#Yt.forEach((s=>{n.rand()<t&&(s.activation+=n.randMinus1To1()*e)}))}calcCompat(t){let e,s,i,r,n=0,o=0,h=0,a=0,l=0,c=0,u=this.numGenes(),d=t.numGenes();for(;n<u||o<d;)n>=u?(++o,++a):o>=d?(++n,++a):(r=t.geneAt(o),i=this.geneAt(n),s=this.#U.getIID(r),e=this.#U.getIID(i),e==s?(++n,++o,++l,c+=Math.abs(i.weight-r.weight)):(++h,e<s?++n:e>s&&++o));let g=Math.max(this.numGenes(),t.numGenes()),p=1*a/g+1*h/g;return l>0?p+.4*c/l:p}#ae(){return this.#te.sort(n.comparator(n.SORT_ASC,(t=>this.#U.getIID(t)),(t=>this.#U.getIID(t)))),this}_cpy(t,e,s,i,r,n,o){return this.#at=c.fitFunc(t.score()),this.#Yt=n.map((t=>t.clone())),this.#te=o.map((t=>t.clone())),this.#ne=i,this.#re=s,this.#wt=r,this.#ie=e,this.#oe(),this}clone(){return new k(this.#U,-1)._cpy(this.#at,this.#ie,this.#re,this.#ne,this.#wt,this.#Yt,this.#te)}morph(t){return this.#ie=t,this.numNeurons()<c.maxNNetNeurons&&this.addNeuron(c.chanceAddNode,c.findOldLink),this.addLink(c.chanceAddLink,c.chanceRecurrent,c.findLoopedLink,c.addLinkAttempts),this.mutateWeights(c.mutationRate,c.chanceSetWeight,c.maxWeightJiggle),this.mutateActivation(c.activationMutation,c.maxActivationJiggle),this}}class b{#pe;#ft;#m;#fe;#me;#ye;#s;get bestScore(){return this.#s}get id(){return this.#pe}get leader(){return this.#ye}get stale(){return this.#ft}get age(){return this.#m}constructor(t,e){this.#s=e.getScore(),this.#ye=e.clone(),this.#me=[e],this.#pe=t,this.#fe=0,this.#m=0,this.#ft=0}adjustScores(){return this.#me.forEach(((t,e,s)=>{e=t.getScore(),this.#m<c.youngBonusAge&&(e*=c.youngFitnessBonus),this.#m>c.oldAgeThreshold&&(e*=c.oldAgePenalty),t.adjustScore(e/s.length)})),this}addMember(t){return t.getScore()>this.#s&&(this.#s=t.getScore(),this.#ye=t.clone(),this.#ft=0),t.species=this.#pe,this.#me.push(t),this}purge(){return this.#me.length=0,this.#fe=0,++this.#ft,++this.#m,this}calcSpawnAmount(){return this.#fe=this.#me.reduce(((t,e)=>t+e.spawnCnt),0)}spawn(){let t,e,s=this.#me.length;return 1==s?e=this.#me[0]:(t=r(c.survivalRate*s)-1,t<0&&(t=1),t>=s&&(t=s-1),e=this.#me[n.randInt2(0,t)]),e.clone()}randPair(t=5){n.assert(t>=0,"bad param: tries must be positive");let s,i,o,h=this.#me.length;if(1==h)s=this.#me[0];else for(o=r(c.survivalRate*h)-1,o<0&&(o=1),o>=h&&(o=h-1),s=this.#me[n.randInt2(0,o)];t--&&(i=this.#me[n.randInt2(0,o)],s.id==i.id);)i=e;return i?[s,i]:[s,null]}numToSpawn(){return this.#fe}size(){return this.#me.length}}function S(t,e,s,i){const r=e-t;return i.push({val:t+r/2,depth:s+1}),s>6||(S(t,t+r/2,s+1,i),S(t+r/2,e,s+1,i)),i}return{NeatGA:class{#_e;#Ne;#we;#Ee;#ve;#k;#xe;#ke;#be;#Se;#S;#Me;constructor(t,e,s){this.#Ee=S(0,1,0,[]),this.#ve=[],this.#we=[],this.#_e=0,this.#Ne=0,this.#k=0,this.#S=t,this.#ke=0,this.#be=0,this.#Se=0,this.#Me=new w(e,s),this.#xe=n.fill(t,(()=>new k(this.#Me,this.#Te())))}curGen(){return this.#k}#Ie(t,e){let s,i,r,o,h,a=t.numGenes(),l=e.numGenes(),c=t.getScore()>=e.getScore(),u=[],d=[],g=0,p=0;for(;g!=a||p!=l;)g==a?(c||(s=e.geneAt(p)),++p):p==l?(c&&(s=t.geneAt(g)),++g):(i=t.geneAt(g),r=e.geneAt(p),o=this.#Me.getIID(i),h=this.#Me.getIID(r),o<h?(c&&(s=i),++g):h<o?(c||(s=r),++p):(s=n.randAorB(i,r),++g,++p)),n.assert(s,"crossOver: unexpected null as chosen"),0!=u.length&&this.#Me.getIID(u.at(-1))==this.#Me.getIID(s)||u.push(s.clone()),[s.fromNeuron,s.toNeuron].forEach((t=>d.indexOf(t)<0?d.push(t):0));return s=new k(this.#Me,-1)._specialClone(this.#Te(),d.sort().map((t=>this.#Me.createNeuronFromID(t))),u),s}#Oe(){return++this.#_e}#Te(){return++this.#Ne}tournamentSelection(t){let e,s,i=0;for(n.assert(t>=0,`tournamentSelection: bad arg value: ${t}`);t--;)s=n.randItem(this.#xe),s.getScore()>i&&(e=s,i=s.getScore());return e}calcNetDepth(t){let e=0;for(let s=0;s<t.numNeurons();++s)for(let i=0;i<this.#Ee.length;++i)t.neuronAt(s).posY==this.#Ee[i].val&&this.#Ee[i].depth>e&&(e=this.#Ee[i].depth);return e+2}#xt(){this.#xe.forEach(((t,e)=>{(e=this.#we.find((e=>t.calcCompat(e.leader)<=c.compatThreshold)))?e.addMember(t):this.#we.push(new b(this.#Oe(),t))})),this.#we.forEach((t=>t.adjustScores())),this.#xe.forEach((t=>this.#ke+=t.adjScore)),this.#be=this.#ke/this.#xe.length,this.#xe.forEach((t=>t.spawnCnt=t.adjScore/this.#be)),this.#we.forEach((t=>t.calcSpawnAmount())),this.#we.sort(n.comparator(n.SORT_DESC,(t=>t.bestScore),(t=>t.bestScore)))}#Ae(t){this.#xe.forEach(((e,s)=>e.setScore(t[s]))),this.#xe.sort(n.comparator(n.SORT_DESC,(t=>t.getScore()),(t=>t.getScore()))),this.#Se=Math.max(this.#Se,this.#xe[0].getScore()),this.#ve.length=0;for(let t=0;t<c.numBestElites;++t)this.#ve.push(this.#xe[t]);return this}#ze(){this.#ke=0,this.#be=0;let t=[];return this.#we.forEach((e=>{e.stale>c.noImprovements&&e.bestScore<this.#Se||t.push(e.purge())})),n.append(this.#we,t,!0),this}epoch(t){n.assert(t.length==this.#xe.length,"NeatGA::Epoch(scores/ genomes mismatch)!"),this.#ze()&&this.#Ae(t)&&this.#xt();let e,s=[],i=0;if(this.#we.forEach((t=>{if(i<this.#S){let r=!1,o=n.rounded(t.numToSpawn());for(;o--;){if(r)if(1==t.size()||n.rand()>c.crossOverRate)e=t.spawn();else{let[s,i]=t.randPair(5);e=i?this.#Ie(s,i):s.clone()}else r=!0,e=t.leader.clone();if(s.push(e.morph(this.#Te())),++i==this.#S)break}}})),i<this.#S){let t=this.#S-i;for(;t--;)s.push(this.tournamentSelection(r(this.#S/5)).clone())}return n.append(this.#xe,s,!0),++this.#k,this.createPhenotypes()}createPhenotypes(){return this.#xe.map((t=>t.createPhenotype(this.calcNetDepth(t))))}numSpecies(){return this.#we.length}bestFromPrevGen(){return this.#ve.map((t=>t.createPhenotype(this.calcNetDepth(t))))}},NeuralNet:x,Genome:k,NeuronGene:y,LinkGene:_,NLink:E,NNeuron:v,Species:b,FitFunc:p,InnovHistory:w,NeuronType:h,InnovType:a,RunType:l,configParams:t=>n.inject(c,t)}}"object"==typeof module&&module.exports?module.exports=s(require("@czlab/mcfud")):t["io/czlab/mcfud/algo/NEAT_Buckland"]=s}(this),function(){"use strict";console.log("@czlab/crafty version: 1.5.0")}();