!function(t,e,i){var s,r=256,n="random",o=i.pow(r,6),h=i.pow(2,52),l=2*h,a=255;function c(a,c,p){function m(){for(var t=w.g(6),e=o,i=0;t<h;)t=(t+i)*r,e*=r,i=w.g(1);for(;l<=t;)t/=2,e/=2,i>>>=1;return(t+i)/e}var y=[],_=f(function t(e,i){var s,r=[],n=typeof e;if(i&&"object"==n)for(s in e)try{r.push(t(e[s],i-1))}catch(t){}return r.length?r:"string"==n?e:e+"\0"}((c=1==c?{entropy:!0}:c||{}).entropy?[a,g(e)]:null==a?function(){try{var i;return s&&(i=s.randomBytes)?i=i(r):(i=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(i)),g(i)}catch(i){var n=t.navigator,o=n&&n.plugins;return[+new Date,t,o,t.screen,g(e)]}}():a,3),y),w=new u(y);return m.int32=function(){return 0|w.g(4)},m.quick=function(){return w.g(4)/4294967296},m.double=m,f(g(w.S),e),(c.pass||p||function(t,e,s,r){return r&&(r.S&&d(r,w),t.state=function(){return d(w,{})}),s?(i[n]=t,e):t})(m,_,"global"in c?c.global:this==i,c.state)}function u(t){var e,i=t.length,s=this,n=0,o=s.i=s.j=0,h=s.S=[];for(i||(t=[i++]);n<r;)h[n]=n++;for(n=0;n<r;n++)h[n]=h[o=a&o+t[n%i]+(e=h[n])],h[o]=e;(s.g=function(t){for(var e,i=0,n=s.i,o=s.j,h=s.S;t--;)e=h[n=a&n+1],i=i*r+h[a&(h[n]=h[o=a&o+e])+(h[o]=e)];return s.i=n,s.j=o,i})(r)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){for(var i,s=t+"",r=0;r<s.length;)e[a&r]=a&(i^=19*e[a&r])+s.charCodeAt(r++);return g(e)}function g(t){return String.fromCharCode.apply(0,t)}if(f(i.random(),e),"object"==typeof module&&module.exports){module.exports=c;try{s=require("crypto")}catch(c){}}else"function"==typeof define&&define.amd?define((function(){return c})):i["seed"+n]=c}("undefined"!=typeof self?self:this,[],Math),function(t,e,i){"use strict";function s(){const s=t,r=Math.floor,n=Array.prototype.slice,o=Object.prototype.toString;function h(t){return"[object Object]"==o.call(t)}function l(t){return"[object Function]"==o.call(t)}function a(t){return"[object Array]"==o.call(t)}function c(t){return"[object Map]"==o.call(t)}function u(t){return"[object Set]"==o.call(t)}function d(t){return"[object String]"==o.call(t)}function f(t){return"[object Number]"==o.call(t)}function g(t){return"[object Boolean]"==o.call(t)}function p(t){return t>0?t%2==0:-t%2==0}function m(t){return void 0===t}function y(t){return a(t)||c(t)||h(t)}let _=i?i():new Math.seedrandom;function w(t,e){for(let i,s=0;s<t.length;++s)if(i=t[s],!i[0](i[1]))throw new TypeError("wanted "+e);return!0}function x(t,e){for(let e,i=0;i<t.length;++i)if(e=t[i],e[0](e[1]))return!0;throw new TypeError("wanted "+e)}function k(t,e,i){if(t(e))return!0;throw new TypeError("wanted "+i)}const E=/(\/|\\\\)([^(\/|\\\\)]+)$/g,v=/(\.[^\.\/\?\\]*)(\?.*)?$/;function b(t,e){let i=v.exec(t);return i&&i[1]?(i=i[1].toLowerCase(),e||(i=i.substring(1))):i="",i}let N=0;function M(t,e,i){let s=t(e);switch(i.length){case 0:return s;case 1:return s&&t(i[0]);case 2:return s&&t(i[0])&&t(i[1]);case 3:return s&&t(i[0])&&t(i[1])&&t(i[2]);default:return s&&i.every(e=>t(e))}}const q={},z={fun:(t,...e)=>M(l,t,e),str:(t,...e)=>M(d,t,e),undef:(t,...e)=>M(m,t,e),map:(t,...e)=>M(c,t,e),set:(t,...e)=>M(u,t,e),num:(t,...e)=>M(f,t,e),bool:(t,...e)=>M(g,t,e),pos:t=>f(t)&&t>0,neg:t=>f(t)&&t<0,vec:(t,...e)=>M(a,t,e),obj:(t,...e)=>M(h,t,e),some:t=>T.size(t)>0,none:t=>0===T.size(t),own:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},T={error(...t){console.error(...t)},log(...t){console.log(...t)},srand(){_=i?i():new Math.seedrandom},feq0:t=>Math.abs(t)<1e-10,feq:(t,e)=>Math.abs(t-e)<1e-10,pack:t=>JSON.stringify(t),unpack:t=>JSON.parse(t),v2:(t=0,e=0)=>[t,e],p2:(t=0,e=0)=>({x:t,y:e}),numOrZero:t=>isNaN(t)?0:t,setVec(t,...e){e.forEach((e,i)=>t[i]=e)},evenN:(t,e)=>p(t=Math.floor(t))?t:e?t+1:t-1,nichts:t=>null==t,echt:t=>null!=t,nor:(t,e)=>null==t?e:t,or:(t,e)=>void 0===t?e:t,toNum(t,e){const i=parseFloat(t);return isNaN(i)&&f(e)?e:i},percentRemain:(t,e,i)=>(t>e&&(t=i?t%e:e),Math.max(0,e-t)/e),splitVerStr(t){const e=(""+(t||"")).split(".").filter(t=>t.length>0);return[this.toNum(e[0],0),this.toNum(e[1],0),this.toNum(e[2],0)]},cmpVerStrs(t,e){let i=this.splitVerStr(""+t),s=this.splitVerStr(""+e);return i[0]>s[0]?1:i[0]<s[0]?-1:i[1]>s[1]?1:i[1]<s[1]?-1:i[2]>s[2]?1:i[2]<s[2]?-1:0},pdef:t=>(t.configurable=!0)&&(t.enumerable=!0)&&t,findFiles:(t,e)=>t.filter(t=>e.indexOf(b(t,1))>-1),zipMap(t,e,i){let s=Math.min(t.length,e.length),r=i||new Map;for(let i=0;i<s;++i)r.set(t[i],e[i]);return r},zip(t,e,i){return this.zipMap(t,e,i)},zipObj(t,e,i){let s=Math.min(t.length,e.length),r=i||{};for(let i=0;i<s;++i)r[t[i]]=e[i];return r},partition(t,e){const i=[];for(let s,r,n=0;;){for(s=[],r=0;r<t;++r){if(!(n<e.length)){r=-1;break}s.push(e[n++])}if(s.length>0&&i.push(s),r<0)break}return i},keys:t=>c(t)?Array.from(t.keys()):h(t)?Object.keys(t):[],selectNotKeys(t,e){x([[c,t],[h,t]],"map/object");const i=c(t)?new Map:{};return e=this.seq(e),this.doseq(t,(t,s)=>!e.includes(s)&&this.assoc(i,s,t)),i},selectKeys(t,e){x([[c,t],[h,t]],"map/object");const i=c(t)?new Map:{};return this.seq(e).forEach(e=>{c(t)?t.has(e)&&i.set(e,t.get(e)):z.own(t,e)&&(i[e]=t[e])}),i},assertNot(t,...e){return this.assert(!t,...e)},assert(t,...e){if(!t)throw 0===e.length?"Assertion!":e.join("");return!0},noSuchKeys(t,e){return!this.some(this.seq(t),t=>this.has(e,t)?t:null)},randInt2:(t,e)=>function(t,e){return r(_()*(e-t+1)+t)}(t,e),randFloat:(t,e)=>t+_()*(e-t),randMinus1To1:()=>2*(_()-.5),randInt:t=>r(_()*t),rand:(t=!1)=>t?Math.random():_(),randSign:()=>_()>.5?-1:1,inst:(t,e)=>e instanceof t,hashCode(t){let e=0;for(let i=0;i<t.length;++i)e=Math.imul(31,e)+t.charCodeAt(i);return e},randSample(t,e=1){let i;if(1==e)i=[this.randItem(t)];else if(0==e)i=[];else if(e>0){let s=this.shuffle(t,!1);i=e>=s.length?s:s.slice(0,e)}return i},randItem(t,e){let i,s=-1;if(t)switch(t.length){case 0:case 1:i=t[s=0];break;case 2:i=t[s=this.randSign()>0?1:0];break;default:i=t[s=r(_()*t.length)]}return e?[i,s]:i},isPerc:t=>d(t)&&t.match(/^([0-9])(\.?[0-9]+|[0-9]*)%$/),isEven:t=>p(t),jsMap(...t){k(p,t.length,"even n# of args");let e=new Map;for(let i=0;i<t.length;)e.set(t[i],t[i+1]),i+=2;return e},jsObj(...t){k(p,t.length,"even n# of args");let e={};for(let i=0;i<t.length;)e[t[i]]=t[i+1],i+=2;return e},jsVec:(...t)=>0===t.length?[]:t.slice(),lastIndex:t=>a(t)&&t.length>0?t.length-1:-1,first(t){if(a(t)&&t.length>0)return t[0]},last(t){if(a(t)&&t.length>0)return t[t.length-1]},head(t){return this.first(t)},tail(t){return this.last(t)},floor:t=>Math.floor(t),ceil:t=>Math.ceil(t),abs:t=>Math.abs(t),sqrt:t=>Math.sqrt(t),min:(...t)=>Math.min(...t),max:(...t)=>Math.max(...t),slice:(t,e)=>n.call(t,e),every(t,e){k(a,t,"array");for(let i=0;i<t.length;++i)if(l(e)){if(!e(t[i]))return!1}else if(t[i]!=e)return!1;return t.length>0},notAny(t,e){k(a,t,"array");for(let i=0;i<t.length;++i)if(l(e)){if(e(t[i]))return!1}else if(t[i]===e)return!1;return t.length>0},copy(t,e=[]){w([[a,t],[a,e]],"arrays");const i=Math.min(t.length,e.length);for(let s=0;s<i;++s)t[s]=e[s];return t},append(t,e=[]){w([[a,t],[a,e]],"arrays");for(let i=0;i<e.length;++i)t.push(e[i]);return t},fill(t,e,...i){if(f(t)&&(t=new Array(t)),a(t))for(let s=0;s<t.length;++s)t[s]=l(e)?e(s,...i):e;return t},size(t){return a(t)||d(t)?t.length:u(t)||c(t)?t.size:t?this.keys(t).length:0},nextId:()=>++N,now:()=>Date.now(),fileExt:t=>b(t),fileBase(t){let e,i,s=t.indexOf("?");return s>0&&(t=t.substring(0,s)),t=t.replace(/(\/|\\\\)$/,""),i=E.exec(t),e="",i&&(e=i[2],s=e.lastIndexOf("."),s>0&&(e=e.substring(0,s))),e},range(t,e,i=1){1===arguments.length&&(e=t,t=0,i=1);let s=(e-t)/i;const r=[];s=Math.ceil(s),s=Math.max(0,s),r.length=s;for(let e=0;e<s;++e)r[e]=t,t+=i;return r},shuffle(t,e=!0){k(a,t,"array");const i=n.call(t,0);switch(i.length){case 0:case 1:break;case 2:if(this.randSign()>0){let t=i[0];i[0]=i[1],i[1]=t}break;default:for(let t,e,s=i.length-1;s>0;--s)e=r(_()*(s+1)),t=i[s],i[s]=i[e],i[e]=t}return e?this.copy(t,i):i},shuffle2(t,e=!0){if(k(a,t,"array"),t.length<3)t=this.shuffle(t,e);else{const e=t.length;n.call(t,0);for(let i,s,n=0;n<e;++n)s=n+r(_()*(e-n)),i=t[s],t[s]=t[n],t[n]=i}return t},uniq:t=>(k(a,t,"array"),Array.from(new Set(t))),map(t,e,i){if(k(y,t,"array/map/object"),a(t))return t.map(e,i);{const s=c(t)?new Map:{};return this.doseq(t,(r,n)=>{this.assoc(s,n,e.call(i,r,n,t))}),s}},find(t,e,i){let s,r=!0,o=n.call(arguments,3);return this.doseq(t,(t,n)=>{r&&e.apply(i,[t,n].concat(o))&&(s=[n,t],r=!1)}),s},some(t,e,i){let s,r=!0,o=n.call(arguments,3);return this.doseq(t,(t,n)=>{r&&(s=e.apply(i,[t,n].concat(o)),s?r=!1:s=void 0)}),s},invoke(t,e){let i=n.call(arguments,2);a(t)&&t.forEach(t=>t[e].apply(t,i))},delay:(t,e)=>setTimeout(e,t),timer:(t,e=0,i=!1)=>({repeat:!!i,id:i?setInterval(t,e):setTimeout(t,e)}),clear(t){t&&t.id?(t.repeat?clearInterval(t.id):clearTimeout(t.id),t.id=0):z.pos(t)&&clearTimeout(t)},dotimes(t,e,i,...s){for(let r=0;r<t;++r)e.call(i,r,...s)},rseq(t,e,i){if(k(a,t,"array"),t.length>0)for(let s=t.length-1;s>=0;--s)e.call(i,t[s],s,t)},doseq(t,e,i){a(t)?t.forEach(e,i):c(t)?t.forEach((s,r)=>e.call(i,s,r,t)):h(t)&&Object.keys(t).forEach(s=>e.call(i,t[s],s,t))},doseqEx(t,e,i){this.doseq(t,(s,r)=>null!=s&&e.call(i,s,r,t))},dissoc(t,e){if(arguments.length>2){let e,i=1;for(;i<arguments.length;++i)e=this.dissoc(t,arguments[i]);return e}{let i;return c(t)?(i=t.get(e),t.delete(e)):h(t)&&(i=t[e],delete t[e]),i}},get(t,e){if(void 0!==e){if(c(t))return t.get(e);if(t)return t[e]}},assoc(t,e,i){if(arguments.length>3){if((arguments.length-1)%2!=0)throw"wanted even count of args";let e,i=1;for(;i<arguments.length;)e=this.assoc(t,arguments[i],arguments[i+1]),i+=2;return e}{let s;return c(t)?(s=t.get(e),t.set(e,i)):t&&(s=t[e],t[e]=i),s}},disj(t,e){const i=t?t.indexOf(e):-1;return i>-1&&t.splice(i,1),i>-1},conj:(t,...e)=>(t&&e.forEach(e=>t.push(e)),t),seq:(t,e=/[,; \t\n]+/)=>("string"==typeof t&&(t=t.split(e).map(t=>t.trim()).filter(t=>t.length>0)),a(t)||(t=[t]),t),has(t,e){return 1!==arguments.length&&(c(t)?t.has(e):a(t)?-1!==t.indexOf(e):!!h(t)&&z.own(t,e))},patch(t,e){return k(h,t=t||{},"object"),e&&Object.keys(e).forEach(i=>{this.has(t,i)||(t[i]=e[i])}),t},clone(t){return t?this.unpack(this.pack(t)):t},inject:(t,...e)=>(t=t||{},e.forEach(e=>e&&function(t,e){let i=Object.keys(e).reduce((t,i)=>(t[i]=Object.getOwnPropertyDescriptor(e,i),t),{});return Object.getOwnPropertySymbols(e).forEach(t=>{let s=Object.getOwnPropertyDescriptor(e,t);s.enumerable&&(i[t]=s)}),Object.defineProperties(t,i),t}(t,e)),t),deepCopyArray(t){k(a,t,"array");const e=[];for(let i=0,s=t.length;i<s;++i)e[i]=a(t[i])?this.deepCopyArray(t[i]):t[i];return e},mergeEx(t,e){return this.merge(this.merge({},t),e)},merge(t,e){let i;return Object.keys(e).forEach(s=>{i=e[s],"object"==typeof i&&null!==i&&t[s]?("object"!=typeof t[s]&&(t[s]=i instanceof Array?[]:{}),this.merge(t[s],i)):t[s]=i}),t},throttle(t,e,i){let s=!0,r=!0;if("function"!=typeof t)throw new TypeError("Expected a function");return h(i)&&(s="leading"in i?!!i.leading:s,r="trailing"in i?!!i.trailing:r),this.debounce(t,e,{leading:s,trailing:r,maxWait:e})},debounce(t,e,i){let r,n,o,l,a,c,u=0,d=!1,f=!1,g=!0;const p=!e&&0!==e&&"function"==typeof s.requestAnimationFrame;if("function"!=typeof t)throw new TypeError("Expected a function");function m(e){const i=r,s=n;return r=n=void 0,u=e,l=t.apply(s,i),l}function y(t,e){return p?(s.cancelAnimationFrame(a),s.requestAnimationFrame(t)):setTimeout(t,e)}function _(t){const i=t-c;return void 0===c||i>=e||i<0||f&&t-u>=o}function w(){const t=Date.now();if(_(t))return x(t);a=y(w,function(t){const i=t-u,s=e-(t-c);return f?Math.min(s,o-i):s}(t))}function x(t){return a=void 0,g&&r?m(t):(r=n=void 0,l)}function k(...t){const i=Date.now(),s=_(i);if(r=t,n=this,c=i,s){if(void 0===a)return function(t){return u=t,a=y(w,e),d?m(t):l}(c);if(f)return a=y(w,e),m(c)}return void 0===a&&(a=y(w,e)),l}return e=+e||0,h(i)&&(d=!!i.leading,f="maxWait"in i,o=f?Math.max(+i.maxWait||0,e):o,g="trailing"in i?!!i.trailing:g),k.cancel=function(){void 0!==a&&function(t){if(p)return s.cancelAnimationFrame(t);clearTimeout(t)}(a),u=0,r=c=n=a=void 0},k.flush=function(){return void 0===a?l:x(Date.now())},k.pending=function(){return void 0!==a},k},negate:t=>(k(l,t,"function"),function(...e){return!t.apply(this,e)}),strPadRight:(t,e,i)=>(e-=t.length)>0?t+new Array(Math.ceil(e/i.length)+1).join(i).substr(0,e):t,strPadLeft:(t,e,i)=>(e-=t.length)>0?new Array(Math.ceil(e/i.length)+1).join(i).substr(0,e)+t:t,safeSplit:(t,e)=>(t||"").trim().split(e).filter(t=>t.length>0),capitalize:t=>t.charAt(0).toUpperCase()+t.slice(1),prettyNumber(t,e=2,i="0"){return this.strPadLeft(Number(t).toString(),e,i)},prettyMillis(t){let e,i,s=r(t/1e3);i=r(s/60),t-=1e3*s,s-=60*i,e=r(i/60),i-=60*e;let n=[];return n.push(`${s}.${t} secs`),(i>0||e>0)&&n.push(i+" mins, "),e>0&&n.push(e+" hrs, "),n.reverse().join("")},swap(t,e,i){let s=t[e];return t[e]=t[i],t[i]=s,t},listIndexesOf(t,e){let i=T.fill(t.length,t=>t);return e?this.shuffle(i):i},dropArgs:(t,e)=>t.length>e?n.call(t,e):[],isSSL:()=>t&&t.location&&t.location.protocol.indexOf("https")>=0,isMobile:t=>t&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(t.userAgent),isSafari:t=>t&&/Safari/.test(t.userAgent)&&/Apple Computer/.test(t.vendor),isCrossOrigin(e){let i=t;if(2===arguments.length&&911===arguments[1].hack&&(i=arguments[1]),i&&i.location&&e){const t=e.indexOf("://");if(t>0){let s=e.indexOf("/",t+3);return(s<0?e:e.substring(0,s))!=i.location.origin}}},addEvent(t,e,i,s){a(t)&&1===arguments.length?t.forEach(t=>this.addEvent.apply(this,t)):e.addEventListener(t,i,s)},delEvent(t,e,i,s){a(t)&&1===arguments.length?t.forEach(t=>this.delEvent.apply(this,t)):e.removeEventListener(t,i,s)}},S={qSelector:t=>e.querySelectorAll(t),qId:t=>e.getElementById(t),parent(t){if(t)return t.parentNode},conj:(t,e)=>t.appendChild(e),byTag:(t,i)=>d(i)?e.getElementsByTagNameNS(i,t):e.getElementsByTagName(id),attrs(t,e){return!h(e)&&e?(arguments.length>2&&t.setAttribute(e,arguments[2]),t.getAttribute(e)):(e&&T.doseq(e,(e,i)=>t.setAttribute(i,e)),t)},css(t,e){return!h(e)&&e?(arguments.length>2&&(t.style[e]=arguments[2]),t.style[e]):(e&&T.doseq(e,(e,i)=>t.style[i]=e),t)},wrap(t,e){const i=t.parentNode;return e.appendChild(t),i.appendChild(e),e},newElm(t,i,s){const r=e.createElement(t);return this.attrs(r,i),this.css(r,s),r},newTxt(t,i,s){const r=e.createTextNode(t);return this.attrs(r,i),this.css(r,s),r}},A={},O=[];class P{constructor(){this._tree=new Map,this._targets=new Map}sub(t,e,i,s){let r=t[0],n=t[1];return n&&!this._targets.has(n)&&this._targets.set(n,1),T.seq(r).forEach(t=>{if(e||(e=t),d(e)&&(e=(i=i||n)[e]),!e)throw"Error: no callback for sub()";this._tree.has(t)||this._tree.set(t,T.jsMap());let r=this._tree.get(t);n=n||A,!r.has(n)&&r.set(n,[]),r.get(n).push([e,i,s])}),this}pub(t,...e){let i,s,r=t[0],n=t[1]||A;return(n===A||this._targets.has(n))&&T.seq(r).forEach(t=>{s=this._tree.get(t),i=s&&s.get(n),i&&i.forEach(t=>{t[0].apply(t[1],e.concat(t[2]||O))})}),this}reset(){return this._targets.clear(),this._tree.clear(),this}drop(t){if(this._targets.has(t)){this._targets.delete(t);let e=this._tree.values();for(let i=e.next();!i.done;)i.value.delete(t),i=e.next()}return this}unsub(t,e,i){if(1!==arguments.length||z.vec(t)){let s=t[0],r=t[1]||A;if(r===A||this._targets.has(r)){let t,n;T.seq(s).forEach(s=>{if(t=this._tree.get(s),n=t&&t.get(r),n&&(d(e)&&(e=(i=i||r)[e]),e))for(let t=n.length-1;t>=0;--t)n[t][0]===e&&n[t][1]===i&&n.splice(t,1)})}}else this.drop(t);return this}}return e?q.dom=S:(delete T.addEvent,delete T.delEvent),q.EventBus=function(){return new P},q.is=z,q.u=T,q}"object"==typeof module&&module.exports?i=require("../tpcl/seedrandom.min"):e=t.document,"object"==typeof module&&module.exports?module.exports=s():t["io/czlab/mcfud/core"]=s}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const i=360,s=2*Math.PI,{is:r,u:n}=(Math.PI,e);function o(t){return t<0?- -t%i:t%i}return{lerp:(t,e,i)=>(1-i)*t+i*e,xmod:(t,e)=>t<0?t- -(e+e*Math.floor(-t/e)):t%e,clamp:(t,e,i)=>i<t?t:i>e?e:i,sqr:t=>t*t,fuzzyEq:(t,e)=>n.feq(t,e),fuzzyZero:t=>n.feq0(t),radToDeg:t=>o(i*t/s),degToRad:t=>s*o(t)/i,pythag2:(t,e)=>t*t+e*e,pythag:(t,e)=>Math.sqrt(t*t+e*e),wrap:(t,e)=>(t+1)%e,biasGreater:(t,e)=>t>=.95*e+.01*t}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/math"]=e}(this),function(t){"use strict";function e(e=null){e||(e=t["io/czlab/mcfud/core"]());const{u:i,is:s}=e;function r(t,e){i.assert(!s.num(t)&&!s.num(e)&&t&&e,"wanted 2 vecs")}function n(t,e=0,i=0){return t?[e,i]:{x:e,y:i}}const o={};class h{constructor(){this.x=0,this.y=0}unit(t){return s.bool(t)&&(t=n(t)),s.vec(t)?(t[0]=this.x,t[1]=this.y):(t.x=this.x,t.y=this.y),t}bind(t){return s.vec(t)?(this.x=t[0],this.y=t[1]):(this.x=t.x,this.y=t.y),this}op(t,e,i){let r=o.take();switch(r.x=this.x,r.y=this.y,t){case"+":s.num(e)&&(r.x+=e),s.num(i)&&(r.y+=i);break;case"-":s.num(e)&&(r.x-=e),s.num(i)&&(r.y-=i);break;case"*":s.num(e)&&(r.x*=e),s.num(i)&&(r.y*=i);break;case"/":s.num(e)&&(r.x/=e),s.num(i)&&(r.y/=i)}return r}"+"(t){return this.op("+",t.x,t.y)}"-"(t){return this.op("-",t.x,t.y)}"*"(t){return this.op("*",t.x,t.y)}"/"(t){return this.op("/",t.x,t.y)}}function l(t,e,i,r,n,o,h){const l=t-n,a=e-o,c=n+(l*i-a*r),u=o+(l*r+a*i);return s.vec(h)?(h[0]=c,h[1]=u):(h.x=c,h.y=u),h}function a(t,e,i,r){let n,h,l=o.take().bind(t);if(s.num(e))h=l.op(i,e,e);else{let t=o.take().bind(e);h=l[i](t),o.drop(t)}return n=h.unit(r?t:s.vec(t)),o.drop(l,h),n}i.inject(o,{take(){return this._pool.pop()},drop(...t){t.forEach(t=>{t.x=0,t.y=0,this._pool.push(t)})},_pool:i.fill(16,()=>new h)});return{vec:(t=0,e=0)=>n(!0,t,e),vecXY:(t=0,e=0)=>n(!1,t,e),add(t,e){return i.assert(2===arguments.length)&&a(t,e,"+")},add$(t,e){return i.assert(2===arguments.length)&&a(t,e,"+",!0)},sub(t,e){return i.assert(2===arguments.length)&&a(t,e,"-")},sub$(t,e){return i.assert(2===arguments.length)&&a(t,e,"-",!0)},mul(t,e){return i.assert(2===arguments.length)&&a(t,e,"*")},mul$(t,e){return i.assert(2===arguments.length)&&a(t,e,"*",!0)},div(t,e){return i.assert(2===arguments.length)&&a(t,e,"/")},div$(t,e){return i.assert(2===arguments.length)&&a(t,e,"/",!0)},dot(t,e){r(t,e);let i=o.take().bind(t),s=o.take().bind(e),n=i.x*s.x+i.y*s.y;return o.drop(i,s),n},equals(t,e){let i=o.take().bind(t),s=o.take().bind(e);return ok=i.x==s.x&&i.y==s.y,o.drop(i,s),ok},vecAB(t,e){r(t,e);let i=o.take().bind(t),n=o.take().bind(e),h=o.take();h.x=n.x-i.x,h.y=n.y-i.y;let l=h.unit(s.vec(t));return o.drop(i,n,h),l},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},dist2(t,e){return this.len2(this.sub(e,t))},dist(t,e){return Math.sqrt(this.dist2(t,e))},unit(t){let e=o.take().bind(t),r=this.len(t);i.feq0(r)?(e.x=0,e.y=0):(e.x/=r,e.y/=r);let n=e.unit(s.vec(t));return o.drop(e),n},unit$(t){let e=o.take().bind(t),s=this.len(t);i.feq0(s)?(e.x=0,e.y=0):(e.x/=s,e.y/=s);let r=e.unit(t);return o.drop(e),r},copy(t,e){r(t,e);let i=o.take().bind(t),s=o.take().bind(e);i.x=s.x,i.y=s.y;let n=i.unit(t);return o.drop(i,s),n},clone(t){let e=o.take().bind(t),i=e.unit(s.vec(t));return o.drop(e),i},set(t,e,i){let r=o.take().bind(t);s.num(e)&&(r.x=e),s.num(i)&&(r.y=i);let n=r.unit(t);return o.drop(r),n},setX(t,e){return this.set(t,e)},setY(t,e){return this.set(t,null,e)},rot(t,e,i=null){let r=o.take().bind(t),h=0,a=0;if(i){let t=o.take().bind(i);h=t.x,a=t.y,o.drop(t)}let c=l(r.x,r.y,Math.cos(e),Math.sin(e),h,a,n(s.vec(t)));return o.drop(r),c},rot$(t,e,i){let s=o.take().bind(t),r=0,n=0;if(i){let t=o.take().bind(i);r=t.x,n=t.y,o.drop(t)}let h=l(s.x,s.y,Math.cos(e),Math.sin(e),r,n,t);return o.drop(s),h},cross(t,e){let i;if(s.num(t)){let r=o.take().bind(e),n=o.take();n.x=-t*r.y,n.y=t*r.x,i=n.unit(s.vec(e)),o.drop(r,n)}else if(s.num(e)){let r=o.take().bind(t),n=o.take();n.x=e*r.y,n.y=-e*r.x,i=n.unit(s.vec(t)),o.drop(r,n)}else{r(t,e);let s=o.take().bind(t),n=o.take().bind(e);i=s.x*n.y-s.y*n.x,o.drop(s,n)}return i},angle(t,e){return Math.acos(this.dot(t,e)/(this.len(t)*this.len(e)))},normal(t,e=!1){let i=o.take().bind(t),r=o.take();e?(r.x=-i.y,r.y=i.x):(r.x=i.y,r.y=-i.x);let n=r.unit(s.vec(t));return o.drop(i,r),n},normal$(t,e=!1){let i=o.take().bind(t),s=o.take();e?(s.x=-i.y,s.y=i.x):(s.x=i.y,s.y=-i.x);let r=s.unit(t);return o.drop(i,s),r},proj_scalar(t,e){return this.dot(t,e)/this.len(e)},proj(t,e){const i=this.unit(e);this.mul$(i,this.dot(t,i));let r=o.take().bind(i),n=r.unit(s.vec(t));return o.drop(r),n},perp(t,e){return this.sub(t,this.proj(t,e))},reflect(t,e){let i=2*this.dot(t,e);return this.sub(t,this.mul(e,i))},flip(t){return this.mul(t,-1)},flip$(t){return this.mul$(t,-1)},translate(t,...e){let i,r,n,h,l=o.take().bind(t);return 1===e.length&&s.vec(e[0])&&!s.num(e[0][0])&&(e=e[0]),n=e.map(t=>(r=o.take().bind(t),i=r["+"](l),h=i.unit(s.vec(t)),o.drop(r,i),h)),o.drop(l),n}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/vec2"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());Math.atan2;const i=Math.cos,s=Math.sin,r=(Math.tan,Math.floor),{u:n,is:o}=e;function h(t){return t%2!=0}function l(t,e,i,s){return s-1+(i-1)*e}function a(t,e,i){return{dim:[t,e],cells:i}}function c(t,e){return a(t,e,n.fill(t*e,0))}return{v4:(t=0,e=0,i=0,s=0)=>[t,e,i,s],v3:(t=0,e=0,i=0)=>[t,e,i],dot:(t,e)=>t[0]*e[0]+t[1]*e[1]+t[2]*e[2],cross(t,e){return this.v3(t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0])},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},unit(t){let e=this.len(t);if(!n.feq0(e))return[t[0]/e,t[1]/e,t[2]/e]},sub(t,e){return o.num(e)?this.v3(t[0]-e,t[1]-e,t[2]-e):this.v3(t[0]-e[0],t[1]-e[1],t[2]-e[2])},add(t,e){return o.num(e)?this.v3(t[0]+e,t[1]+e,t[2]+e):this.v3(t[0]+e[0],t[1]+e[1],t[2]+e[2])},mul(t,e){return o.num(e)?this.v3(t[0]*e,t[1]*e,t[2]*e):this.v3(t[0]*e[0],t[1]*e[1],t[2]*e[2])},div(t,e){return o.num(e)?this.v3(t[0]/e,t[1]/e,t[2]/e):this.v3(t[0]/e[0],t[1]/e[1],t[2]/e[2])},matrix([t,e],...i){const s=t*e;return 0===i.length?c(t,e):n.assert(s===i.length)&&a(t,e,i)},matCell(t,e,i,s){const r=l(t.dim[0],t.dim[1],e,i);if(r>=0&&r<t.cells.length)return o.num(s)?(t.cells[r]=s,t):t.cells[r]},matIdentity(t){const e=n.assert(t>0)&&n.fill(t*t,0);for(let i=0;i<t;++i)e[l(0,t,i+1,i+1)]=1;return a(t,t,e)},matZero:t=>n.assert(t>0)&&a(t,t,n.fill(t*t,0)),matRowMajors(t){const[e,i]=t.dim;return n.partition(i,t.cells)},matColMajors(t){const[e,i]=t.dim,s=[];for(let r,n=0;n<i;++n){r=[];for(let s=0;s<e;++s)r.push(t.cells[s*i+n]);s.push(r)}return s},mat2(t,e,i,s){return this.matrix([2,2],t,e,i,s)},mat3(t,e,i,s,r,n,o,h,l){return this.matrix([3,3],t,e,i,s,r,n,o,h,l)},mat4(t,e,i,s,r,n,o,h,l,a,c,u,d,f,g,p){return this.matrix([4,4],t,e,i,s,r,n,o,h,l,a,c,u,d,f,g,p)},matEq:(t,e)=>t.dim[0]===e.dim[0]&&t.dim[1]===e.dim[1]&&function(t,e){for(let i=0;i<t.length;++i)if(!n.feq(t[i],e[i]))return!1;return!0}(t.cells,e.cells),matXpose(t){const[e,i]=t.dim,s=e*i,n=[];for(let o=0;o<s;++o)n.push(t.cells[r(o/e)+i*(o%e)]);return a(i,e,n)},matScale:(t,e)=>a(t.dim[0],t.dim[1],t.cells.map(t=>t*e)),matMult(t,e){let[i,s]=t.dim,[r,o]=e.dim,h=t.cells,l=e.cells;n.assert(s===r,"mismatch matrices");let c=new Array(i*o);for(let t=0;t<i;++t)for(let e=0;e<o;++e)c[e+t*o]=n.range(r).reduce((i,r)=>i+h[r+t*s]*l[e+r*o],0);return a(i,o,c)},matDet(t){let[e,i]=t.dim,s=[];if(2===i)return this._matDet2x2(t);for(let e=0;e<i;++e)n.conj(s,this.matDet(this.matCut(t,1,e+1)));return n.range(i).reduce((e,i)=>{let r=s[i];return e+t.cells[i]*(h(i)?-r:r)},0)},_matDet2x2:t=>(n.assert(4===t.cells.length),t.cells[0]*t.cells[3]-t.cells[1]*t.cells[2]),matCut(t,e,i){const[s,r]=t.dim;let o=e-1,h=i-1,l=[];for(let e=0;e<s;++e)for(let i=0;i<r;++i)e!==o&&i!==h&&n.conj(l,t.cells[i+e*r]);return a(s-1,r-1,l)},matMinor(t){const[e,i]=t.dim;let s=[];if(n.assert(e===i),2===i)return this._matMinor2x2(t);for(let r=0;r<e;++r)for(let e=0;e<i;++e)n.conj(s,this.matDet(this.matCut(t,r+1,e+1)));return a(e,i,s)},_matMinor2x2(t){return n.assert(4===t.cells.length)&&this.mat2(t.cells[3],t.cells[2],t.cells[1],t.cells[0])},matCofactor(t){const e=this.matMinor(t),[i,s]=e.dim;let r=e.cells.slice();for(let t=0;t<i;++t)for(let e,i=0;i<s;++i)e=t*s+i,h(t+i)&&(r[e]=-r[e]);return a(i,s,r)},matAdjugate(t){return this.matXpose(this.matCofactor(t))},_minv2x2(t){const[e,i]=t.dim;n.assert(4===t.cells.length&&2===e&&2===i);let s,r=t.cells,o=r[0]*r[3]-r[1]*r[2];if(n.feq0(o))s=this.matIdentity(e);else{let t=1/o;s=this.mat2(r[3]*t,-r[1]*t,-r[2]*t,r[0]*t)}return s},matInv(t){const[e,i]=t.dim;if(2===i)return this._minv2x2(t);let s=this.matDet(t);return n.feq0(s)?this.matIdentity(e):this.matScale(this.matAdjugate(t),1/s)},matFromColMajor(t){let e=t.length,i=c(t[0].length,e);for(let s,r=0;r<t.length;++r){s=t[r];for(let t=0;t<s.length;++t)i.cells[t*e+r]=s[t]}return i},matToColMajor(t){const[e,i]=t.dim,s=[];t.cells.slice();for(let r,n=0;n<i;++n){r=[];for(let s=0;s<e;++s)r.push(t.cells[s*i+n]);s.push(r)}return s},scale3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,1,1)]=t[0],e.cells[l(0,4,2,2)]=t[1],e.cells[l(0,4,3,3)]=t[2],e},translate3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,4,1)]=t[0],e.cells[l(0,4,4,2)]=t[1],e.cells[l(0,4,4,3)]=t[2],e},rot3D(t,e,i){return this.matMult(this.zRot3D(i),this.matMult(this.yRot3D(e),this.xRot3D(t)))},matVMult(t,e){let i=t.dim[1],s=e.length;n.assert(i===s);let r=this.matMult(t,a(s,1,e)),o=r.cells;return r.cells=null,o},rot2D(t){return this.mat2(i(t),-s(t),s(t),i(t))},xRot3D(t){return this.mat4(1,0,0,0,0,i(t),-s(t),0,0,s(t),i(t),0,0,0,0,1)},yRot3D(t){return this.mat4(i(t),0,s(t),0,0,1,0,0,-s(t),0,i(t),0,0,0,0,1)},zRot3D(t){return this.mat4(i(t),-s(t),0,0,s(t),i(t),0,0,0,0,1,0,0,0,0,1)},isIdentity(t){const[e,i]=t.dim;if(e===i){for(let s,r=0;r<e;++r)for(let e=0;e<i;++e)if(s=t.cells[r*i+e],r+1===e+1){if(1!==s)return!1}else if(0!==s)return!1;return!0}return!1},isOrthogonal(t){let e=this.matDet(t);return 1===Math.abs(e)&&this.isIdentity(this.matMult(this.matXpose(t),this.matInv(t)))}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/matrix"]=e}(this),function(t){"use strict";const e=" @N/\\Ri2}aP`(xeT4F3mt;8~%r0v:L5$+Z{'V)\"CKIc>z.*fJEwSU7juYg<klO&1?[h9=n,yoQGsW]BMHpXb6A|D#q^_d!-",i=e.length;function s(s){s||(s=t["io/czlab/mcfud/core"]());const{u:r}=s;function n(t){return Math.abs(t)%i}function o(t,i){return(i||e).charAt(t)}function h(t){for(let e=0;e<i;++e)if(o(e)===t)return e;return-1}function l(t,e){let s=e+t;return o(s>=i?s-i:s)}function a(t,e){let s=e-t;return o(s<0?i+s:s)}return{encrypt(t,e){if(0===e)return t;let i,s=[],r=n(e);return t.split("").forEach(t=>{i=h(t),s.push(i<0?t:function(t,e,i){return t<0?l(e,i):a(e,i)}(e,r,i))}),s.join("")},decrypt(t,e){if(0===e)return t;let i,s=[],r=n(e);return t.split("").forEach(t=>{i=h(t),s.push(i<0?t:function(t,e,i){return t<0?a(e,i):l(e,i)}(e,r,i))}),s.join("")}}}"object"==typeof module&&module.exports?module.exports=s(require("./core")):t["io/czlab/mcfud/crypt"]=s}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());return{fsm(t){let e=t.initState();return{state:()=>e,process(){const i=t[e];i&&i.run&&i.run()},trigger(i="change",s){const r=t[e],n=r&&r.transitions[i];if(n){const i=n.target,o=t[i];if(o)return r.exit&&r.exit(),o.enter&&o.enter(),s&&s.action?s.action():n.action&&(s?n.action(s):n.action()),e=i}}}}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/fsm"]=e}(this),function(t){"use strict";function e(e,i){e||(e=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/math"]());const s=2*Math.PI,{u:r}=e;return{TXMatrix2D:class{constructor(t){t?(this.m=[],this.clone(t)):this.m=[1,0,0,0,1,0]}identity(){const t=this.m;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,this}clone(t){let e=this.m,i=t.m;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],this}multiply(t){let e=this.m,i=t.m,s=e[0]*i[0]+e[1]*i[3],r=e[0]*i[1]+e[1]*i[4],n=e[0]*i[2]+e[1]*i[5]+e[2],o=e[3]*i[0]+e[4]*i[3],h=e[3]*i[1]+e[4]*i[4],l=e[3]*i[2]+e[4]*i[5]+e[5];return e[0]=s,e[1]=r,e[2]=n,e[3]=o,e[4]=h,e[5]=l,this}rotate(t){if(!r.feq0(t)){let e=this.m,i=Math.cos(t),s=Math.sin(t),r=e[0]*i+e[1]*s,n=-e[0]*s+e[1]*i,o=e[3]*i+e[4]*s,h=-e[3]*s+e[4]*i;e[0]=r,e[1]=n,e[3]=o,e[4]=h}return this}rotateDeg(t){return r.feq0(t)?this:this.rotate(Math.PI*t/180)}scale(t,e){let i=this.m;return void 0===e&&(e=t),i[0]*=t,i[1]*=e,i[3]*=t,i[4]*=e,this}translate(t,e){let i=this.m;return i[2]+=i[0]*t+i[1]*e,i[5]+=i[3]*t+i[4]*e,this}transform(t,e){return[t*this.m[0]+e*this.m[1]+this.m[2],t*this.m[3]+e*this.m[4]+this.m[5]]}transformPoint(t){const[e,i]=this.transform(t.x,t.y);return t.x=e,t.y=i,t}transformArray(t){return this.transform(t[0],t[1])}setContextTransform(t){const e=this.m;t.transform(e[0],e[3],e[1],e[4],e[2],e[5])}},textStyle(t,e,i,s){const r={font:t,fill:e};return i&&(r.align=i),s&&(r.base=s),r},drawShape(t,e,...i){e&&e.draw&&e.draw(t,...i)},cfgStyle(t,e){const{line:i,stroke:s}=e;i&&(i.cap&&(t.lineCap=i.cap),i.width&&(t.lineWidth=i.width)),s&&s.style&&(t.strokeStyle=s.style)},drawPoints(t,e,i){void 0===i&&(i=e.length),r.assert(i<=e.length),t.beginPath();for(let s,r,n,o=0;o<i;++o)n=(o+1)%i,s=e[o],r=e[n],t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]);t.stroke()},drawShapePoly(t,e){return this.drawPoints(t,e.points)},drawCircle(t,e,i,r){t.beginPath(),t.arc(e,i,r,0,s,!0),t.closePath(),t.stroke()},drawShapeCircle(t,e){return this.drawCircle(t,e.pos[0],e.pos[1],e.radius)},drawRect(t,e,i,s,r,n){let o=e,h=i-r;t.save(),t.translate(o,h),t.rotate(n),t.strokeRect(0,0,s,r),t.restore()},drawShapeRect(t,e){return this.drawRect(t,e.pos[0],e.pos[1],e.width,e.height,e.rotation)},drawLine(t,e,i,s,r){t.beginPath(),t.moveTo(e,i),t.lineTo(s,r),t.stroke()},drawShapeLine(t,e){return this.drawLine(t,e.p[0],e.p[1],e.q[0],e.q[1])}}}"object"==typeof module&&module.exports?module.exports=e(require("./core"),require("./math")):t["io/czlab/mcfud/gfx"]=e}(this),function(t){"use strict";const[e,i,s]=[1,0,-1];function r(r,n,o){r||(r=t["io/czlab/mcfud/core"]()),n||(n=t["io/czlab/mcfud/math"]()),o||(o=t["io/czlab/mcfud/vec2"]());const h=Math.floor,l=Math.abs,{u:a}=r;function c(t){const e=t.length,i=a.assert(e<=36)&&a.fill(36);let s=0,r=t[0][0];for(let i,n=1;n<e;++n)i=t[n][0],i>r?(r=i,s=n):a.feq(i,r)&&t[n][1]<t[s][1]&&(s=n);let n=0,h=s;for(;;){i[n]=h;let r=0,l=i[n];for(let i,s,n,c=1;c<e;++c)r!==h?(i=o.sub(t[r],t[l]),s=o.sub(t[c],t[l]),n=o.cross(i,s),n<0&&(r=c),a.feq0(n)&&o.len2(s)>o.len2(i)&&(r=c)):r=c;if(h=r,++n,r===s)break}const l=[];for(let e=0;e<n;++e)l.push(o.clone(t[i[e]]));return l}class u{constructor(t,e,i,s){switch(arguments.length){case 2:this.pos=o.vec(),this.width=t,this.height=e;break;case 4:this.pos=o.vec(t,e),this.width=i,this.height=s;break;default:throw"Error: bad input to Rect()"}}}class d{constructor(t,e){this.width=t,this.height=e}half(){return new d(h(this.width/2),h(this.height/2))}}class f{constructor(t,e,i,s){this.p=o.vec(t,e),this.q=o.vec(i,s)}}class g{constructor(t,e){this.calcPoints=null,this.normals=null,this.edges=null,this.points=null,this.orient=0,this.pos=o.vec(),this.setPos(t,e)}setPos(t=0,e=0){return o.set(this.pos,t,e),this}set(t){return this.calcPoints=this.calcPoints||[],this.normals=this.normals||[],this.edges=this.edges||[],this.calcPoints.length=0,this.normals.length=0,this.edges.length=0,this.points=a.assert(t.length>2)&&c(t),a.doseq(this.points,t=>{this.calcPoints.push(o.vec()),this.edges.push(o.vec()),this.normals.push(o.vec())}),this._recalc()}setOrient(t){return this.orient=t,this._recalc()}translate(t,e){return a.doseq(this.points,i=>{i[0]+=t,i[1]+=e}),this._recalc()}_recalc(){if(this.points){let t,e,i;a.doseq(this.points,(t,e)=>{o.copy(this.calcPoints[e],t),a.feq0(this.orient)||o.rot$(this.calcPoints[e],this.orient)}),a.doseq(this.points,(s,r)=>{t=(r+1)%this.calcPoints.length,e=this.calcPoints[r],i=this.calcPoints[t],this.edges[r]=o.sub(i,e),this.normals[r]=o.unit(o.normal(this.edges[r]))})}return this}static translateCalcPoints(t){return o.translate(t.pos,t.calcPoints)}}class p{constructor(t,e){this.overlapN=o.vec(),this.overlapV=o.vec(),this.A=t,this.B=e,this.clear()}swap(){let t=new p,e=this.AInB,i=this.BInA,s=this.A;return t.overlap=this.overlap,t.A=this.B,t.B=s,t.AInB=i,t.BInA=e,t.overlapN=o.flip(this.overlapN),t.overlapV=o.flip(this.overlapV),t}clear(){return this.overlap=1/0,this.AInB=!0,this.BInA=!0,this}}function m(t,e){let i=1/0,s=-1/0;for(let r,n=0;n<t.length;++n)r=o.dot(t[n],e),r<i&&(i=r),r>s&&(s=r);return[i,s]}function y(t,r){let n=o.len2(t),h=o.dot(r,t);return h<0?e:h>n?s:i}function _(t,e,i,s,r,n){let[h,l]=m(e,r),[a,c]=m(s,r),u=o.vecAB(t,i),d=o.dot(u,r);if(a+=d,c+=d,h>c||a>l)return!0;if(n){let t=0;if(h<a)if(n.AInB=!1,l<c)t=l-a,n.BInA=!1;else{let[e,i]=[l-a,c-h];t=e<i?e:-i}else if(n.BInA=!1,l>c)t=h-c,n.AInB=!1;else{let[e,i]=[l-a,c-h];t=e<i?e:-i}let e=Math.abs(t);e<n.overlap&&(n.overlap=e,o.copy(n.overlapN,r),t<0&&o.flip$(n.overlapN))}}new p,w=new u(0,0,1,1),new g(w.pos[0],w.pos[1]).set([o.vec(w.width,0),o.vec(w.width,w.height),o.vec(0,w.height),o.vec()]);var w;function x(t,e,i){let s=o.vecAB(t.pos,e.pos),r=t.radius+e.radius,n=r*r,h=o.len2(s),l=!(h>n);if(l&&i){let n=Math.sqrt(h);i.A=t,i.B=e,i.overlap=r-n,o.copy(i.overlapN,o.unit$(s)),o.copy(i.overlapV,o.mul(s,i.overlap)),i.AInB=t.radius<=e.radius&&n<=e.radius-t.radius,i.BInA=e.radius<=t.radius&&n<=t.radius-e.radius}return l}function k(t,i,r){let n,h=o.vecAB(t.pos,i.pos),l=i.radius*i.radius,a=t.calcPoints,c=o.vec();for(let u,d,f,g,p=a.length,m=0;m<p;++m){u=m===p-1?0:m+1,d=0===m?p-1:m-1,f=0,g=null,o.copy(c,t.edges[m]),n=o.vecAB(a[m],h),r&&o.len2(n)>l&&(r.AInB=!1);let _=y(c,n);if(_===e){if(o.copy(c,t.edges[d]),_=y(c,o.vecAB(a[d],h)),_===s){let t=o.len(n);if(t>i.radius)return!1;r&&(r.BInA=!1,g=o.unit(n),f=i.radius-t)}}else if(_===s){if(o.copy(c,t.edges[u]),o.sub$(o.copy(n,h),a[u]),_=y(c,n),_===e){let t=o.len(n);if(t>i.radius)return!1;r&&(r.BInA=!1,g=o.unit(n),f=i.radius-t)}}else{let t=o.unit$(o.normal(c)),e=o.dot(n,t),s=Math.abs(e);if(e>0&&s>i.radius)return!1;r&&(g=t,f=i.radius-e,(e>=0||f<2*i.radius)&&(r.BInA=!1))}g&&r&&Math.abs(f)<Math.abs(r.overlap)&&(r.overlap=f,o.copy(r.overlapN,g))}return r&&(r.A=t,r.B=i,o.mul$(o.copy(r.overlapV,r.overlapN),r.overlap)),!0}function E(t,e,i){let s=k(e,t,i);if(s&&i){let t=i.A,e=i.AInB;o.flip$(i.overlapN),o.flip$(i.overlapV),i.A=i.B,i.B=t,i.AInB=i.BInA,i.BInA=e}return s}function v(t,e,i){let s=t.calcPoints,r=e.calcPoints;for(let n=0;n<s.length;++n)if(_(t.pos,s,e.pos,r,t.normals[n],i))return!1;for(let n=0;n<r.length;++n)if(_(t.pos,s,e.pos,r,e.normals[n],i))return!1;if(i){if(0===i.overlap||a.feq0(i.overlap))return!1;i.A=t,i.B=e,o.copy(i.overlapV,i.overlapN),o.mul$(i.overlapV,i.overlap)}return!0}return{Rect:u,Area:d,Line:f,Circle:class{constructor(t){this.radius=t,this.orient=0,this.pos=o.vec()}setOrient(t){return this.orient=t,this}setPos(t,e){return o.set(this.pos,t,e),this}},Polygon:g,Manifold:p,orderVertices:t=>c(t),polyArea(t,e=!1){let i=e?this.orderVertices(t):t,s=0;for(let t,e,r,n=i.length,o=0;o<n;++o)r=(o+1)%n,t=i[o],e=i[r],s+=t[0]*e[1]-e[0]*t[1];return h(l(s)/2)},calcPolygonCenter(t,e=!1){const i=e?this.orderVertices(t):t,s=6*this.polyArea(i);let r=0,n=0;for(let t,e,s,o=0,h=i.length;o<h;++o)s=(o+1)%h,t=i[o],e=i[s],r+=(t[0]+e[0])*(t[0]*e[1]-e[0]*t[1]),n+=(t[1]+e[1])*(t[0]*e[1]-e[0]*t[1]);return o.vec(h(r/s),h(n/s))},getAABB(t,e=null){if(e||(e=t.pos),a.has(t,"radius"))return new u(e[0]-t.radius,e[1]-t.radius,2*t.radius,2*t.radius);{let i=o.translate(e,t.calcPoints),s=i[0][0],r=i[0][1],n=s,h=r;for(let t,e=1;e<i.length;++e)t=i[e],t[0]<s&&(s=t[0]),t[0]>n&&(n=t[0]),t[1]<r&&(r=t[1]),t[1]>h&&(h=t[1]);return new u(s,r,n-s,h-r)}},shiftPoints:(t,e)=>t.map(t=>o.add(t,e)),rotPoints:(t,e,i)=>t.map(t=>o.rot(t,e,i)),calcRectPoints(t,e){const i=h(t/2),s=h(e/2);return[o.vec(i,-s),o.vec(i,s),o.vec(-i,s),o.vec(-i,-s)]},line:(t,e,i,s)=>new f(t,e,i,s),rectEqRect:(t,e)=>t.width===e.width&&t.height===e.height&&t.pos[0]===e.pos[0]&&t.pos[1]===e.pos[1],rectContainsRect:(t,e)=>!(t.pos[0]>=e.pos[0]||t.pos[1]>=e.pos[1]||t.pos[0]+t.width<=e.pos[0]+e.width||t.pos[1]+t.height<=e.pos[1]+e.height),rectGetMaxX:t=>t.pos[0]+t.width,rectGetMidX:t=>t.pos[0]+h(t.width/2),rectGetMinX:t=>t.pos[0],rectGetMaxY:t=>t.pos[1]+t.height,rectGetMidY:t=>t.pos[1]+h(t.height/2),rectGetMinY:t=>t.pos[1],rectContainsPoint(t,e,i){return e>=this.rectGetMinX(t)&&e<=this.rectGetMaxX(t)&&i>=this.rectGetMinY(t)&&i<=this.rectGetMaxY(t)},rectOverlayRect:(t,e)=>!(t.pos[0]+t.width<e.pos[0]||e.pos[0]+e.width<t.pos[0]||t.pos[1]+t.height<e.pos[1]||e.pos[1]+e.height<t.pos[1]),rectUnion(t,e){const i=Math.min(t.pos[0],e.pos[0]),s=Math.min(t.pos[1],e.pos[1]);return new u(i,s,Math.max(t.pos[0]+t.width,e.pos[0]+e.width)-i,Math.max(t.pos[1]+t.height,e.pos[1]+e.height)-s)},rectIntersection(t,e){if(this.rectOverlayRect(t,e)){const i=Math.max(t.pos[0],e.pos[0]),s=Math.max(t.pos[1],e.pos[1]);return new u(i,s,Math.min(t.pos[0]+t.width,e.pos[0]+e.width)-i,Math.min(t.pos[1]+t.height,e.pos[1]+e.height)-s)}},hitTestPointCircle(t,e,i){let s=t-i.pos[0],r=e-i.pos[1];return s*s+r*r<=i.radius*i.radius},hitCircleCircle(t,e){let i=new p;if(x(t,e,i))return i},hitTestCircleCircle:(t,e)=>x(t,e,new p),hitPolygonCircle(t,e){let i=new p;if(k(t,e,i))return i},hitTestPolygonCircle:(t,e)=>k(t,e,new p),hitCirclePolygon(t,e){let i=new p;if(E(t,e,i))return i},hitTestCirclePolygon:(t,e)=>E(t,e,new p),hitPolygonPolygon(t,e){let i=new p;if(v(t,e,i))return i},hitTestPolygonPolygon:(t,e)=>v(t,e,new p),hitTestPointInPolygon(t,e,i){let s;for(let r,n,o=i.length,h=0,l=o-1;h<o;)r=i[h],n=i[l],r[1]>e!=n[1]>e&&t<(n[0]-r[0])*(e-r[1])/(n[1]-r[1])+r[0]&&(s=!s),l=h,++h;return s},hitTestPointPolygon(t,e,i){return this.hitTestPointInPolygon(t,e,o.translate(i.pos,i.calcPoints))},hitTestLinePolygon(t,e,i){let s=g.translateCalcPoints(i);for(let i=0,r=0;i<s.length;++i){r=i+1,r==s.length&&(r=0);let[n,o]=this.lineIntersect2D(t,e,s[i],s[r]);if(n)return[n,o]}return[!1]},lineIntersect2D(t,e,i,s){let r,n,o=t[0],h=t[1],l=e[0],c=e[1],u=i[0],d=i[1],f=s[0],g=s[1],p=(o-l)*(d-g)-(h-c)*(u-f);return a.feq0(p)?[!1]:(r=(o-u)*(d-g)-(h-d)*(u-f),r/=p,n=(o-u)*(h-c)-(h-d)*(o-l),n/=p,0<=r&&r<=1&&0<=n&&n<=1?[!0,r,[o+r*(l-o),h+r*(c-h)]]:[!1])}}}"object"==typeof module&&module.exports?module.exports=r(require("./core"),require("./math"),require("./vec2")):t["io/czlab/mcfud/geo2d"]=r}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const i=Math.floor,{u:s,is:r}=e;return{spatialGrid:(t=320,e=320)=>function(t,e){const n=new Map;return{searchAndExec(t,e){let i,s=t.getSpatial();for(let r,o,h=s.y1;h<=s.y2;++h)if(o=n.get(h))for(let n,l,a=s.x1;a<=s.x2;++a)if(r=o.get(a))for(n=r.values(),l=n.next();!l.done;){if(t!==l.value&&(i=e(t,l.value))){a=h=1/0;break}i=null,l=n.next()}return i},search(t,e=!1){let i,s,r=[],o=t.getSpatial();for(let h=o.y1;h<=o.y2;++h)if(s=n.get(h))for(let n=o.x1;n<=o.x2;++n)(i=s.get(n))&&i.forEach(i=>{(i!==t||e)&&r.push(i)});return r},engrid(s,r){if(!s)return;let n=s.getBBox(),o=s.getSpatial(),h=i(n.x1/t),l=i(n.y1/e),a=i(n.x2/t),c=i(n.y2/e);return o.x1===h&&o.x2===a&&o.y1===l&&o.y2===c||(this.degrid(s),o.x1=h,o.x2=a,o.y1=l,o.y2=c,r||this._register(s)),s},reset(){n.clear()},_register(t){let e=t.getSpatial();if(r.num(e.x1))for(let i,r,o=e.y1;o<=e.y2;++o){n.has(o)||n.set(o,new Map),r=n.get(o);for(let n=e.x1;n<=e.x2;++n)r.has(n)||r.set(n,new Map),i=r.get(n),s.assoc(i,t.getGuid(),t)}},degrid(t){if(t){let e=t.getSpatial();if(r.num(e.x1))for(let i,r,o=e.y1;o<=e.y2;++o)if(r=n.get(o))for(let n=e.x1;n<=e.x2;++n)(i=r.get(n))&&s.dissoc(i,t.getGuid())}}}}(t,e)}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/spatial"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const i=Math.floor,{u:s}=e;function r(t,e,o,h,l,a,c){let u=null,d=[],f=o<h,g=i((t+e)/2),p=i((o+h)/2);function m(t){let e,i,s,r;if(t.getBBox){let{x1:n,x2:o,y1:h,y2:l}=t.getBBox();e=n,i=h,s=o-n,r=f?l-h:h-l}else void 0!==t.x&&void 0!==t.y&&void 0!==t.width&&void 0!==t.height&&(e=t.x,i=t.y,s=t.width,r=t.height);let n=[],o=e<g,h=e+s>g,l=f?i+r>p:i<p;return(f?i<p:i+r>p)&&(o&&n.push(3),h&&n.push(0)),l&&(o&&n.push(2),h&&n.push(1)),n}function y(){s.assert(null===u),u=[r(g,e,o,p,l,a,c+1),r(g,e,p,h,l,a,c+1),r(t,g,p,h,l,a,c+1),r(t,g,o,p,l,a,c+1)]}const _={x1:t,x2:e,y1:o,y2:h};return{boundingBox:()=>_,subTrees:()=>u,dbg:t=>t(d,u,l,a,c),insert:function(t){for(let e=0;e<arguments.length;++e)t=arguments[e],u?m(t).forEach(e=>u[e].insert(t)):(d.push(t),d.length>l&&c<a&&(y(),d.forEach(t=>m(t).forEach(e=>u[e].insert(t))),d.length=0))},remove(t){u?u.forEach(e=>e.remove(t)):s.disj(d,t)},isLeaf:()=>null===u?-1:d.length,prune(){if(u){let t=0,e=0;for(let i,s=0;s<u.length;++s)i=u[s],i.prune(),n=i.isLeaf(),n>=0&&(++t,e+=n);t===u.length&&e<l&&(s.assert(0===d.length,"quadtree wanted zero items"),u.forEach(t=>t._swap(d)),u=null)}},_swap(t){d.forEach(e=>t.push(e)),d.length=0},reset(){d.length=0,u&&u.forEach(t=>t.reset()),u=null},searchAndExec(t,e,i){let s;if(u){let r=m(t);for(let n=0;n<r.length&&(s=u[r[n]].searchAndExec(t,e,i),!s);++n);}else for(let r,n=0;n<d.length&&(r=d[n],i&&r===t||!(s=e(r,t)));++n);return s},search(t,e){const i=new Map,s=[];return e&&i.set(t,null),u&&m(t).forEach(e=>{u[e].search(t).forEach(t=>{i.has(t)||(i.set(t,null),s.push(t))})}),d.forEach(t=>{i.has(t)||(i.set(t,null),s.push(t))}),i.clear(),s}}}return{quadtree(t,e=12,i=5){const{left:s,right:n,top:o,bottom:h}=t;return r(s,n,o,h,e,i,0)}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/qtree"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const{u:i}=e;class s{constructor(t,e){this.lastBestMove=null,this.state=null,this.other=e,this.cur=t}clone(t){const e=new s;return e.state=t(this.state),e.lastBestMove=this.lastBestMove,e.other=this.other,e.cur=this.cur,e}}function r(t,e,i,s){return t.evalScore(e,i,s)*(1+.001*i)}function n(t,e,s,o,h,l){if(0===s||t.isOver(e))return{depth:s,value:r(t,e,s,o)};let a=e,c=t.getStateCopier(),u=i.shuffle(t.getNextMoves(e));for(let r,d,f=0;f<u.length;++f)if(d=u[f],t.undoMove||(i.assert(c,"Missing state copier!"),e=a.clone(c)),t.makeMove(e,d),r=n(t,e,s-1,o,{value:-l.value,move:l.move},{value:-h.value,move:h.move}),t.undoMove&&t.unmakeMove(e,d),r.value=-r.value,r.move=d,r.value>h.value&&(h={value:r.value,move:d,depth:r.depth}),h.value>=l.value)return l;return JSON.parse(JSON.stringify(h))}function o(t,e,s,n,h,l){if(0===s||t.isOver(e))return[r(t,e,s,n),null];let a=i.shuffle(t.getNextMoves(e)),c=t.getStateCopier(),u=e,d=-1/0,f=a[0];s===n&&(u.lastBestMove=f);for(let r,g,p=0;p<a.length&&(t.undoMove||(i.assert(c,"Missing state copier!"),e=u.clone(c)),g=a[p],t.makeMove(e,g),r=-o(t,e,s-1,n,-l,-h)[0],t.undoMove&&t.unmakeMove(e,g),d<r&&(d=r,f=g),!(h<r&&(h=r,s===n&&(u.lastBestMove=g),h>=l)));++p);return[d,u.lastBestMove]}const h={algo:"negamax",GFrame:s,GameBoard:class{constructor(){}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t){}isStalemate(t){}isOver(t){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}takeGFrame(){}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=h.evalNegaMax(this)),s}},XXevalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let r,n;return[r,n]=o(t,e,s,s,-1/0,1/0),i.nichts(n)&&console.log(`evalNegaMax: score=${r}, pos= ${n}, lastBestMove=${n}`),n},evalNegaMax(t){const e=t.takeGFrame(),s=t.depth;let{value:r,move:o}=n(t,e,s,s,{value:-1/0},{value:1/0});return i.nichts(o)&&console.log(`evalNegaMax: score= ${r}, pos= ${o}`),o}};return h}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/negamax"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const{u:i}=e;class s{constructor(t,e){this.cur=t,this.state=null,this.other=e}clone(t){const e=new s;return e.state=t(this.state),e.other=this.other,e.cur=this.cur,e}}function r(t,e,i,s){return t.evalScore(e,i,s)}function n(t,e,s,o,h,l,a){if(0===s||t.isOver(e))return[r(t,e,s,o),null];let c=e,u=t.getStateCopier(),d=i.shuffle(t.getNextMoves(e));if(a){let r,f,g=d[0],p=-1/0;for(let m=0;m<d.length&&(t.undoMove||(i.assert(u,"Missing state copier!"),e=c.clone(u)),f=d[m],t.makeMove(e,f),r=n(t,e,s-1,o,h,l,!a)[0],t.undoMove&&t.unmakeMove(e,f),h=Math.max(r,h),r>p&&(p=r,g=f),!(l<=h));++m);return[p,g]}{let r,f,g=d[0],p=1/0;for(let m=0;m<d.length&&(t.undoMove||(i.assert(u,"Missing state copier!"),e=c.clone(u)),f=d[m],t.makeMove(e,f),r=n(t,e,s-1,o,h,l,!a)[0],t.undoMove&&t.unmakeMove(e,f),l=Math.min(r,l),r<p&&(p=r,g=f),!(l<=h));++m);return[p,g]}}const o={algo:"minimax",GFrame:s,GameBoard:class{constructor(){this.aiActor=null}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t,e,i){}isStalemate(t){}isOver(t,e){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}takeGFrame(){}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let s=this.getFirstMove();return i.nichts(s)&&(s=o.evalMiniMax(this)),s}},evalMiniMax(t){const e=t.takeGFrame(),s=t.depth;let r,o;return[r,o]=n(t,e,s,s,-1/0,1/0,!0),i.nichts(o)&&console.log(`evalMiniMax: score=${r}, pos= ${o}`),o}};return o}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/minimax"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const i=(t,e)=>t<e?-1:t>e?1:0,s=Math.floor,{is:r,u:n}=e;function o(t,e=" ",i=""){for(;t.hasNext();)i+=`${t.next()}${e}`;return i}function h(t){return n.assert(r.num(t)||r.str(t),"expected number or string")}class l{constructor(t){this.current=t}hasNext(){return n.echt(this.current)}remove(){throw Error("Unsupported")}next(){if(!this.hasNext())throw Error("NoSuchElementException");let t=this.current.item;return this.current=this.current.next,t}}function a(t,e=null){return{item:t,next:e}}class c{constructor(){this.first=null,this.n=0}clone(){let t,e=new c,i=this.first;for(;i;)t?(t.next=a(i.item),t=t.next):e.first=t=a(i.item),e.n+=1,i=i.next;return e}isEmpty(){return n.nichts(this.first)}size(){return this.n}add(t){this.first=a(t,this.first),this.n+=1}iter(){return new l(this.first)}static test(){let t=new c;"to be or not to - be - - that - - - is".split(" ").forEach(e=>t.add(e)),console.log("size of bag = "+t.size()),console.log(o(t.iter()));let e=t.clone();console.log("size of cloned = "+e.size()),console.log(o(e.iter()))}}class u{constructor(){this.first=null,this.n=0}clone(){let t,e=new u,i=this.first;for(;i;)t?(t.next=a(i.item),t=t.next):e.first=t=a(i.item),e.n+=1,i=i.next;return e}isEmpty(){return n.nichts(this.first)}size(){return this.n}push(t){this.first=a(t,this.first),this.n+=1}pop(){if(this.isEmpty())throw Error("Stack underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,t}peek(){if(this.isEmpty())throw Error("Stack underflow");return this.first.item}toString(){return o(this.iter())}iter(){return new l(this.first)}static test(){let t=new u;"to be or not to - be - - that - - - is".split(" ").forEach(e=>{"-"!=e?t.push(e):t.isEmpty()||console.log("(-)"+t.pop()+" ")}),console.log("("+t.size()+" left on stack)");let e=t.clone();console.log("cloned= "+o(e.iter())),console.log("("+e.size()+" left on stack)")}}class d{constructor(){this.first=null,this.last=null,this.n=0}clone(){let t=new d,e=this.first;for(;e;)t.enqueue(e.item),e=e.next;return t}isEmpty(){return n.nichts(this.first)}size(){return this.n}peek(){if(this.isEmpty())throw Error("Queue underflow");return this.first.item}enqueue(t){let e=this.last;this.last=a(t),this.isEmpty()?this.first=this.last:e.next=this.last,this.n+=1}dequeue(){if(this.isEmpty())throw Error("Queue underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,this.isEmpty()&&(this.last=null),t}toString(){return o(this.iter())}iter(){return new l(this.first)}static test(){let t=new d;"to be or not to - be - - that - - - is".split(/\s+/).forEach(e=>{"-"!=e?t.enqueue(e):t.isEmpty()||console.log(t.dequeue()+" ")}),console.log("("+t.size()+" left on queue)");let e=t.clone();console.log("cloned= "+o(e.iter())),console.log("("+e.size()+" left on queue)")}}class f{constructor(t){this.compare=t||i,this.root=null,this.n=0}size(){return this.n}contains(t){return void 0!==this.get(t)}get(t){const e=(t,i,s)=>{if(i){let r=this.compare(t,i.key);s=r<0?e(t,i.left):r>0?e(t,i.right):i.value}return s};if(h(t)&&this.n>0)return e(t,this.root)}set(t,e){const i=(t,e,s)=>{if(!s)return this.n+=1,{key:t,value:e,left:null,right:null};let r=this.compare(t,s.key);return r<0?s.left=i(t,e,s.left):r>0?s.right=i(t,e,s.right):s.value=e,s};h(t)&&void 0!==e&&(this.root=i(t,e,this.root))}_getMaxNode(t){for(;null!==t&&null!==t.right;)t=t.right;return t}_getMaxKey(){let t=this._getMaxNode(this.root);if(t)return t.key}_getMinNode(t){for(;null!==t&&null!==t.left;)t=t.left;return t}_getMinKey(){let t=this._getMinNode(this.root);if(t)return t.key}remove(t){const e=(t,i)=>{if(i){let s,r,n,o=this.compare(t,i.key);o<0?i.left=e(t,i.left):o>0?i.right=e(t,i.right):i.left&&i.right?(n=this._getMaxNode(i.left),s=n.key,r=n.value,n.value=i.value,n.key=i.key,i.key=s,i.value=r,i.left=e(t,i.left)):i.left?(i=i.left,this.n-=1):i.right?(i=i.right,this.n-=1):(i=null,this.n-=1)}return i};h(t)&&(this.root=e(t,this.root))}keys(){let t=new d;return this.forEach((e,i)=>t.enqueue(i)),t.iter()}firstKey(){let t;try{this.forEach((e,i)=>{throw t=i,Error("????")})}catch(t){}return t}lastKey(){let t;return this.forEach((e,i)=>{t=i}),t}forEach(t,e){function i(t,e){return e&&e.apply(t,Array.prototype.slice.call(arguments,2))}!function t(e,s,r,n){if(!e)return i(r,n);t(e.left,s,r,(function(){i(r,s,e.value,e.key),t(e.right,s,r,(function(){i(r,n)}))}))}(this.root,t,e)}static test(){let t=new f;t.set(3,"3"),t.set(2,"2"),t.set(7,"7"),t.set(1,"1"),console.log("firstKey= "+t.firstKey()),console.log("lastKey= "+t.lastKey()),console.log(o(t.keys())),console.log("k= "+t.get(3)),console.log("has 2 = "+t.contains(2)),console.log("has size = "+t.size()),t.remove(1),console.log("has size = "+t.size()),console.log(o(t.keys())),console.log("k= "+t.get(2))}}class g{constructor(){this.st=new f}get(t){if(n.nichts(t))throw Error("calls get() with null key");return this.st.get(t)}put(t,e){if(n.nichts(t))throw Error("calls put() with null key");void 0===e?this.st.remove(t):this.st.set(t,e)}remove(t){if(n.nichts(t))throw Error("calls remove() with null key");this.st.remove(t)}contains(t){if(n.nichts(t))throw Error("calls contains() with null key");return this.st.contains(t)}size(){return this.st.size()}isEmpty(){return 0==this.size()}keys(){return this.st.keys()}min(){if(this.isEmpty())throw Error("calls min() with empty symbol table");return this.st.firstKey()}max(){if(this.isEmpty())throw Error("calls max() with empty symbol table");return this.st.lastKey()}ceiling(t){if(n.nichts(t))throw Error("argument to ceiling() is null");let e,i,s=this.st.keys();for(;s.hasNext();)if(i=s.next(),i==t||i>t){e=i;break}if(void 0===e)throw Error("argument to ceiling() is too large");return e}floor(t){if(n.nichts(t))throw Error("argument to floor() is null");let e,i,s=this.st.keys();for(;s.hasNext();)i=s.next(),(i==t||i<t)&&(e=i);if(void 0===e)throw Error("argument to floor() is too small");return e}static test(){let t=new g;t.put("a",1),t.put("g",9),t.put("c",3),t.put("j",10),t.put("z",26),t.put("x",24),console.log("isEmpty= "+t.isEmpty()),console.log("size= "+t.size()),console.log("get-c= "+t.get("c")),console.log("contains z= "+t.contains("z")),console.log("contains m= "+t.contains("m")),console.log(o(t.keys())),console.log("ceil w= "+t.ceiling("w")),console.log("floor k= "+t.floor("k")),console.log("min = "+t.min()),console.log("max = "+t.max()),t.remove("x"),console.log(o(t.keys()))}}class p{static M=4;Node(t){return{m:t,children:new Array(p.M)}}Entry(t,e,i=null){return{key:t,val:e,next:i}}constructor(t){this.root=this.Node(0),this.compare=t,this._height=0,this.n=0}isEmpty(){return 0==this.size()}size(){return this.n}height(){return this._height}get(t){if(n.nichts(t))throw Error("argument to get() is null");return this._search(this.root,t,this._height)}_search(t,e,i){let s=t.children;if(0==i){for(let i=0;i<t.m;++i)if(0==this.compare(e,s[i].key))return s[i].val}else for(let r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,s[r+1].key)<0)return this._search(s[r].next,e,i-1)}put(t,e){if(n.nichts(t))throw Error("argument key to put() is null");let i,s=this._insert(this.root,t,e,this._height);this.n+=1,s&&(i=this.Node(2),i.children[0]=this.Entry(this.root.children[0].key,null,this.root),i.children[1]=this.Entry(s.children[0].key,null,s),this.root=i,this._height+=1)}_insert(t,e,i,s){let r,n=this.Entry(e,i);if(0==s)for(r=0;r<t.m&&!(this.compare(e,t.children[r].key)<0);++r);else for(r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,t.children[r+1].key)<0){let o=this._insert(t.children[r++].next,e,i,s-1);if(!o)return null;n.key=o.children[0].key,n.val=null,n.next=o;break}for(let e=t.m;e>r;--e)t.children[e]=t.children[e-1];if(t.children[r]=n,t.m++,t.m>=p.M)return this._split(t)}_split(t){let e=s(p.M/2),i=this.Node(e);t.m=e;for(let s=0;s<e;++s)i.children[s]=t.children[e+s];return i}toString(){return function t(e,i,s){let r="",n=e.children;if(0==i)for(let t=0;t<e.m;++t)r+=`${s}${n[t].key} ${n[t].val}\n`;else for(let o=0;o<e.m;++o)o>0&&(r+=`${s}(${n[o].key})\n`),r+=t(n[o].next,i-1,s+"     ");return r}(this.root,this._height,"")+"\n"}static test(){let t=new p(i);t.put("www.cs.princeton.edu","128.112.136.12"),t.put("www.cs.princeton.edu","128.112.136.11"),t.put("www.princeton.edu","128.112.128.15"),t.put("www.yale.edu","130.132.143.21"),t.put("www.simpsons.com","209.052.165.60"),t.put("www.apple.com","17.112.152.32"),t.put("www.amazon.com","207.171.182.16"),t.put("www.ebay.com","66.135.192.87"),t.put("www.cnn.com","64.236.16.20"),t.put("www.google.com","216.239.41.99"),t.put("www.nytimes.com","199.239.136.200"),t.put("www.microsoft.com","207.126.99.140"),t.put("www.dell.com","143.166.224.230"),t.put("www.slashdot.org","66.35.250.151"),t.put("www.espn.com","199.181.135.201"),t.put("www.weather.com","63.111.66.11"),t.put("www.yahoo.com","216.109.118.65"),console.log("cs.princeton.edu:  "+t.get("www.cs.princeton.edu")),console.log("hardvardsucks.com: "+t.get("www.harvardsucks.com")),console.log("simpsons.com:      "+t.get("www.simpsons.com")),console.log("apple.com:         "+t.get("www.apple.com")),console.log("ebay.com:          "+t.get("www.ebay.com")),console.log("dell.com:          "+t.get("www.dell.com")),console.log(""),console.log("size:    "+t.size()),console.log("height:  "+t.height()),console.log(t.toString()),console.log("")}}class m{constructor(t){this.d=t,this.st=new g}put(t,e){if(t<0||t>=this.d)throw Error("Illegal index");n.feq0(e)?this.st.remove(t):this.st.put(t,e)}get(t){if(t<0||t>=this.d)throw Error("Illegal index");return this.st.contains(t)?this.st.get(t):0}nnz(){return this.st.size()}dimension(){return this.d}dot(t){if(n.assert(t instanceof m,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e,i=0,s=(this.st.size()<=t.st.size()?this:t).st.keys();for(;s.hasNext();)e=s.next(),t.st.contains(e)&&(i+=this.get(e)*t.get(e));return i}dotWith(t){let e=0;for(let i,s=this.st.keys();s.hasNext();)i=s.next(),e+=t[i]*this.get(i);return e}magnitude(){return Math.sqrt(this.dot(this))}scale(t){let e=new m(this.d);for(let i,s=this.st.keys();s.hasNext();)i=s.next(),e.put(i,t*this.get(i));return e}plus(t){if(n.assert(t instanceof m,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e=new m(this.d);for(let t,i=this.st.keys();i.hasNext();)t=i.next(),e.put(t,this.get(t));for(let i,s=t.st.keys();s.hasNext();)i=s.next(),e.put(i,t.get(i)+e.get(i));return e}toString(){let t="";for(let e,i=this.st.keys();i.hasNext();)e=i.next(),t+=`(${e}, ${this.st.get(e)}) `;return t}static test(){let t=new m(10),e=new m(10);t.put(3,.5),t.put(9,.75),t.put(6,.11),t.put(6,0),e.put(3,.6),e.put(4,.9),console.log("a = "+t.toString()),console.log("b = "+e.toString()),console.log("a dot b = "+t.dot(e)),console.log("a + b   = "+t.plus(e).toString())}}return{BTree:p,Bag:c,Stack:u,Queue:d,ST:g,TreeMap:f,SparseVector:m,Iterator:l,prnIter:o,StdCompare:i}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core")):t["io/czlab/mcfud/algo/basic"]=e}(this),function(t){"use strict";function e(e,i){e||(e=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/algo/basic"]());const{prnIter:s,Bag:r,Stack:n,Iterator:o,StdCompare:h}=i,l=Math.floor,{is:a,u:c}=e;function u(t,e,i,s,r){c.assert(t>e,"bad resize capacity");let n=new Array(t);for(let t=i;t<s;++t)n[t]=r[t];return n}function d(t,e,i){return i(t,e)<0}function f(t,e,i){const s=t[e];t[e]=t[i],t[i]=s}function g(t){let e="";for(let i=0;i<t.length;++i)e+=t[i]+" ";console.log(e)}class p{static sort(t,e){const i=t.length;for(let s=1;s<i;++s)for(let i=s;i>0&&d(t[i],t[i-1],e);--i)f(t,i,i-1);return t}static sortRange(t,e,i,s){for(let r=e+1;r<i;++r)for(let i=r;i>e&&d(t[i],t[i-1],s);--i)f(t,i,i-1);return t}static indexSort(t,e){const i=t.length,s=c.fill(i,t=>t);for(let r=1;r<i;++r)for(let i=r;i>0&&d(t[s[i]],t[s[i-1]],e);--i)f(s,i,i-1);return s}static test(){let t="SORTEXAMPLE".split("");g(p.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(p.sortRange(t,0,t.length,h)),t="SORTEXAMPLE".split(""),g(p.indexSort(t,h))}}class m{static sort(t,e){let i,s,r,n=t.length;for(let o,h=1;h<n;++h){for(s=0,r=h,o=t[h];s<r;)i=s+l((r-s)/2),d(o,t[i],e)?r=i:s=i+1;for(let e=h;e>s;--e)t[e]=t[e-1];t[s]=o}return t}static test(){let t="SORTEXAMPLE".split("");g(m.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(m.sort(t,h))}}class y{static sort(t,e){let i,s=t.length;for(let r=0;r<s;++r){i=r;for(let n=r+1;n<s;++n)d(t[n],t[i],e)&&(i=n);f(t,r,i)}return t}static test(){let t="SORTEXAMPLE".split("");g(y.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(y.sort(t,h))}}class _{static sort(t,e){let i=t.length,s=1,r=l(i/3);for(;s<r;)s=3*s+1;for(;s>=1;){for(let r=s;r<i;++r)for(let i=r;i>=s&&d(t[i],t[i-s],e);i-=s)f(t,i,i-s);s=l(s/3)}return t}static test(){let t="SORTEXAMPLE".split("");g(_.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(_.sort(t,h))}}function w(t,e,i,s,r,n){if(r<=s);else{let o=s+l((r-s)/2);w(t,e,i,s,o,n),w(t,e,i,o+1,r,n),function(t,e,i,s,r,n,o){for(let t=s;t<=n;++t)i[t]=e[t];let h=s,l=r+1;for(let a=s;a<=n;++a)h>r?e[a]=i[l++]:l>n?e[a]=i[h++]:d(t[i[l]],t[i[h]],o)?e[a]=i[l++]:e[a]=i[h++]}(t,e,i,s,o,r,n)}return t}class x{static sort(t,e){return function t(e,i,s,r,n){if(r<=s);else{let o=s+l((r-s)/2);t(e,i,s,o,n),t(e,i,o+1,r,n),function(t,e,i,s,r,n){for(let s=i;s<=r;++s)e[s]=t[s];let o=i,h=s+1;for(let l=i;l<=r;++l)o>s?t[l]=e[h++]:h>r?t[l]=e[o++]:d(e[h],e[o],n)?t[l]=e[h++]:t[l]=e[o++]}(e,i,s,o,r,n)}return e}(t,new Array(t.length),0,t.length-1,e),t}static indexSort(t,e){let i=t.length,s=c.fill(i,t=>t);return w(t,s,new Array(i),0,i-1,e),s}static test(){let t="SORTEXAMPLE".split("");g(x.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(x.sort(t,h)),t="SORTEXAMPLE".split(""),g(x.indexSort(t,h))}}class k{static sort(t,e){const i=t.length;for(let s,r=0;r<i;++r){s=0;for(let n=i-1;n>r;--n)d(t[n],t[n-1],e)&&(f(t,n,n-1),++s);if(0==s)break}return t}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");k.sort(t,h),g(t)}}function E(t,e,i,s){let r=e,n=t[e],o=i+1;for(;;){for(;d(t[++r],n,s)&&r!=i;);for(;d(n,t[--o],s)&&o!=e;);if(r>=o)break;f(t,r,o)}return f(t,e,o),o}class v{static sort(t,e){return function t(e,i,s,r){if(s<=i);else{let n=E(e,i,s,r);t(e,i,n-1,r),t(e,n+1,s,r)}return e}(t,0,t.length-1,e),t}static select(t,e,i){if(e<0||e>=t.length)throw Error(`index is not between 0 and ${t.length}: ${e}`);let s=0,r=t.length-1;for(;r>s;){let n=E(t,s,r,i);if(n>e)r=n-1;else{if(!(n<e))return t[n];s=n+1}}return t[s]}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");g(v.sort(t,h)),t="SORTEXAMPLE".split(""),g(v.sort(t,h)),c.shuffle(t),t.forEach((e,i)=>console.log(v.select(t,i,h)))}}function b(t,e,i,s){return d(t[e],t[i],s)}class N{Node(t){return{key:t,order:0,prev:null,next:null,child:null}}constructor(t,e){this.compare=t,this.table=new Map,this.head=null,this._min=null,this.n=0,a.vec(e)&&e.forEach(t=>this.insert(t))}isEmpty(){return 0==this.n}size(){return this.n}insert(t){let e=this.Node(t);this.n+=1,this.head=this._insertNode(e,this.head),this._min=this._min?this._greater(this._min.key,t)?this.head:this._min:this.head}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cut(this._min,this.head);let t=this._min.child,e=this._min.key;return this._min.key=null,t&&(this.head=this._meld(this.head,t),this._min.child=null),this.n-=1,this.isEmpty()?this._min=null:this._consolidate(),e}union(t){return this.head=this._meld(this.head,t.head),this._min=this._greater(this._min.key,t._min.key)?t._min:this._min,this.n=this.n+t.n,this}_greater(t,e){return!c.nichts(t)&&(!!c.nichts(e)||this.compare(t,e)>0)}_link(t,e){e.child=this._insertNode(t,e.child),e.order+=1}_consolidate(){this.table.clear();let t=this.head,e=null,i=null,s=0;this._min=this.head;do{for(e=t,t=t.next,i=this.table.get(e.order);i;)this.table.delete(e.order),this._greater(e.key,i.key)?(this._link(e,i),e=i):this._link(i,e),i=this.table.get(e.order);this.table.set(e.order,e),e.order>s&&(s=e.order)}while(t!==this.head);this.head=null,this.table.forEach(t=>{t&&(this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head))})}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cut(t,e){if(t.next===t)return t.next=null,t.prev=null,null;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=null,t.prev=null,e===t?i:e}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new N(this.compare),e=i=>{if(!i)return;let s=i;do{t.insert(s.key),e(s.child),s=s.next}while(s!==i)};return e(this.head),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new N(h);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ",e.isEmpty(),console.log(t),console.log("min= "+e.min()),console.log(s(e.iter())),console.log("("+e.size()+" left on pq)");let i=new N(h);"ZTAK".split("").forEach(t=>i.insert(t)),i=i.union(e),console.log(s(i.iter()))}}class M{Node(t){return{key:t,order:0,index:0,prev:null,next:null,parent:null,child:null,mark:!1}}constructor(t,e){if(t<0)throw Error("Cannot create a priority queue of negative size");this.maxN=t,this.n=0,this.head=null,this._min=null,this.compare=e,this.table=new Map,this.nodes=new Array(t)}isEmpty(){return 0==this.n}contains(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");return c.echt(this.nodes[t])}size(){return this.n}insert(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(this.contains(t))throw Error("Specified index is already in the queue");let i=this.Node(e);i.index=t,this.nodes[t]=i,this.n+=1,this.head=this._insertNode(i,this.head),this._min=this._min?this._greater(this._min.key,e)?this.head:this._min:this.head}minIndex(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.index}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cutNode(this._min,this.head);let t=this._min.child,e=this._min.index;if(this._min.key=null,t){do{t.parent=null,t=t.next}while(t!==this._min.child);this.head=this._meld(this.head,t),this._min.child=null}return this.n-=1,this.isEmpty()?this._min=null:this._consolidate(),this.nodes[e]=null,e}keyOf(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");return this.nodes[t].key}changeKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");this._greater(e,this.nodes[t].key)?this.increaseKey(t,e):this.decreaseKey(t,e)}decreaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(e,this.nodes[t].key))throw Error("Calling with this argument would not decrease the key");let i=this.nodes[t];i.key=e,this._greater(this._min.key,e)&&(this._min=i),i.parent&&this._greater(i.parent.key,e)&&this._cut(t)}increaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(this.nodes[t].key,e))throw Error("Calling with this argument would not increase the key");this.delete(t),this.insert(t,e)}delete(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");let e=this.nodes[t];if(e.key=null,e.parent&&this._cut(t),this.head=this._cutNode(e,this.head),e.child){let t=e.child;e.child=null,e=t;do{t.parent=null,t=t.next}while(t!==e);this.head=this._meld(this.head,t)}this.isEmpty()?this._min=null:this._consolidate(),this.nodes[t]=null,this.n-=1}_greater(t,e){return!c.nichts(t)&&(!!c.nichts(e)||this.compare(t,e)>0)}_link(t,e){t.parent=e,e.child=this._insertNode(t,e.child),e.order+=1}_cut(t){let e=this.nodes[t],i=e.parent;i.child=this._cutNode(e,i.child),e.parent=null,i.order-=1,this.head=this._insertNode(e,this.head),i.mark=!i.mark,!i.mark&&i.parent&&this._cut(i.index)}_consolidate(){let t=null,e=null,i=0,s=this.head;this.table.clear(),this._min=this.head;do{for(t=s,s=s.next,e=this.table.get(t.order);e;)this.table.delete(t.order),this._greater(t.key,e.key)?(this._link(t,e),t=e):this._link(e,t),e=this.table.get(t.order);this.table.set(t.order,t),t.order>i&&(i=t.order)}while(s!==this.head);this.head=null,this.table.forEach(t=>{this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head)})}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cutNode(t,e){if(t.next===t)return t.next=null,t.prev=null,null;{t.next.prev=t.prev,t.prev.next=t.next;let i=t.next;return t.next=null,t.prev=null,e===t?i:e}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new M(this.maxN,this.compare);return this.nodes.forEach(e=>{e&&t.insert(e.index,e.key)}),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new M(t.length,h);for(let i=0;i<t.length;++i)e.insert(i,t[i]);for(console.log("min= "+e.min()),console.log("minindex= "+e.minIndex()),console.log("size= "+e.size()),console.log("contains(3)="+e.contains(3)),console.log("keyOf(3)="+e.keyOf(3)),e.changeKey(3,"bbbb");!e.isEmpty();){let t=e.minIndex();console.log(t+" "+e.keyOf(t)),e.delMin()}console.log("");for(let i=0;i<t.length;++i)e.insert(i,t[i]);for(let i,s=e.iter();s.hasNext();)i=s.next(),console.log(i+" "+t[i]);for(;!e.isEmpty();)e.delMin()}}class q{constructor(t,e){if(this.comparator=t,this.n=0,a.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=l(this.n/2);t>=1;--t)this._sink(t,this)}else this.pq=new Array(a.num(e)?e:2);c.assert(this._isMinHeap(),"not min heap")}isEmpty(){return 0==this.n}size(){return this.n}min(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=u(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.pq[++this.n]=t,this._swim(this.n),c.assert(this._isMinHeap(),"not min heap-insert")}delMin(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return f(this.pq,1,this.n--),this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==l((this.pq.length-1)/4)&&(this.pq=u(l(this.pq.length/2),this.n,1,this.n+1,this.pq)),t}_swim(t){for(;t>1&&this._greater(l(t/2),t);)f(this.pq,t,l(t/2)),t=l(t/2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&e++,!this._greater(t,e))break;f(this.pq,t,e),t=e}}_greater(t,e){return this.comparator(this.pq[t],this.pq[e])>0}_isMinHeap(){for(let t=1;t<=this.n;++t)if(c.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(!c.nichts(this.pq[t]))return!1;return!c.echt(this.pq[0])&&this._isMinHeapOrdered(1)}_isMinHeapOrdered(t){if(t>this.n)return!0;let e=2*t,i=2*t+1;return!(e<=this.n&&this._greater(t,e))&&(!(i<=this.n&&this._greater(t,i))&&(this._isMinHeapOrdered(e)&&this._isMinHeapOrdered(i)))}iter(){let t=new q(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new q(h);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}class z{constructor(t,e){if(this.comparator=t,this.n=0,a.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=l(this.n/2);t>=1;--t)this._sink(t)}else this.pq=new Array(a.num(e)?e:2);c.assert(this._isMaxHeap(),"not max heap")}isEmpty(){return 0==this.n}size(){return this.n}max(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=u(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.n+=1,this.pq[this.n]=t,this._swim(this.n),c.assert(this._isMaxHeap(),"not max heap-insert")}delMax(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return f(this.pq,1,this.n),this.n-=1,this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==l((this.pq.length-1)/4)&&(this.pq=u(l(this.pq.length/2),this.n,1,this.n+1,this.pq)),t}_isMaxHeap(){for(let t=1;t<=this.n;++t)if(c.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(c.echt(this.pq[t]))return!1;return!c.echt(this.pq[0])&&this._isMaxHeapOrdered(1)}_isMaxHeapOrdered(t){if(t>this.n)return!0;let e=2*t,i=2*t+1;return!(e<=this.n&&b(this.pq,t,e,this.comparator))&&(!(i<=this.n&&b(this.pq,t,i,this.comparator))&&(this._isMaxHeapOrdered(e)&&this._isMaxHeapOrdered(i)))}_swim(t){for(;t>1&&b(this.pq,l(t/2),t,this.comparator);)f(this.pq,t,l(t/2)),t=l(t/2)}_sink(t){let e;for(;2*t<=this.n&&(e=2*t,e<this.n&&b(this.pq,e,e+1,this.comparator)&&++e,b(this.pq,t,e,this.comparator));)f(this.pq,t,e),t=e}iter(){const t=new z(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t="",e=new z(h);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}function T(t,e,i,s){return s(t[e-1],t[i-1])<0}function S(t,e,i){const s=t[e-1];t[e-1]=t[i-1],t[i-1]=s}class A{static sort(t,e){function i(t,e,i,s){for(;2*e<=i;){let r=2*e;if(r<i&&T(t,r,r+1,s)&&++r,!T(t,e,r,s))break;S(t,e,r),e=r}}let s,r=t.length;for(s=l(r/2);s>=1;--s)i(t,s,r,e);for(s=r;s>1;)S(t,1,s--),i(t,1,s,e);return t}static test(){let t="SORTEXAMPLE".split("");g(A.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(A.sort(t,h))}}class O{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}minIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}minKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMin(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),c.assert(t==this.pq[this.n+1],"No good"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let i=this.compare(this.mKeys[t],e);if(0==i)throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(i<0)throw Error("Calling decreaseKey() with a key strictly greater than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let i=this.compare(this.mKeys[t],e);if(0==i)throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(i>0)throw Error("Calling increaseKey() with a key strictly less than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let e=this.qp[t];this._exch(e,this.n--),this._swim(e),this._sink(e),this.mKeys[t]=null,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_greater(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])>0}_exch(t,e){let i=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=i,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._greater(l(t/2),t);)this._exch(t,l(t/2)),t=l(t/2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&++e,!this._greater(t,e))break;this._exch(t,e),t=e}}iter(){let t=new O(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new O(t.length,h);for(let i=0;i<t.length;++i)e.insert(i,t[i]);for(;!e.isEmpty();){let i=e.delMin();console.log(i+" "+t[i])}console.log("");for(let i=0;i<t.length;++i)e.insert(i,t[i]);for(let i,s=e.iter();s.hasNext();)i=s.next(),console.log(i+" "+t[i]);for(;!e.isEmpty();)e.delMin()}}class P{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}maxIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}maxKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMax(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),c.assert(this.pq[this.n+1]==t,"bad delMax"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)>0)throw Error("Calling increaseKey() with a key that is strictly less than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)<0)throw Error("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let e=this.qp[t];this._exch(e,this.n--),this._swim(e),this._sink(e),this.mKeys[t]=null,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_less(t,e){return d(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]],this.compare)}_exch(t,e){let i=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=i,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._less(l(t/2),t);)this._exch(t,l(t/2)),t=l(t/2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._less(e,e+1)&&++e,!this._less(t,e))break;this._exch(t,e),t=e}}iter(){let t=new P(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new P(t.length,h);for(let i=0;i<t.length;++i)e.insert(i,t[i]);for(let i,s=e.iter();s.hasNext();)i=s.next(),console.log(i+" "+t[i]);console.log("");for(let i=0;i<t.length;++i)c.rand()<.5?e.increaseKey(i,t[i]+t[i]):e.decreaseKey(i,t[i].substring(0,1));for(;!e.isEmpty();){let t=e.maxKey(),i=e.delMax();console.log(i+" "+t)}console.log("");for(let i=0;i<t.length;++i)e.insert(i,t[i]);let i=new Array(t.length);for(let e=0;e<t.length;++e)i[e]=e;c.shuffle(i);for(let t=0;t<i.length;++t){let s=e.keyOf(i[t]);e.delete(i[t]),console.log(i[t]+" "+s)}}}return{FibonacciMinPQ:N,IndexFibonacciMinPQ:M,Insertion:p,BinaryInsertion:m,Selection:y,Shell:_,Merge:x,Bubble:k,Quick:v,MinPQ:q,MaxPQ:z,Heap:A,IndexMinPQ:O,IndexMaxPQ:P}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic")):t["io/czlab/mcfud/algo/sort"]=e}(this),function(t){"use strict";function e(e,i,s){e||(e=t["io/czlab/mcfud/core"]()),i||(i=t["io/czlab/mcfud/algo/basic"]()),s||(s=t["io/czlab/mcfud/algo/sort"]());const{Bag:r,Stack:n,Queue:o,StdCompare:h,prnIter:l}=i,{MinPQ:a}=s,c=Math.floor,{is:u,u:d}=e;class f{static count(t,e){let i=new Map,s=0,r="",n=0;for(let r,o=0;o<t.length;++o)r=t[o],r.length<e||(++s,i.has(r)?i.set(r,i.get(r)+1):(i.set(r,1),++n));return i.set(r,0),Array.from(i.keys()).forEach(t=>{i.get(t)>i.get(r)&&(r=t)}),[r,i.get(r),[n,s]]}static test(){let t="it was the best of times it was the worst of times\n        it was the age of wisdom it was the age of foolishness\n        it was the epoch of belief it was the epoch of incredulity\n        it was the season of light it was the season of darkness\n        it was the spring of hope it was the winter of despair".split(" "),[e,i,s]=f.count(t,1);console.log(e+" "+i),console.log("distinct = "+s[0]),console.log("words= "+s[1])}}class g{constructor(){this.first=null,this.n=0}size(){return this.n}isEmpty(){return 0==this.size()}contains(t){if(d.nichts(t))throw Error("argument to contains is null");return void 0!==this.get(t)}get(t){if(d.nichts(t))throw Error("argument to get is null");for(let e=this.first;e;e=e.next)if(t==e.key)return e.val}put(t,e){if(d.nichts(t))throw Error("first argument to put is null");if(void 0===e)this.delete(t);else{let i,s;for(s=this.first;s&&!i;s=s.next)t==s.key&&(s.val=e,i=!0);i||(this.first=function(t,e,i){return{key:t,val:e,next:i}}(t,e,this.first),this.n+=1)}}delete(t){const e=(t,i)=>t?i==t.key?(this.n-=1,t.next):(t.next=e(t.next,i),t):null;if(d.nichts(t))throw Error("argument to delete is null");this.first=e(this.first,t)}keys(){let t=new o;for(let e=this.first;e;e=e.next)t.enqueue(e.key);return t.iter()}static load(t){let e=new g;return t.forEach((t,i)=>e.put(t,i)),e}static test(){let t=g.load("SEARCHEXAMPLE".split(""));console.log(((e="",i=0,s=0)=>{for(s=t.keys();s.hasNext();)e+=`${i=s.next()}=${t.get(i)} `;return e})()),console.log("size= "+t.size()),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),t.delete("R"),t.isEmpty(),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),console.log("size= "+t.size())}}class p{constructor(t,e=2){this.mKeys=new Array(e),this.vals=new Array(e),this.compare=t,this.n=0,this._resize=t=>{let e=new Array(t),i=new Array(t);for(let t=0;t<this.n;++t)e[t]=this.mKeys[t],i[t]=this.vals[t];this.vals=i,this.mKeys=e},this._argOk=t=>d.echt(t,"Invalid argument"),this._check=()=>(()=>{for(let t=1;t<this.size();++t)if(this.compare(this.mKeys[t],this.mKeys[t-1])<0)return!1;return!0})()&&(()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0;t<this.size();++t)if(0!=this.compare(this.mKeys[t],this.select(this.rank(this.mKeys[t]))))return!1;return!0})()}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){if(this._argOk(t)&&!this.isEmpty()){let e=this.rank(t);if(e<this.n&&0==this.compare(this.mKeys[e],t))return this.vals[e]}}rank(t){let e,i,s=0,r=this.n-1;for(this._argOk(t);s<=r;)if(e=s+c((r-s)/2),i=this.compare(t,this.mKeys[e]),i<0)r=e-1;else{if(!(i>0))return e;s=e+1}return s}put(t,e){if(this._argOk(t)&&void 0===e)this.delete(t);else{let i=this.rank(t);if(i<this.n&&0==this.compare(this.mKeys[i],t))this.vals[i]=e;else{this.n==this.mKeys.length&&this._resize(2*this.mKeys.length);for(let t=this.n;t>i;--t)this.mKeys[t]=this.mKeys[t-1],this.vals[t]=this.vals[t-1];this.n+=1,this.mKeys[i]=t,this.vals[i]=e}}}delete(t){if(this._argOk(t)&&this.isEmpty());else{let e=this.rank(t);if(e==this.n||0!=this.compare(this.mKeys[e],t));else{for(let t=e;t<this.n-1;++t)this.mKeys[t]=this.mKeys[t+1],this.vals[t]=this.vals[t+1];this.n-=1,this.mKeys[this.n]=null,this.vals[this.n]=null,this.n>0&&this.n==c(this.mKeys.length/4)&&this._resize(c(this.mKeys.length/2)),this._check()}}}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.min())}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.max())}min(){if(this.isEmpty())throw Error("called min with empty symbol table");return this.mKeys[0]}max(){if(this.isEmpty())throw Error("called max with empty symbol table");return this.mKeys[this.n-1]}select(t){if(t<0||t>=this.size())throw Error("called select with invalid argument: "+t);return this.mKeys[t]}floor(t){let e=this._argOk(t)&&this.rank(t);if(e<this.n&&0==this.compare(t,this.mKeys[e]))return this.mKeys[e];if(0==e)throw Error("argument to floor is too small");return this.mKeys[e-1]}ceiling(t){let e=this._argOk(t)&&this.rank(t);if(e==this.n)throw Error("argument to ceiling is too large");return this.mKeys[e]}size(t,e){return 0==arguments.length?this.n:(this._argOk(t)&&this._argOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}keys(t,e){0==arguments.length&&(t=this.min(),e=this.max()),this._argOk(t)&&this._argOk(e);let i=new o;if(this.compare(t,e)>0);else{for(let s=this.rank(t);s<this.rank(e);++s)i.enqueue(this.mKeys[s]);this.contains(e)&&i.enqueue(this.mKeys[this.rank(e)])}return i.iter()}static load(t,e){let i=new p(e);return t.forEach((t,e)=>i.put(t,e)),i}static test(){let t=p.load("SEARCHEXAMPLE".split(""),h),e=e=>{e="";for(let i,s=t.keys();s.hasNext();)i=s.next(),e+=`${i}=${t.get(i)} `;return e};console.log(e()),t.deleteMin(),console.log(e()),t.deleteMax(),t.isEmpty(),console.log(e()),console.log("floor of Q= "+t.floor("Q")),console.log("ceil of Q= "+t.ceiling("Q")),console.log("size= "+t.size()),console.log("size= "+t.size("E","P")),console.log("keys E->P = "+l(t.keys("E","P")))}}class m{constructor(t){this.compare=t,this.root=null,this._argOk=t=>d.assert(t,"Invalid argument"),this._check=()=>(this.isBST(this.root,null,null)||console.log("Not in symmetric order"),this.isSizeConsistent(this.root)||console.log("Subtree counts not consistent"),this.isRankConsistent()||console.log("Ranks not consistent"),this.isBST(this.root,null,null)&&this.isSizeConsistent(this.root)&&this.isRankConsistent()),this.isBST=(t,e,i)=>!!d.nichts(t)||!(d.echt(e)&&this.compare(t.key,e)<=0)&&(!(d.echt(i)&&this.compare(t.key,i)>=0)&&(this.isBST(t.left,e,t.key)&&this.isBST(t.right,t.key,i))),this.isSizeConsistent=t=>!!d.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(this.isSizeConsistent(t.left)&&this.isSizeConsistent(t.right)),this.isRankConsistent=()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this.rank(t))))return!1;return!0}}Node(t,e,i){return{key:t,val:e,size:i,left:null,right:null}}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){return this._getNode(this.root,t)}_getNode(t,e){if(!this._argOk(e)||!d.nichts(t)){let i=this.compare(e,t.key);return i<0?this._getNode(t.left,e):i>0?this._getNode(t.right,e):t.val}}put(t,e){this._argOk(t)&&d.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this._check())}_putNode(t,e,i){if(d.nichts(t))t=this.Node(e,i,1);else{let s=this.compare(e,t.key);s<0?t.left=this._putNode(t.left,e,i):s>0?t.right=this._putNode(t.right,e,i):t.val=i,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right)}return t}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMinNode(this.root),this._check()}_deleteMinNode(t){return d.nichts(t.left)?t=t.right:(t.left=this._deleteMinNode(t.left),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMaxNode(this.root),this._check()}_deleteMaxNode(t){return d.nichts(t.right)?t=t.left:(t.right=this._deleteMaxNode(t.right),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}delete(t){this.root=this._argOk(t)&&this._deleteNode(this.root,t),this._check()}_deleteNode(t,e){if(d.echt(t)){let i=this.compare(e,t.key);if(i<0)t.left=this._deleteNode(t.left,e);else if(i>0)t.right=this._deleteNode(t.right,e);else{if(d.nichts(t.right))return t.left;if(d.nichts(t.left))return t.right;let e=t;(t=this._minNode(e.right)).right=this._deleteMinNode(e.right),t.left=e.left}t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1}return t}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return d.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return d.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(d.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(d.nichts(t))return null;let i=this.compare(e,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,e);let s=this._floorNode(t.right,e);return d.nichts(s)?t:s}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(d.nichts(e))throw Error("argument to floor is too large");return e.key}_ceilingNode(t,e){if(d.nichts(t))return null;let i=this.compare(e,t.key);if(0==i)return t;if(i<0){let i=this._ceilingNode(t.left,e);return i||t}return this._ceilingNode(t.right,e)}select(t){if(t<0||t>=this.size())throw Error("argument to select is invalid: "+t);return this._selectNode(this.root,t)}_selectNode(t,e){if(d.nichts(t))return null;let i=this._sizeNode(t.left);return i>e?this._selectNode(t.left,e):i<e?this._selectNode(t.right,e-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(d.nichts(e))return 0;let i=this.compare(t,e.key);return i<0?this._rankNode(t,e.left):i>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let i=new o;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,i,t,e),i.iter()}_keysNode(t,e,i,s){if(d.nichts(t));else{let r=this.compare(i,t.key),n=this.compare(s,t.key);r<0&&this._keysNode(t.left,e,i,s),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,i,s)}return e}_sizeNode(t){return d.nichts(t)?0:t.size}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}height(){return this._heightNode(this.root)}_heightNode(t){return d.nichts(t)?-1:1+Math.max(this._heightNode(t.left),this._heightNode(t.right))}levelOrder(){let t,e=[],i=new o;for(e.push(this.root);e.length>0;)t=e.pop(),d.echt(t)&&(i.enqueue(t.key),e.push(t.left,t.right));return i.iter()}static load(t,e){let i=new m(e);return t.forEach((t,e)=>i.put(t,e)),i}static test(){let t,e=m.load("SEARCHEXAMPLE".split(""),h);t="";for(let i,s=e.levelOrder();s.hasNext();)i=s.next(),t+=`${i}=${e.get(i)} `;console.log("level-order:\n"+t),t="";for(let i,s=e.keys();s.hasNext();)i=s.next(),t+=`${i}=${e.get(i)} `;e.isEmpty(),console.log("keys=\n"+t),console.log("size="+e.size()),console.log("size E->Q = ",e.size("E","Q")),t="";for(let i,s=e.keys("E","Q");s.hasNext();)i=s.next(),t+=`${i}=${e.get(i)} `;console.log("keys[E->Q]= "+t),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank P= "+e.rank("P")),console.log("contains X= "+e.contains("X")),console.log("contains Z= "+e.contains("Z")),e.delete("X"),console.log("get C="+e.get("C")),console.log("max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("height= "+e.height()),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank E= "+e.rank("E")),console.log("floor G= "+e.floor("G")),console.log("ceiling G= "+e.ceiling("G"))}}class y{static BLACK=!1;static RED=!0;constructor(t){this.compare=t,this.root=null,this._argOk=t=>d.assert(t,"Invalid argument"),this._check=()=>{let t=(e,i,s)=>!!d.nichts(e)||!(i&&this.compare(e.key,i)<=0)&&(!(s&&this.compare(e.key,s)>=0)&&(t(e.left,i,e.key)&&t(e.right,e.key,s))),e=t=>!!d.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(e(t.left)&&e(t.right)),i=t=>!!d.nichts(t)||!this._isRed(t.right)&&((t===this.root||!this._isRed(t)||!this._isRed(t.left))&&(i(t.left)&&i(t.right))),s=(t,e)=>d.nichts(t)?0==e:(this._isRed(t)||--e,s(t.left,e)&&s(t.right,e));return t(this.root,null,null)&&e(this.root)&&(()=>{for(let t=0;t<this.size();++t)if(t!=this._rankNode(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this._rankNode(t))))return!1;return!0})()&&i(this.root)&&(()=>{let t=0,e=this.root;for(;e;)this._isRed(e)||++t,e=e.left;return s(this.root,t)})()}}Node(t,e,i,s){return{key:t,val:e,color:i,size:s,left:null,right:null}}_isRed(t){return!d.nichts(t)&&t.color===y.RED}_sizeNode(t){return d.nichts(t)?0:t.size}isEmpty(){return d.nichts(this.root)}get(t){return this._argOk(t)&&this._getNode(this.root,t)}_getNode(t,e){for(;t;){let i=this.compare(e,t.key);if(i<0)t=t.left;else{if(!(i>0))return t.val;t=t.right}}}contains(t){return void 0!==this.get(t)}put(t,e){this._argOk(t)&&d.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.root.color=y.BLACK)}_putNode(t,e,i){if(d.nichts(t))return this.Node(e,i,y.RED,1);let s=this.compare(e,t.key);return s<0?t.left=this._putNode(t.left,e,i):s>0?t.right=this._putNode(t.right,e,i):t.val=i,this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}deleteMin(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=y.RED),this.root=this._deleteMinNode(this.root),this.isEmpty()||(this.root.color=y.BLACK)}_deleteMinNode(t){return d.nichts(t.left)?null:(this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteMinNode(t.left),this._balance(t))}deleteMax(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=y.RED),this.root=this._deleteMaxNode(this.root),this.isEmpty()||(this.root.color=y.BLACK)}_deleteMaxNode(t){return this._isRed(t.left)&&(t=this._rotateRight(t)),d.nichts(t.right)?null:(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),t.right=this._deleteMaxNode(t.right),this._balance(t))}delete(t){this._argOk(t)&&!this.contains(t)||(this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=y.RED),this.root=this._deleteNode(this.root,t),this.isEmpty()||(this.root.color=y.BLACK))}_deleteNode(t,e){if(this.compare(e,t.key)<0)this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteNode(t.left,e);else{if(this._isRed(t.left)&&(t=this._rotateRight(t)),0==this.compare(e,t.key)&&d.nichts(t.right))return null;if(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),0==this.compare(e,t.key)){let e=this._minNode(t.right);t.key=e.key,t.val=e.val,t.right=this._deleteMinNode(t.right)}else t.right=this._deleteNode(t.right,e)}return this._balance(t)}_rotateRight(t){if(d.nichts(t)||!this._isRed(t.left))throw Error("bad input to rotateRight");let e=t.left;return t.left=e.right,e.right=t,e.color=e.right.color,e.right.color=y.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_rotateLeft(t){if(d.nichts(t)||!this._isRed(t.right))throw Error("bad input to rotateLeft");let e=t.right;return t.right=e.left,e.left=t,e.color=e.left.color,e.left.color=y.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_flipColors(t){t.color=!t.color,t.left.color=!t.left.color,t.right.color=!t.right.color}_moveRedLeft(t){return this._flipColors(t),this._isRed(t.right.left)&&(t.right=this._rotateRight(t.right),t=this._rotateLeft(t),this._flipColors(t)),t}_moveRedRight(t){return this._flipColors(t),this._isRed(t.left.left)&&(t=this._rotateRight(t),this._flipColors(t)),t}_balance(t){return this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}height(){return this._height(this.root)}_height(t){return d.nichts(t)?-1:1+Math.max(this._height(t.left),this._height(t.right))}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return d.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return d.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(d.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(d.nichts(t))return null;let i=this.compare(e,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,e);let s=this._floorNode(t.right,e);return s||t}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(d.nichts(e))throw Error("argument to ceiling is too small");return e.key}_ceilingNode(t,e){if(d.nichts(t))return null;let i=this.compare(e,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,e);let s=this._ceilingNode(t.left,e);return s||t}select(t){if(t<0||t>=this.size())throw Error("argument to select is invalid: "+t);return this._selectNode(this.root,t)}_selectNode(t,e){if(d.nichts(t))return null;let i=this._sizeNode(t.left);return i>e?this._selectNode(t.left,e):i<e?this._selectNode(t.right,e-i-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(d.nichts(e))return 0;let i=this.compare(t,e.key);return i<0?this._rankNode(t,e.left):i>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let i=new o;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,i,t,e),i.iter()}_keysNode(t,e,i,s){if(t){let r=this.compare(i,t.key),n=this.compare(s,t.key);r<0&&this._keysNode(t.left,e,i,s),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,i,s)}return e}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}static load(t,e){let i=new y(e);return t.forEach((t,e)=>i.put(t,e)),i}static test(){let t,e=y.load("SEARCHEXAMPLE".split(""),h);t="";for(let i,s=e.keys();s.hasNext();)i=s.next(),t+=`${i}=${e.get(i)} `;console.log(t),e.isEmpty(),console.log("height= "+e.height()+", size= "+e.size()),console.log("get X= "+e.get("X")),console.log("contains X= "+e.contains("X")),console.log("min= "+e.min()+",max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("min= "+e.min()+",max= "+e.max()),e.delete("R"),console.log("contains R= "+e.contains("R")),console.log("floor J= "+e.floor("J")),console.log("ceiling J= "+e.ceiling("J")),console.log("rank M= "+e.rank("M")),t="";for(let i,s=e.keys("D","Q");s.hasNext();)i=s.next(),t+=`${i}=${e.get(i)} `;console.log("keys[D-Q]= "+t),console.log("size[E-P]= "+e.size("E","P"))}}class _{static indexOf(t,e){let i=0,s=t.length-1;for(;i<=s;){let r=i+c((s-i)/2);if(e<t[r])s=r-1;else{if(!(e>t[r]))return r;i=r+1}}return-1}static test(){let t="84 48 68 10 18 98 12 23 54 57 33 16 77 11 29".split(" ").map(t=>+t).sort();"23 50 10 99 18 23 98 84 11 10 48 77 13 54 98 77 77 68".split(" ").map(t=>+t).forEach(e=>{_.indexOf(t,e)<0&&console.log(e)})}}class w{Node(t,e,i,s){return{key:t,val:e,height:i,size:s,left:null,right:null}}constructor(t){this.compare=t,this.root=null}isEmpty(){return d.nichts(this.root)}_sizeNode(t){return d.nichts(t)?0:t.size}height(){return this._heightNode(this.root)}_heightNode(t){return d.nichts(t)?-1:t.height}get(t){if(d.nichts(t))throw Error("argument to get() is null");let e=this._getNode(this.root,t);if(e)return e.val}_getNode(t,e){if(!t)return null;let i=this.compare(e,t.key);return i<0?this._getNode(t.left,e):i>0?this._getNode(t.right,e):t}contains(t){return void 0!==this.get(t)}put(t,e){if(d.nichts(t))throw Error("first argument to put() is null");void 0===e?this.delete(t):this.root=this._putNode(this.root,t,e)}_putNode(t,e,i){if(!t)return this.Node(e,i,0,1);let s=this.compare(e,t.key);if(s<0)t.left=this._putNode(t.left,e,i);else{if(!(s>0))return t.val=i,t;t.right=this._putNode(t.right,e,i)}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balanceNode(t)}_balanceNode(t){return this._balanceFactor(t)<-1?(this._balanceFactor(t.right)>0&&(t.right=this._rotateRight(t.right)),t=this._rotateLeft(t)):this._balanceFactor(t)>1&&(this._balanceFactor(t.left)<0&&(t.left=this._rotateLeft(t.left)),t=this._rotateRight(t)),t}_balanceFactor(t){return this._heightNode(t.left)-this._heightNode(t.right)}_rotateRight(t){let e=t.left;return t.left=e.right,e.right=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}_rotateLeft(t){let e=t.right;return t.right=e.left,e.left=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}delete(t){if(d.nichts(t))throw Error("argument to delete() is null");this.contains(t)&&(this.root=this._deleteNode(this.root,t))}_deleteNode(t,e){let i=this.compare(e,t.key);if(i<0)t.left=this._deleteNode(t.left,e);else if(i>0)t.right=this._deleteNode(t.right,e);else{if(!t.left)return t.right;if(!t.right)return t.left;let e=t;(t=this.min(e.right)).right=this.deleteMin(e.right),t.left=e.left}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)}deleteMin(){if(this.isEmpty())throw Error("called deleteMin() with empty symbol table");this.root=this._deleteMinNode(this.root)}_deleteMinNode(t){return t.left?(t.left=this._deleteMinNode(t.left),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.right}deleteMax(){if(this.isEmpty())throw Error("called deleteMax() with empty symbol table");this.root=this._deleteMaxNode(this.root)}_deleteMaxNode(t){return t.right?(t.right=this._deleteMaxNode(t.right),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.left}min(){if(this.isEmpty())throw Error("called min() with empty symbol table");return this._minNode(this.root).key}_minNode(t){return t.left?this._minNode(t.left):t}max(){if(this.isEmpty())throw Error("called max() with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return t.right?this._maxNode(t.right):t}floor(t){if(d.nichts(t))throw Error("argument to floor() is null");if(this.isEmpty())throw Error("called floor() with empty symbol table");let e=this._floorNode(this.root,t);if(e)return e.key}_floorNode(t,e){if(d.nichts(t))return null;let i=this.compare(e,t.key);if(0==i)return t;if(i<0)return this._floorNode(t.left,e);let s=this._floorNode(t.right,e);return s||t}ceiling(t){if(d.nichts(t))throw Error("argument to ceiling() is null");if(this.isEmpty())throw Error("called ceiling() with empty symbol table");let e=this._ceilingNode(this.root,t);if(e)return e.key}_ceilingNode(t,e){if(d.nichts(t))return null;let i=this.compare(e,t.key);if(0==i)return t;if(i>0)return this._ceilingNode(t.right,e);let s=this._ceilingNode(t.left,e);return s||t}select(t){if(t<0||t>=this.size())throw Error("k is not in range 0-"+(this.size()-1));let e=this._selectNode(this.root,t);if(e)return e.key}_selectNode(t,e){if(d.nichts(t))return null;let i=this._sizeNode(t.left);return i>e?this._selectNode(t.left,e):i<e?this._selectNode(t.right,e-i-1):t}rank(t){if(d.nichts(t))throw Error("argument to rank() is null");return this._rankNode(t,this.root)}_rankNode(t,e){if(d.nichts(e))return 0;let i=this.compare(t,e.key);return i<0?this._rankNode(t,e.left):i>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keysInOrder(){let t=new o;return this._keysInOrderNode(this.root,t),t.iter()}_keysInOrderNode(t,e){d.nichts(t)||(this._keysInOrderNode(t.left,e),e.enqueue(t.key),this._keysInOrderNode(t.right,e))}keysLevelOrder(){let t=new o;if(!this.isEmpty()){let e=new o;for(e.enqueue(this.root);!e.isEmpty();){let i=e.dequeue();t.enqueue(i.key),i.left||e.enqueue(i.left),i.right&&e.enqueue(i.right)}}return t}keys(t,e){if(0==arguments.length)return this.keysInOrder();if(d.nichts(t))throw Error("first argument to keys() is null");if(d.nichts(e))throw Error("second argument to keys() is null");let i=new o;return this._keysNode(this.root,i,t,e),i.iter()}_keysNode(t,e,i,s){if(t){let r=this.compare(i,t.key),n=this.compare(s,t.key);r<0&&this._keysNode(t.left,e,i,s),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,i,s)}}size(t,e){if(0==arguments.length)return this._sizeNode(this.root);if(d.nichts(t))throw Error("first argument to size() is null");if(d.nichts(e))throw Error("second argument to size() is null");return this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}_check(){let t=this;return function e(i,s,r){return!i||!(!s&&t.compare(i.key,s)<=0)&&(!(!r&&t.compare(i.key,r)>=0)&&(e(i.left,s,i.key)&&e(i.right,i.key,r)))}(this.root,null,null)&&function e(i){if(!i)return!0;let s=t._balanceFactor(i);return!(s>1||s<-1)&&(e(i.left)&&e(i.right))}(this.root)&&function e(i){return!i||i.size==t._sizeNode(i.left)+t._sizeNode(i.right)+1&&(e(i.left)&&e(i.right))}(this.root)&&function(){for(let e=0;e<t.size();e++)if(e!=t.rank(t.select(e)))return!1;for(let e,i=t.keys().iterator();i.hasNext();)if(e=i.next(),0!=this.compare(e,t.select(t.rank(key))))return!1;return!0}()}static test(){let t=new w(h);"SEARCHEXAMPLE".split("").forEach((e,i)=>t.put(e,i));for(let e,i=t.keys();i.hasNext();)e=i.next(),console.log(e+" "+t.get(e))}}const x=Math.sqrt(2);function k(t,e){return{parent:e,pos:t,f:0,g:0,h:0,pid:`${t[0]},${t[1]}`,equals(t){return this.pos[0]==t.pos[0]&&this.pos[1]==t.pos[1]}}}class E{static manhattan(t,e,i=1){return i*Math.abs(t[1]-e[1])+i*Math.abs(t[0]-e[0])}static euclidean(t,e,i=1){let s=e[0]-t[0],r=e[1]-t[1];return i*(s*s+r*r)}static diagonal(t,e,i=1,s=x){let r=Math.abs(e[0]-t[0]),n=Math.abs(e[1]-t[1]);return i*(r+n)+(s-2*i)*Math.min(r,n)}constructor(t){this.grid=t}pathTo(t,e,i){return this._search(this.grid,t,e,i)}_search(t,e,i,s){const r=s.compare,n=t.length,o=t[0].length,h=new Map,l=new Map,c=new a(r,10),u=k(i),d=k(e),f=[[1,0],[-1,0],[0,1],[0,-1]],g=(t,e)=>{for(;t;t=t.parent)e.unshift(t.pos);return e};s.wantDiagonal&&f.push([1,1],[1,-1],[-1,1],[-1,-1]),l.set(d.pid,d.g),c.insert(d);let p,m=[];for(;!c.isEmpty();){if(p=c.delMin(),l.delete(p.pid),h.set(p.pid,0),p.equals(u))return g(p,[]);m.length=0;for(let t,e=0;e<f.length;++e)t=[p.pos[0]+f[e][0],p.pos[1]+f[e][1]],t[0]>o-1||t[0]<0||t[1]>n-1||t[1]<0||s.blocked(t)||m.push(k(t,p));m.forEach(t=>{h.has(t.pid)||(t.g=p.g+s.cost(),t.h=s.calcHeuristic(t.pos,u.pos),t.f=t.g+t.h,l.has(t.pid)&&t.g>l.get(t.pid)||(c.insert(t),l.set(t.pid,t.g)))})}}static test(){let t,e,i,s=[[0,1,0,0,0,0],[0,0,0,0,0,0],[0,1,0,1,0,0],[0,1,0,0,1,0],[0,0,0,0,1,0]],r=s.length,n=s[0].length,o={wantDiagonal:!1,compare:(t,e)=>t.f-e.f,cost:()=>1,blocked:t=>0!=s[t[1]][t[0]],calcHeuristic:(t,e)=>E.euclidean(t,e)},h=new E(s).pathTo([0,0],[5,4],o);h?(i="",h.forEach(t=>{i+=`[${t[0]},${t[1]}] `}),console.log(i),e=d.fill(r,()=>d.fill(n,"#")),t=0,h.forEach(i=>{e[i[1]][i[0]]=""+t,++t}),e.forEach(t=>{console.log(t.toString())})):console.log("no path")}}return{AStarGrid:E,AVLTreeST:w,BinarySearch:_,RedBlackBST:y,BST:m,BinarySearchST:p,SequentialSearchST:g,FrequencyCounter:f}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/search"]=e}(this),function(t){"use strict";function e(e,i,s){i||(i=t["io/czlab/mcfud/algo/basic"]()),s||(s=t["io/czlab/mcfud/algo/sort"]()),e||(e=t["io/czlab/mcfud/core"]());const{prnIter:r,TreeMap:n,Bag:o,Stack:h,Queue:l,ST:a,StdCompare:c}=i,{IndexMinPQ:u,MinPQ:d}=s,{is:f,u:g}=(Math.floor,e);function p(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`);return!0}class m{constructor(t){g.assert(t>=0,"Number of vertices must be non-negative"),this.verts=t,this.edges=0,this.adjls=g.fill(t,()=>new o)}clone(){let t=new m(this.V());t.edges=this.E(),t.adjls=[];for(let e=0,i=this.V();e<i;++e)t.adjls.push(this.adjls[e].clone());return t}V(){return this.verts}E(){return this.edges}addEdge(t,e){p(t,this.verts),p(e,this.verts),this.edges+=1,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return p(t,this.verts)&&this.adjls[t]}degree(t){return p(t,this.verts)&&this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e=0;e<this.verts;++e)t+=e+": "+r(this.adjls[e].iter()),t+="\n";return t}static load(t,e){let i=new m(t);g.assert(e.length%2==0,"wanted even n# of data points");for(let t=0;t<e.length;t+=2)i.addEdge(e[t],e[t+1]);return i}static test(){let t=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);t.degree(1),console.log(t.toString());let e=t.clone();console.log("cloned=\n"+e.toString())}}class y{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,p(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.nCount+=1,this.bMarked[e]=!0;for(let i,s=t.adj(e).iter();s.hasNext();)i=s.next(),this.bMarked[i]||this._dfs(t,i)}marked(t){return p(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.nCount}static test(){let t,e,i=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach(s=>{e=new y(i,s),t="";for(let s=0;s<i.V();++s)e.marked(s)&&(t+=s+" ");console.log(t),console.log(e.count()!=i.V()?"NOT connected":"connected")})}}class _{constructor(t,e){this.bMarked=new Array(t.V()),p(e,this.bMarked.length);let i,s,r=g.fill(t.V(),e=>t.adj(e).iter()),n=new h;for(this.bMarked[e]=!0,n.push(e);!n.isEmpty();)i=n.peek(),r[i].hasNext()?(s=r[i].next(),this.bMarked[s]||(this.bMarked[s]=!0,n.push(s))):n.pop()}marked(t){return p(t,this.bMarked.length)&&this.bMarked[t]}static test(){let t,e,i=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach(s=>{e=new _(i,s),t="";for(let s=0;s<i.V();++s)e.marked(s)&&(t+=s+" ");console.log(t)})}}class w{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,p(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let i,s=t.adj(e).iter();s.hasNext();)i=s.next(),this.bMarked[i]||(this.edgeTo[i]=e,this._dfs(t,i))}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new h;for(let i=t;i!=this.s;i=this.edgeTo[i])e.push(i);return e.push(this.s),e.iter()}}static test(){let t=m.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new w(t,0);for(let i,s,r=0;r<t.V();++r)if(e.hasPathTo(r)){i=`0 to ${r}:  `;for(let t=e.pathTo(r);t.hasNext();)s=t.next(),i+=0==s?s:"-"+s;console.log(i)}else console.log(`0 to ${r}:  not connected\n`)}}function x(t,e,i){let s,r=[];for(s=0;s<t.V();++s)i.mDistTo[s]=1/0;for(e.forEach(t=>{i.bMarked[t]=!0,i.mDistTo[t]=0,r.push(t)});r.length>0;){s=r.shift();for(let e,n=t.adj(s).iter();n.hasNext();)e=n.next(),i.bMarked[e]||(i.edgeTo[e]=s,i.mDistTo[e]=i.mDistTo[s]+1,i.bMarked[e]=!0,r.push(e))}}function k(t,e){if(!t||0==t.length)throw Error("argument is null or empty");return t.forEach(t=>p(t,e)),!0}class E{constructor(t,e){this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V()),f.vec(e)||(e=[e]),k(e,t.V()),x(t,e,this),function(t,e,i){if(0!=i.mDistTo[e])throw Error(`dist of source ${e} to itself = ${i.mDistTo[e]}`);for(let e=0;e<t.V();++e)for(let s,r=t.adj(e).iter();r.hasNext();){if(s=r.next(),i.hasPathTo(e)!==i.hasPathTo(s))throw Error(`edge ${e}-${s}hasPathTo(${e})=${i.hasPathTo(e)}hasPathTo(${s})=${i.hasPathTo(s)}`);if(i.hasPathTo(e)&&i.mDistTo[s]>i.mDistTo[e]+1)throw Error(`edge ${e}-${s}distTo[${e}]=${i.mDistTo[e]}distTo[${s}]=${i.mDistTo[s]}`)}for(let s,r=0;r<t.V();++r)if(i.hasPathTo(r)&&r!=e&&(s=i.edgeTo[r],i.mDistTo[r]!=i.mDistTo[s]+1))throw Error(`shortest path edge ${s}-${r} distTo[${s}]= ${i.mDistTo[s]}distTo[${r}]= ${i.mDistTo[r]}`)}(t,e,this)}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return p(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e,i=new h;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])i.push(e);return i.push(e),i.iter()}}static test(){let t=m.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new E(t,0);for(let i,s=0;s<t.V();++s)if(e.hasPathTo(s)){i=`0 to ${s}(${e.distTo(s)}): `;for(let t,r=e.pathTo(s);r.hasNext();)t=r.next(),i+=0==t?""+t:"-"+t;console.log(i)}else console.log(`0 to ${s} (-):  not connected\n`)}}class v{constructor(t,e,i){if(t<0)throw Error("vertex index must be a non-negative integer");if(e<0)throw Error("vertex index must be a non-negative integer");this.v=t,this.w=e,this._weight=i}weight(){return this._weight}either(){return this.v}other(t){if(t==this.v)return this.w;if(t==this.w)return this.v;throw Error("Illegal endpoint")}static comparator(t,e){return t._weight<e._weight?-1:t._weight>e._weight?1:0}toString(){return`${this.v}-${this.w} ${this._weight}`}static test(){console.log(new v(12,34,5.67).toString())}}class b{constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this._V=t,this._E=0,this.adjls=g.fill(t,()=>new o)}static randGraph(t,e){let i=new b(t);if(e<0)throw Error("Number of edges must be non-negative");for(let s,r,n,o=0;o<e;++o)r=g.randInt(t),n=g.randInt(t),s=Math.round(100*g.rand())/100,i.addEdge(new v(r,n,s));return i}clone(){let t=new b(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){let e=t.either(),i=t.other(e);p(e,this._V),p(i,this._V),this.adjls[e].add(t),this.adjls[i].add(t),this._E+=1}adj(t){return p(t,this._V)&&this.adjls[t]}degree(t){return p(t,this._V)&&this.adjls[t].size()}edges(){const t=new o;for(let e,i,s,r=0;r<this._V;++r)for(i=0,e=this.adjls[r].iter();e.hasNext();)s=e.next(),s.other(r)>r?t.add(s):s.other(r)==r&&(i%2==0&&t.add(s),++i);return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e,i=0;i<this._V;++i){for(t+=i+": ",e=this.adjls[i].iter();e.hasNext();)t+=e.next()+", ";t+="\n"}return t}static load(t,e){let i=new b(t);g.assert(e.length%3==0,"Invalid data size");for(let s=0;s<e.length;s+=3)p(e[s],t)&&p(e[s+1],t)&&i.addEdge(new v(e[s],e[s+1],e[s+2]));return i}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38 2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34 6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(" ").map(t=>+t),e=b.load(8,t);console.log(e.toString())}}class N{constructor(t){this.bMarked=new Array(t.V()),this._id=new Array(t.V()),this._size=new Array(t.V()),this.nCount=0;for(let e=0;e<t.V();++e)this.bMarked[e]||(this._dfs(t,e),++this.nCount)}_dfs(t,e){this.bMarked[e]=!0,this._id[e]=this.nCount,this._size[this.nCount]+=1;for(let i,s,r=t.adj(e).iter();r.hasNext();)i=r.next(),t instanceof b?(s=i.other(e),this.bMarked[s]||this._dfs(t,s)):this.bMarked[i]||this._dfs(t,i)}id(t){return p(t,this.bMarked.length)&&this._id[t]}size(t){return p(t,this.bMarked.length)&&this._size[this._id[t]]}count(){return this.nCount}connected(t,e){return p(t,this.bMarked.length)&&p(e,this.bMarked.length)&&this.id(t)==this.id(e)}static test(){let t=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]),e=new N(t),i=e.count();console.log(i+" components");let s=g.fill(i,()=>[]);for(let i=0;i<t.V();++i)s[e.id(i)].push(i);for(let t,e=0;e<i;++e)t="",s[e].forEach(e=>t+=e.toString()+" "),console.log(t)}}class M{static load(t,e){if(t<0)throw Error("verts in a Digraph must be non-negative");g.assert(e.length%2==0,"expected even n# of data-length");let i=new M(t);for(let t=0;t<e.length;t+=2)i.addEdge(e[t],e[t+1]);return i}constructor(t){if(t<0)throw Error("verts in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=g.fill(t,0),this.adjls=g.fill(t,()=>new o)}clone(){let t=this,e=new M(this.V());e._E=this.E(),e._indegree=g.fill(e.V(),e=>t._indegree[e]);for(let t=0;t<e.V();++t)e.adjls[t]=this.adjls[t].clone();return e}V(){return this._V}E(){return this._E}addEdge(t,e){p(t,this._V)&&p(e,this._V),this.adjls[t].add(e),this._indegree[e]+=1,++this._E}adj(t){return p(t,this._V)&&this.adjls[t]}outdegree(t){return p(t,this._V)&&this.adjls[t].size()}indegree(t){return p(t,this._V)&&this._indegree[t]}reverse(){let t=new M(this._V);for(let e,i=0;i<this._V;++i)for(e=this.adjls[i].iter();e.hasNext();)t.addEdge(e.next(),i);return t}toString(){let t=`${this._V} vertices, ${this._E} edges\n`;for(let e,i=0;i<this._V;++i){for(t+=i+": ",e=this.adjls[i].iter();e.hasNext();)t+=e.next()+" ";t+="\n"}return t}static test(){let t=M.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t)),e="",i="";for(let s=0;s<t.V();++s)e+=`${s}=${t.indegree(s)}, `,i+=`${s}=${t.outdegree(s)},`;console.log("indegreee= "+e),console.log("outdegreee= "+i),console.log(t.toString());let s=t.clone();console.log("cloned=\n"+s.toString());let r=t.reverse();console.log("rev'ed=\n"+r.toString())}}class q{constructor(t,e){this.bMarked=new Array(t.V()),f.vec(e)||(e=[e]),k(e,t.V()),e.forEach(e=>{this.bMarked[e]||this._dfs(t,e)})}_dfs(t,e){this.mCount+=1,this.bMarked[e]=!0;for(let i,s=t.adj(e).iter();s.hasNext();)i=s.next(),this.bMarked[i]||this._dfs(t,i)}marked(t){return p(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.mCount}static test(){let t=M.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t)),e="",i=new q(t,[1,2,6]);for(let s=0;s<t.V();++s)i.marked(s)&&(e+=s+" ");i.count(),console.log(e)}}class z{constructor(t){this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V()),this.mCycle=null;for(let e=0;e<t.V();++e)this.bMarked[e]||null!==this.mCycle||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let i,s=t.adj(e).iter();s.hasNext();){if(i=s.next(),null!==this.mCycle)return;if(this.bMarked[i]){if(this.onStack[i]){this.mCycle=new h;for(let t=e;t!=i;t=this.edgeTo[t])this.mCycle.push(t);this.mCycle.push(i),this.mCycle.push(e),this._check()}}else this.edgeTo[i]=e,this._dfs(t,i)}this.onStack[e]=!1}hasCycle(){return null!==this.mCycle}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=-1,e=-1;for(let i,s=this.cycle();s.hasNext();)i=s.next(),-1==t&&(t=i),e=i;if(t!=e)throw Error(`cycle begins with ${t} and ends with ${e}\n`)}return!0}static test(){let t="2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map(t=>+t),e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9\n               10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8\n               6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t);[new z(M.load(13,e)),new z(M.load(13,t))].forEach(t=>{t.hasCycle()?(console.log("Directed cycle: "),console.log(r(t.cycle()))):console.log("No directed cycle")})}}class T{constructor(t,e,i){if(t<0)throw Error("Vertex names must be non-negative integers");if(e<0)throw Error("Vertex names must be non-negative integers");this.v=t,this.w=e,this._weight=i}from(){return this.v}to(){return this.w}weight(){return this._weight}toString(){return`${this.v}->${this.w} ${Number(this._weight).toFixed(2)}`}static test(){console.log(new T(12,34,5.67).toString())}}class S{constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=g.fill(t,()=>new o)}static randGraph(t,e){if(e<0)throw Error("n# edges in a Digraph must be non-negative");let i=new S(t);for(let s=0;s<e;++s)i.addEdge(new T(g.randInt(t),g.randInt(t),.01*_randInt(100)));return i}static load(t,e){if(t<0)throw Error("n# vertices in a Digraph must be non-negative");g.assert(e.length%3==0,"bad data length");let i=new S(t);for(let s=0;s<e.length;s+=3)p(e[s],t)&&p(e[s+1],t)&&i.addEdge(new T(e[s],e[s+1],e[s+2]));return i}clone(){let t=new S(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t._indegree[e]=this._indegree(e);for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){g.assert(t instanceof T,"Expected DirectedEdge");let e=t.to(),i=t.from();p(i,this._V),p(e,this._V),this.adjls[i].add(t),this._indegree[e]+=1,this._E++}adj(t){return p(t,this._V)&&this.adjls[t]}outdegree(t){return p(t,this._V)&&this.adjls[t].size()}indegree(t){return p(t,this._V)&&this._indegree[t]}edges(){const t=new o;for(let e=0;e<this._V;++e)for(let i=this.adj(e).iter();i.hasNext();)t.add(i.next());return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e=0;e<this._V;++e)t+=e+": "+r(this.adjls[e].iter())+"\n";return t}static test(){let t="4 5 0.35\n        5 4 0.35\n        4 7 0.37\n        5 7 0.28\n        7 5 0.28\n        5 1 0.32\n        0 4 0.38\n        0 2 0.26\n        7 3 0.39\n        1 3 0.29\n        2 7 0.34\n        6 2 0.40\n        3 6 0.52\n        6 0 0.58\n        6 4 0.93".split(/\s+/).map(t=>+t),e=S.load(8,t);console.log(e.toString())}}class A{constructor(t){this._pre=new Array(t.V()),this._post=new Array(t.V()),this.preCounter=0,this.postCounter=0,this.postorder=new l,this.preorder=new l,this.bMarked=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.bMarked[e]=!0,this._pre[e]=this.preCounter++,this.preorder.enqueue(e);for(let i,s=t.adj(e).iter();s.hasNext();)i=t instanceof S?s.next().to():s.next(),this.bMarked[i]||this._dfs(t,i);this.postorder.enqueue(e),this._post[e]=this.postCounter++}pre(t){return p(t,this.bMarked.length)&&this._pre[t]}post(t){return p(t,this.bMarked.length)&&this._post[t]}postOrder(){return this.postorder.iter()}preOrder(){return this.preorder.iter()}reversePost(){let t=new h;for(let e=this.postorder.iter();e.hasNext();)t.push(e.next());return t.iter()}_check(){let t,e=0;for(t=this.postOrder();t.hasNext();){if(this.post(t.next())!=e)throw Error("post(v) and post() inconsistent");++e}for(e=0,t=this.preOrder();t.hasNext();){if(this.pre(t.next())!=e)throw Error("pre(v) and pre() inconsistent");++e}return!0}static test(){let t=M.load(13,"2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map(t=>+t));console.log(t.toString());let e=new A(t);console.log("   v  pre  post"),console.log("--------------");for(let i=0;i<t.V();++i)console.log(`    ${i}  ${e.pre(i)}  ${e.post(i)}\n`);console.log("Preorder:  "),console.log(r(e.preOrder())),console.log("Postorder:  "),console.log(r(e.postOrder())),console.log(""),console.log("Reverse postorder: "),console.log(r(e.reversePost()))}}class O{constructor(t){g.assert(t instanceof S,"Expected EdgeWeightedDigraph"),this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let i,s,r=t.adj(e).iter();r.hasNext();){if(s=r.next(),i=s.to(),this.mCycle)return;if(this.bMarked[i]){if(this.onStack[i]){this.mCycle=new h;let t=s;for(;t.from()!=i;)this.mCycle.push(t),t=this.edgeTo[t.from()];return void this.mCycle.push(t)}}else this.edgeTo[i]=s,this._dfs(t,i)}this.onStack[e]=!1}hasCycle(){return g.echt(this.mCycle)}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=null,e=null;for(let i,s=this.cycle();s.hasNext();){if(i=s.next(),t||(t=i),e&&e.to()!=i.from())throw Error(`cycle edges ${e} and ${i} not incident\n`);e=i}if(e.to()!=t.from())throw Error(`cycle edges ${e} and ${t} not incident\n`)}return!0}static test(){let t=13,e=new S(t);g.shuffle(g.fill(t,t=>t));for(let i,s,r,n=0;n<8;++n){do{s=g.randInt(t),r=g.randInt(t)}while(s>=r);i=g.rand(),e.addEdge(new T(s,r,i))}for(let i=0;i<6;++i)e.addEdge(new T(g.randInt(t),g.randInt(t),g.rand()));console.log(e.toString());let i=new O(e);i.hasCycle()?console.log("Cycle: "+r(i.cycle())):console.log("No directed cycle")}}class P{constructor(t){this.st=new a,t.forEach(t=>t.forEach((t,e)=>{this.st.contains(t)||this.st.put(t,this.st.size())})),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this._graph=new m(this.st.size()),t.forEach(t=>{let e=this.st.get(t[0]);for(let i,s=1;s<t.length;++s)i=this.st.get(t[s]),this._graph.addEdge(e,i)})}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return p(t,this._graph.V())&&this.keys[t]}graph(){return this._graph}static test(){let t="JFK MCO\n                  ORD DEN\n                  ORD HOU\n                  DFW PHX\n                  JFK ATL\n                  ORD DFW\n                  ORD PHX\n                  ATL HOU\n                  DEN PHX\n                  PHX LAX\n                  JFK ORD\n                  DEN LAS\n                  DFW HOU\n                  ORD ATL\n                  LAS LAX\n                  ATL MCO\n                  HOU MCO\n                  LAS PHX".split(/\s+/),e=new P(g.partition(2,t)),i=e.graph();["JFK","LAX"].forEach(t=>{if(e.contains(t)){let s=e.indexOf(t);console.log(t);for(let t=i.adj(s).iter();t.hasNext();)console.log("   "+e.nameOf(t.next()))}else console.log("input not contain '"+t+"'")})}}class C{constructor(t){this.st=new a,t.forEach(t=>t.forEach(t=>{this.st.contains(t)||this.st.put(t,this.st.size())})),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this.graph=new M(this.st.size()),t.forEach(t=>{let e=this.st.get(t[0]);for(let i=1;i<t.length;++i)this.graph.addEdge(e,this.st.get(t[i]))})}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return p(t,this.graph.V())&&this.keys[t]}digraph(){return this.graph}static test(){let t="JFK MCO\n              ORD DEN\n              ORD HOU\n              DFW PHX\n              JFK ATL\n              ORD DFW\n              ORD PHX\n              ATL HOU\n              DEN PHX\n              PHX LAX\n              JFK ORD\n              DEN LAS\n              DFW HOU\n              ORD ATL\n              LAS LAX\n              ATL MCO\n              HOU MCO\n              LAS PHX".split(/\s+/),e=new C(g.partition(2,t)),i=e.digraph();["JFK","ATL","LAX"].forEach(t=>{console.log(""+t);let s=i.adj(e.indexOf(t)).iter();for(;s.hasNext();)console.log("   "+e.nameOf(s.next()))})}}class I{constructor(t){let e;if(this._order=null,this.rank=null,t instanceof S?e=new O(t):t instanceof M?(e=new z(t),e.hasCycle()||(this.rank=new Array(t.V()))):g.assert(!1,"bad arg for Topological"),e&&!e.hasCycle()){this._order=new l;for(let e,i=0,s=new A(t).reversePost();s.hasNext();)e=s.next(),this.rank&&(this.rank[e]=i++),this._order.enqueue(e)}}order(){return this._order.iter()}hasOrder(){return g.echt(this._order)}rank(t){return this.rank&&p(t,this.rank.length)&&this.hasOrder()?this.rank[t]:-1}static test(){let t=new C([["Algorithms","Theoretical CS","Databases","Scientific Computing"],["Introduction to CS","Advanced Programming","Algorithms"],["Advanced Programming","Scientific Computing"],["Scientific Computing","Computational Biology"],["Theoretical CS","Computational Biology","Artificial Intelligence"],["Linear Algebra","Theoretical CS"],["Calculus","Linear Algebra"],["Artificial Intelligence","Neural Networks","Robotics","Machine Learning"],["Machine Learning","Neural Networks"]]);for(let e=new I(t.digraph()).order();e.hasNext();)console.log(t.nameOf(e.next()))}}class j{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,p(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let i,s=t.adj(e).iter();s.hasNext();)i=s.next(),this.bMarked[i]||(this.edgeTo[i]=e,this._dfs(t,i))}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new h;for(let i=t;i!=this.s;i=this.edgeTo[i])e.push(i);return e.push(this.s),e.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t),i=M.load(13,e),s=new j(i,3);for(let e=0;e<i.V();++e)if(s.hasPathTo(e)){t=`3 to ${e}:  `;for(let i,r=s.pathTo(e);r.hasNext();)i=r.next(),t+=3==i?""+i:"-"+i;console.log(t)}else console.log(`3 to ${e}:  not connected`)}}class R{constructor(t,e){f.vec(e)||(e=[e]),this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.mDistTo[e]=1/0;k(e,t.V())&&this._bfs(t,e)}_bfs(t,e){let i=new l;for(e.forEach(t=>{this.bMarked[t]=!0,this.mDistTo[t]=0,i.enqueue(t)});!i.isEmpty();){let e=i.dequeue();for(let s,r=t.adj(e).iter();r.hasNext();)s=r.next(),this.bMarked[s]||(this.edgeTo[s]=e,this.mDistTo[s]=this.mDistTo[e]+1,this.bMarked[s]=!0,i.enqueue(s))}}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return p(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e,i=new h;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])i.push(e);return i.push(e),i.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t),i=M.load(13,e),s=new R(i,3);for(let e=0;e<i.V();++e)if(t="",s.hasPathTo(e)){t=`3 to ${e} (${s.distTo(e)}):  `;for(let i,r=s.pathTo(e);r.hasNext();)i=r.next(),t+=3==i?""+i:"->"+i;console.log(t)}else console.log(`3 to ${e} (-):  not connected`)}}class V{constructor(t,e,i){g.assert(t instanceof S,"Expected EdgeWeightedDigraph");for(let e,i=t.edges();i.hasNext();)if(e=i.next(),e.weight()<0)throw Error(`edge ${e} has negative weight`);this._distTo=new Array(t.V()),this.edgeTo=g.fill(t.V(),null),p(e,t.V());for(let e=0;e<t.V();++e)this._distTo[e]=1/0;for(this._distTo[e]=0,this.pq=new u(t.V(),i),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let i=t.adj(e).iter();i.hasNext();)this._relax(i.next())}this._check(t,e)}_relax(t){let e=t.from(),i=t.to();this._distTo[i]>this._distTo[e]+t.weight()&&(this._distTo[i]=this._distTo[e]+t.weight(),this.edgeTo[i]=t,this.pq.contains(i)?this.pq.decreaseKey(i,this._distTo[i]):this.pq.insert(i,this._distTo[i]))}distTo(t){return p(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return p(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(p(t,this._distTo.length)&&this.hasPathTo(t)){let e=new h;for(let i=this.edgeTo[t];null!=i;i=this.edgeTo[i.from()])e.push(i);return e.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||null!==this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let i=0;i<t.V();++i)if(i!=e&&null===this.edgeTo[i]&&this._distTo[i]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let i,s,r=t.adj(e).iter();r.hasNext();)if(s=r.next(),i=s.to(),this._distTo[e]+s.weight()<this._distTo[i])throw Error(`edge ${s} not relaxed`);for(let e,i,s=0;s<t.V();++s)if(null===this.edgeTo[s]);else{if(i=this.edgeTo[s],e=i.from(),s!=i.to())throw Error("bad edge");if(this._distTo[e]+i.weight()!=this._distTo[s])throw Error(`edge ${i} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35\n                  5 4 0.35\n                  4 7 0.37\n                  5 7 0.28\n                  7 5 0.28\n                  5 1 0.32\n                  0 4 0.38\n                  0 2 0.26\n                  7 3 0.39\n                  1 3 0.29\n                  2 7 0.34\n                  6 2 0.40\n                  3 6 0.52\n                  6 0 0.58\n                  6 4 0.93".split(/\s+/).map(t=>+t),e=S.load(8,t),i=new V(e,0,c);for(let t=0;t<e.V();++t)i.hasPathTo(t)?console.log(`0 to ${t} (${Number(i.distTo(t)).toFixed(2)})  ${r(i.pathTo(t))}`):console.log(`0 to ${t}         no path\n`)}}class ${constructor(t,e,i){g.assert(t instanceof b,"Expected EdgeWeightedGraph");for(let e,i=t.edges();i.hasNext();)if(e=i.next(),e.weight()<0)throw new Error(`edge ${e} has negative weight`);for(this._distTo=g.fill(t.V(),()=>1/0),this._distTo[e]=0,this.compare=i,this.edgeTo=g.fill(t.V(),()=>null),p(e,t.V()),this.pq=new u(t.V(),this.compare),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let i=t.adj(e).iter();i.hasNext();)this._relax(i.next(),e)}this._check(t,e)}_relax(t,e){let i=t.other(e);this._distTo[i]>this._distTo[e]+t.weight()&&(this._distTo[i]=this._distTo[e]+t.weight(),this.edgeTo[i]=t,this.pq.contains(i)?this.pq.decreaseKey(i,this._distTo[i]):this.pq.insert(i,this._distTo[i]))}distTo(t){return p(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return p(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(p(t,this._distTo.length)&&this.hasPathTo(t)){let e=t,i=new h;for(let s=this.edgeTo[t];null!==s;s=this.edgeTo[e])i.push(s),e=s.other(e);return i.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||null!==this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let i=0;i<t.V();++i)if(i!=e&&null===this.edgeTo[i]&&this._distTo[i]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let i,s,r=t.adj(e).iter();r.hasNext();)if(s=r.next(),i=s.other(e),this._distTo[e]+s.weight()<this._distTo[i])throw Error(`edge ${s} not relaxed`);for(let e,i,s=0;s<t.V();++s)if(null!==this.edgeTo[s]){if(i=this.edgeTo[s],s!=i.either()&&s!=i.other(i.either()))return!1;if(e=i.other(s),this._distTo[e]+i.weight()!=this._distTo[s])throw Error(`edge ${i} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38\n                  2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34\n                  6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(/\s+/).map(t=>+t),e=b.load(8,t),i=new $(e,6,c);for(let t,s=0;s<e.V();++s)if(i.hasPathTo(s)){t=`6 to ${s} (${Number(i.distTo(s)).toFixed(2)})  `;for(let e=i.pathTo(s);e.hasNext();)t+=e.next()+"   ";console.log(t)}else console.log(`6 to ${s}         no path`)}}return{DepthFirstDirectedPaths:j,BreadthFirstDirectedPaths:R,SymbolGraph:P,DijkstraUndirectedSP:$,DijkstraSP:V,Topological:I,SymbolDigraph:C,EdgeWeightedDirectedCycle:O,DepthFirstOrder:A,EdgeWeightedDigraph:S,DirectedEdge:T,DirectedCycle:z,DirectedDFS:q,Digraph:M,CC:N,EdgeWeightedGraph:b,Edge:v,BreadthFirstPaths:E,DepthFirstPaths:w,NonrecursiveDFS:_,DepthFirstSearch:y,Graph:m}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/graph"]=e}(this),function(t){"use strict";function e(t){t||(t=gscope["io/czlab/mcfud/core"]());const e=Math.floor,{u:i,is:s}=t;function r(t){let e=i.fill(t+1,()=>i.randMinus1To1());return{activation:0,error:0,weights:e,numInputs:e.length}}function n(t,e){return{numNeurons:t,neurons:i.fill(t,()=>r(e))}}function o(t,e){return{age:0,genes:t,fitness:e,clone(){return o(this.genes.slice(),this.fitness.clone())}}}function h(t){let e=i.randInt(t.length),s=i.randInt(t.length);return e<s?[e,s]:[s,e]}function l(t,e){let s,r=e?e.totalScore:t.reduce((t,e)=>t+e.fitness.score(),0),n=0,o=i.rand(),h=t.map(t=>n+=t.fitness.score()/r);for(s=0;s<h.length-1;++s)if(o>=h[s]&&o<=h[s+1])return t[s];return t[0]}function a(t,e){let s=0,r=-1/0;for(let n,o=0;o<e;++o)n=i.randInt(t.length),t[n].fitness.score()>r&&(s=n,r=t[n].fitness.score());return t[s]}function c(t,e){let i=0,s=1/0,r={averageScore:0,totalScore:0,bestScore:0,worstScore:0,best:null};return e&&(i=1/0,s=0),t.forEach((t,n)=>{e?t.fitness.score()<i?(i=t.fitness.score(),r.bestScore=i,r.best=t):t.fitness.score()>s&&(s=t.fitness.score(),r.worstScore=s):t.fitness.score()>i?(i=t.fitness.score(),r.bestScore=i,r.best=t):t.fitness.score()<s&&(s=t.fitness.score(),r.worstScore=s),r.totalScore+=t.fitness.score()}),r.averageScore=r.totalScore/t.length,r}function u(t,e="cycles"){let s=t.startTime=i.now();return t[e]=0,s}function d(t){return t.endTime=i.now()}function f(t,e,s,r,n){let h=i.randInt(e.length);for(;e.length>1&&h==t;)h=i.randInt(e.length);let l=e[t].genes.slice(),a=e[h].genes.slice();s&&s(l,a),r&&(r(l),r(a));let c=n(l,e[t].fitness),u=n(a,e[h].fitness);return c.gt(u)?o(l,c):o(a,u)}function g(t,e){let i,s=0;for(;s<t.length&&(i=t[s],!i.fitness.eq(e.fitness)&&e.fitness.gt(i.fitness));++s);return s}function p(t,e){if(s.num(t))return i.fill(t,()=>e.create());let r,n,h,u,d=[],f=c(t),{calcFit:g,crossOver:p,mutate:m,NUM_ELITES:y,TOURNAMENT_COMPETITORS:_}=e;if(t.sort((t,e)=>t.fitness.lt(e.fitness)?-1:t.fitness.gt(e.fitness)?1:0),s.num(y))for(let e=y,i=t.length-1;i>=0&&e>0;--i)d.push(t[i]),--e;for(;d.length<t.length;)void 0!==_?(h=a(t,_),u=a(t,_)):(h=l(t,f),u=l(t,f)),r=h.genes.slice(),n=u.genes.slice(),p&&p(r,n),m&&(m(r),m(n)),d.push(o(r,g(r,h.fitness)),o(n,g(n,u.fitness)));for(;d.length>t.length;)d.pop();return d}return{MAX_PERTURBATION:.3,BIAS:-1,CrossOverRate:.7,MutationRate:.1,NumericFitness:function t(e,i){return{value:e,gt(t){return i?this.value<t.value:this.value>t.value},eq(t){return this.value==t.value},lt(t){return i?this.value>t.value:this.value<t.value},score(){return this.value},clone:()=>t(e)}},Chromosome:o,mutateSM:function(t,e){if(i.rand()<=e){let e,[s,r]=h(t);switch(r-s-1){case-1:case 0:case 1:break;case 2:e=t[s+1],t[s+1]=t[s+2],t[s+2]=e;break;default:e=i.shuffle(t.slice(s+1,r));for(let i=0,n=s+1;n<r;++n)t[n]=e[i++]}}},mutateDM:function(t,e){if(i.rand()<=e){let e,s,r,[n,o]=h(t);switch(o-n-1){case-1:case 0:break;default:s=t.slice(n+1,o),r=t.slice(0,n+1).concat(t.slice(o)),e=i.randInt2(r.length-1),s=r.slice(0,e).concat(s).concat(r.slice(e)),i.assert(s.length==t.length,"Boom"),s.forEach((e,i)=>t[i]=e)}}},mutateIM:function(t,e){if(i.rand()<=e){let e,s=i.randInt(t.length);for(e=i.randInt(t.length);e==s;)e=i.randInt(t.length);i.swap(t,s,e)}},mutateIVM:function(t,e){if(i.rand()<=e){let e,[i,s]=h(t);switch(s-i-1){case-1:case 0:case 1:break;default:e=t.slice(i+1,s).reverse();for(let r=0,n=i+1;n<s;++n)t[n]=e[r++]}}},mutateDIVM:function(t,e){if(i.rand()<=e){let e,s,r,[n,o]=h(t);switch(o-n-1){case-1:case 0:break;default:s=t.slice(n+1,o).reverse(),r=t.slice(0,n+1).concat(t.slice(o)),e=i.randInt2(r.length-1),s=r.slice(0,e).concat(s).concat(r.slice(e)),i.assert(s.length==t.length,"Boom"),s.forEach((e,i)=>t[i]=e)}}},crossOverRND:function(t,e,s){if(i.rand()<=s){let s,r,n;s=i.randInt(t.length),r=t.slice(0,s).concat(e.slice(s)),n=e.slice(0,s).concat(t.slice(s)),r.forEach((e,i)=>t[i]=e),n.forEach((t,i)=>e[i]=t)}},crossOverOBX:function(t,s,r){if(i.rand()>r)return;let n=e(.2*t.length),o=e(.8*t.length),h=i.randInt2(n,o),l=i.listIndexesOf(t,!0).slice(h),a=l.map(e=>t[e]),c=[],u=[],d=new Set(a);for(let t=0;t<s.length;++t)a.length>0&&d.has(s[t])?u.push(a.shift()):u.push(s[t]);i.assert(u.length==s.length,"Boom"),a=l.map(t=>s[t]),d=new Set(a);for(let e=0;e<t.length;++e)a.length>0&&d.has(t[e])?c.push(a.shift()):c.push(t[e]);i.assert(c.length==t.length,"Boom"),c.forEach((e,i)=>t[i]=e),u.forEach((t,e)=>s[e]=t)},crossOverPBX:function(t,s,r){if(i.rand()>r)return;let n=e(.2*t.length),o=e(.8*t.length),h=i.randInt2(n,o),l=i.listIndexesOf(t,!0).slice(h),a=[],c=[],u=new Set(l);for(let e=0;e<s.length;++e)u.has(e)?c.push(t[e]):c.push(s[e]);i.assert(c.length==s.length,"Boom");for(let e=0;e<t.length;++e)u.has(e)?a.push(s[e]):a.push(t[e]);i.assert(a.length==t.length,"Boom"),a.forEach((e,i)=>t[i]=e),c.forEach((t,e)=>s[e]=t)},crossOverPMX:function(t,e,s){if(i.rand()<=s){let s=i.randInt2(0,t.length-2),r=i.randInt2(s+1,t.length-1);for(let n=s;n<=r;++n){let s=t[n],r=e[n];if(s!=r){let n=t.indexOf(s),o=t.indexOf(r);i.swap(t,n,o),n=e.indexOf(s),o=e.indexOf(r),i.swap(e,n,o)}}}},crossOverAtSplits:function(t,e,s,r){if(i.rand()<=s){let s,n,o,h,l;s=i.randInt(r.length-2),n=r[s],o=r[i.randInt2(n,r.length-1)],h=t.slice(0,n).concat(e.slice(n,o)).concat(t.slice(o)),l=e.slice(0,n).concat(t.slice(n,o)).concat(e.slice(o)),h.forEach((e,i)=>t[i]=e),l.forEach((t,i)=>e[i]=t)}},calcStats:c,runGACycle:function(t,e){let s,r,{maxCycles:n,targetScore:o,maxSeconds:h}=e,l=1e3*(h||30),a=u(e);for(n=n||100;;){if(t=p(t,e),r=d(e),r-a>l){r=null;break}if(s=c(t),i.echt(o)&&s.bestScore>=o)break;if(e.cycles>=n)break;e.cycles+=1}return[null==r,t]},runGASearch:function(t,e){let s,r,n=u(e),o=e.maxCycles||100,h=1e3*(e.maxSeconds||30),l=function*([t,e],s){let r,{mutate:n,create:o,maxAge:h,calcFit:l,poolSize:a,crossOver:c}=s,u=o();yield u;let d,p,m,y,_,w=[u],x=[u];a=a||1,h=h||50;for(let t=0;t<a-1;++t)r=o(),r.fitness.gt(u.fitness)&&(yield u=r,x.push(r)),w.push(r);for(_=a-1,y=1;;)if(i.now()-t>e&&(yield u),y=y>0?y-1:_,r=w[y],p=f(y,w,c,n,l),r.fitness.gt(p.fitness)){if(void 0===h)continue;if(r.age+=1,h>r.age)continue;if(m=g(x,p,x.length),d=m/x.length,i.rand()<Math.exp(-d)){w[y]=p;continue}u.age=0,w[y]=u}else p.fitness.gt(r.fitness)?(p.age=0,w[y]=p,p.fitness.gt(u.fitness)&&(yield u=p,x.push(u))):(p.age=r.age+1,w[y]=p)}([n,h],e);for(;;){if(s=l.next().value,r=d(e),r-n>h){r=null;break}if(!t.gt(s.fitness))break;if(e.cycles>=o)break;e.cycles+=1}return[null==r,s]},hillClimb:function(t,e,s,r,n,o){o.startTime=i.now();let h=t(n);for(;!s(h);){let i=t(r(h));e(h,i)&&(h=i)}return o.endTime=i.now(),h},SNeuron:r,SNeuronLayer:n,NeuralNet:function(t,e,s,r){function o(t){let e=0;return i.doseq(t,t=>i.doseq(t.neurons,t=>{e+=t.weights.length})),e}let[h,l]=function(i){if(i.push(n(s>0?r:e,t)),s>0){for(let t=0;t<s-1;++t)i.push(n(r,r));i.push(n(e,r))}return[i,o(i)]}([]);return{numOfWeights:l,numOutputs:e,numInputs:t,numHidden:s,neuronsPerHidden:r,layers:h,putWeights(t){let e=0;i.doseq(this.layers,s=>i.doseq(s.neurons,s=>i.doseq(s.weights,(i,r)=>s.weights[r]=t[e++])))},getNumberOfWeights(){return this.numOfWeights},update(t){let e,s,r=0,n=[];return t.length==this.numInputs&&i.doseq(this.layers,(i,o)=>{o>0&&(t=n),r=0,n=[],i.neurons.forEach(i=>{r=0,e=0,s=i.numInputs;for(let n=0;n<s-1;++n)e+=i.weights[n]*t[r],++r;e+=-1*i.weights[s-1],i.activation=this.sigmoid(e,1),n.push(i.activation)})}),i.assert(n.length==this.numOutputs,"out length incorrect"),n},sigmoid:(t,e)=>1/(1+Math.exp(-t/e)),calcSplitPoints(){let t=[],e=0;return this.layers.forEach(i=>i.neurons.forEach(i=>{e+=i.numInputs,t.push(e-1)})),t}}},showBest(t,e,s){console.log(i.fill(80,"-").join("")),console.log("total time: "+i.prettyMillis(e.endTime-e.startTime)),s&&console.log("time expired"),console.log("total cycles= "+e.cycles),console.log("fitness= "+t.fitness.score()),console.log(i.fill(80,"-").join(""))}}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core")):t["io/czlab/mcfud/NNetGA"]=e}(this),function(t){"use strict";function e(e,i){if(e||(e=t["io/czlab/mcfud/core"]()),!i)throw"Fatal: No Colors!";const{is:s,u:r}=e;function n(t,e){let i="";for(;t>0;)i+=e,--t;return i}function o(t,e){let i=c;return e&&(s.str(t)?i="any"===t||t===e?u:c:t instanceof e&&(i=u)),i}function h(t,e,i){return new Promise((s,r)=>{let n;try{n=i.call(t),n instanceof Promise?n.then((function(t){s(`${t?u:c}: ${e}`)})):(n=n?709394===n?a:u:c,s(`${n}: ${e}`))}catch(t){n=c,s(`${n}: ${e}`)}})}function l(t,e,i,s){return new Promise((r,n)=>{let h;try{h=i.call(t),h=709394===h?u:o(s,null)}catch(t){h=o(s,t)}r(`${h}: ${e}`)})}const[a,c,u]=["Skippd","Failed","Passed"];return{prn(t){const e=t.passed.length,s=t.total,o=e/s*100;console.log(i.white(n(78,"+"))),console.log(i.white.bold(t.title)),console.log(i.white(t.date)),console.log(i.white(n(78,"+"))),t.passed.length>0&&console.log(i.green(t.passed.join("\n"))),t.skippd.length>0&&console.log(i.grey(t.skippd.join("\n"))),t.failed.length>0&&console.log(i.magenta(t.failed.join("\n"))),console.log(i.white(n(78,"="))),console.log(i.yellow(["Passed: ",e,"/",s," [",0|o,"%]"].join(""))),console.log(i.magenta("Failed: "+(s-e))),console.log(i.white(["cpu-time: ",r.prettyMillis(t.duration)].join(""))),console.log(i.white(n(78,"=")))},deftest(t){let[e,i,s,r]=[null,null,null,null];const n={ensure:(t,e)=>(s.push([1,t,e]),n),eerror:(t,e)=>(s.push([911,t,e]),n),begin:t=>(r={},s=[],e=t,n),end(n){i=n;let o=function(){return new Promise((t,n)=>{e&&e(r);let o,a=[];for(let t,e,i=0;i<s.length;++i){switch(e=s[i],e[0]){case 1:t=h(r,e[1],e[2]);break;case 911:t=l(r,e[1],e[2],"any")}o=o?o.then((function(e){return a.push(e),t})):t}o&&o.then((function(e){a.push(e),s.length=0,i&&i(r),t(a)}))})};return(o.title=t)&&o}};return n},_run:t=>new Promise((e,i)=>{t().then((function(t){e(t)}))}),runtest(t,e){const i=Date.now();return this._run(t).then((function(s){const r=Date.now(),n={title:e||t.title,date:(new Date).toString(),total:s.length,duration:r-i,passed:s.filter(t=>"P"===t[0]),skippd:s.filter(t=>"S"===t[0]),failed:s.filter(t=>"F"===t[0])};return new Promise(t=>{t(n)})}))}}}"object"==typeof module&&module.exports?module.exports=e(require("./core"),require("colors/safe")):t["io/czlab/mcfud/test"]=e}(this);