!function(t,e,s){var i,r=256,n="random",o=s.pow(r,6),h=s.pow(2,52),l=2*h,a=255;function c(a,c,p){function m(){for(var t=_.g(6),e=o,s=0;t<h;)t=(t+s)*r,e*=r,s=_.g(1);for(;l<=t;)t/=2,e/=2,s>>>=1;return(t+s)/e}var y=[],w=f(function t(e,s){var i,r=[],n=typeof e;if(s&&"object"==n)for(i in e)try{r.push(t(e[i],s-1))}catch(t){}return r.length?r:"string"==n?e:e+"\0"}((c=1==c?{entropy:!0}:c||{}).entropy?[a,g(e)]:null==a?function(){try{var s;return i&&(s=i.randomBytes)?s=s(r):(s=new Uint8Array(r),(t.crypto||t.msCrypto).getRandomValues(s)),g(s)}catch(s){var n=t.navigator,o=n&&n.plugins;return[+new Date,t,o,t.screen,g(e)]}}():a,3),y),_=new u(y);return m.int32=function(){return 0|_.g(4)},m.quick=function(){return _.g(4)/4294967296},m.double=m,f(g(_.S),e),(c.pass||p||function(t,e,i,r){return r&&(r.S&&d(r,_),t.state=function(){return d(_,{})}),i?(s[n]=t,e):t})(m,w,"global"in c?c.global:this==s,c.state)}function u(t){var e,s=t.length,i=this,n=0,o=i.i=i.j=0,h=i.S=[];for(s||(t=[s++]);n<r;)h[n]=n++;for(n=0;n<r;n++)h[n]=h[o=a&o+t[n%s]+(e=h[n])],h[o]=e;(i.g=function(t){for(var e,s=0,n=i.i,o=i.j,h=i.S;t--;)e=h[n=a&n+1],s=s*r+h[a&(h[n]=h[o=a&o+e])+(h[o]=e)];return i.i=n,i.j=o,s})(r)}function d(t,e){return e.i=t.i,e.j=t.j,e.S=t.S.slice(),e}function f(t,e){for(var s,i=t+"",r=0;r<i.length;)e[a&r]=a&(s^=19*e[a&r])+i.charCodeAt(r++);return g(e)}function g(t){return String.fromCharCode.apply(0,t)}if(f(s.random(),e),"object"==typeof module&&module.exports){module.exports=c;try{i=require("crypto")}catch(c){}}else"function"==typeof define&&define.amd?define((function(){return c})):s["seed"+n]=c}("undefined"!=typeof self?self:this,[],Math),function(t,e,s){"use strict";function i(){const i=t,r=Math.floor,n=Array.prototype.slice,o=Object.prototype.toString;function h(t){return"[object Object]"==o.call(t)}function l(t){return h(t)}function a(t){return"[object Function]"==o.call(t)}function c(t){return"[object Array]"==o.call(t)}function u(t){return"[object Map]"==o.call(t)}function d(t){return"[object Set]"==o.call(t)}function f(t){return"[object String]"==o.call(t)}function g(t){return"[object Number]"==o.call(t)}function p(t){return"[object Boolean]"==o.call(t)}function m(t){return t>0?t%2==0:-t%2==0}function y(t){return void 0===t}function w(t){return c(t)||u(t)||h(t)}const _=1.6180339887;let v=s?s():new Math.seedrandom;function x(t,e){for(let s,i=0;i<t.length;++i)if(s=t[i],!s[0](s[1]))throw new TypeError("wanted "+e);return!0}function k(t,e){for(let e,s=0;s<t.length;++s)if(e=t[s],e[0](e[1]))return!0;throw new TypeError("wanted "+e)}function E(t,e,s){if(t(e))return!0;throw new TypeError("wanted "+s)}const N=/(\/|\\\\)([^(\/|\\\\)]+)$/g,b=/(\.[^\.\/\?\\]*)(\?.*)?$/;function M(t,e){let s=b.exec(t);return s&&s[1]?(s=s[1].toLowerCase(),e||(s=s.substring(1))):s="",s}let T=0;function q(t,e,s){let i=t(e);switch(s.length){case 0:return i;case 1:return i&&t(s[0]);case 2:return i&&t(s[0])&&t(s[1]);case 3:return i&&t(s[0])&&t(s[1])&&t(s[2]);default:return i&&s.every(e=>t(e))}}const I={},S={fun:(t,...e)=>q(a,t,e),str:(t,...e)=>q(f,t,e),undef:(t,...e)=>q(y,t,e),map:(t,...e)=>q(u,t,e),set:(t,...e)=>q(d,t,e),num:(t,...e)=>q(g,t,e),bool:(t,...e)=>q(p,t,e),pos:t=>g(t)&&t>0,neg:t=>g(t)&&t<0,vec:(t,...e)=>q(c,t,e),obj:(t,...e)=>q(h,t,e),some:t=>A.size(t)>0,none:t=>0===A.size(t),own:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},A={error(...t){console.error(...t)},log(...t){console.log(...t)},srand(){v=s?s():new Math.seedrandom},feq0:t=>Math.abs(t)<1e-10,feq:(t,e)=>Math.abs(t-e)<1e-10,pack:t=>JSON.stringify(t),unpack:t=>JSON.parse(t),v2:(t=0,e=0)=>[t,e],p2:(t=0,e=0)=>({x:t,y:e}),numOrZero:t=>isNaN(t)?0:t,setVec(t,...e){e.forEach((e,s)=>t[s]=e)},evenN:(t,e)=>m(t=Math.floor(t))?t:e?t+1:t-1,nichts:t=>null==t,echt:t=>null!=t,nor:(t,e)=>null==t?e:t,or:(t,e)=>void 0===t?e:t,toNum(t,e){const s=parseFloat(t);return isNaN(s)&&g(e)?e:s},percentRemain:(t,e,s)=>(t>e&&(t=s?t%e:e),Math.max(0,e-t)/e),splitVerStr(t){const e=(""+(t||"")).split(".").filter(t=>t.length>0);return[this.toNum(e[0],0),this.toNum(e[1],0),this.toNum(e[2],0)]},cmpVerStrs(t,e){let s=this.splitVerStr(""+t),i=this.splitVerStr(""+e);return s[0]>i[0]?1:s[0]<i[0]?-1:s[1]>i[1]?1:s[1]<i[1]?-1:s[2]>i[2]?1:s[2]<i[2]?-1:0},pdef:t=>(t.configurable=!0)&&(t.enumerable=!0)&&t,findFiles:(t,e)=>t.filter(t=>e.indexOf(M(t,1))>-1),zipMap(t,e,s){let i=Math.min(t.length,e.length),r=s||new Map;for(let s=0;s<i;++s)r.set(t[s],e[s]);return r},zip(t,e,s){return this.zipMap(t,e,s)},zipObj(t,e,s){let i=Math.min(t.length,e.length),r=s||{};for(let s=0;s<i;++s)r[t[s]]=e[s];return r},partition(t,e){const s=[];for(let i,r,n=0;;){for(i=[],r=0;r<t;++r){if(!(n<e.length)){r=-1;break}i.push(e[n++])}if(i.length>0&&s.push(i),r<0)break}return s},keys:t=>u(t)?Array.from(t.keys()):h(t)?Object.keys(t):[],selectNotKeys(t,e){k([[u,t],[h,t]],"map/object");const s=u(t)?new Map:{};return e=this.seq(e),this.doseq(t,(t,i)=>!e.includes(i)&&this.assoc(s,i,t)),s},selectKeys(t,e){k([[u,t],[h,t]],"map/object");const s=u(t)?new Map:{};return this.seq(e).forEach(e=>{u(t)?t.has(e)&&s.set(e,t.get(e)):S.own(t,e)&&(s[e]=t[e])}),s},assertNot(t,...e){return this.assert(!t,...e)},assert(t,...e){if(!t)throw 0===e.length?"Assertion!":e.join("");return!0},noSuchKeys(t,e){return!this.some(this.seq(t),t=>this.has(e,t)?t:null)},randInt2:(t,e)=>function(t,e){return r(v()*(e-t+1)+t)}(t,e),randFloat:(t,e)=>t+v()*(e-t),randMinus1To1:()=>2*(v()-.5),randInt:t=>r(v()*t),rand:(t=!1)=>t?Math.random():v(),randGaussian(t=6){let e=0;for(let s=0;s<t;++s)e+=this.rand();return e/t},randSign:()=>v()>.5?-1:1,toGoldenRatio(t){let e=t/_,s=e/_;return[this.rounded(e),this.rounded(s)]},inst:(t,e)=>e instanceof t,hashCode(t){let e=0;for(let s=0;s<t.length;++s)e=Math.imul(31,e)+t.charCodeAt(s);return e},cls(t){try{t.length=0}catch(t){}return t},randSample(t,e=1){let s;if(1==e)s=[this.randItem(t)];else if(0==e)s=[];else if(e>0){let i=this.shuffle(t,!1);s=e>=i.length?i:i.slice(0,e)}return s},randItem(t,e){let s,i=-1;if(t)switch(t.length){case 0:case 1:s=t[i=0];break;case 2:s=t[i=this.randSign()>0?1:0];break;default:s=t[i=r(v()*t.length)]}return e?[s,i]:s},isPerc:t=>f(t)&&t.match(/^([0-9])(\.?[0-9]+|[0-9]*)%$/),isEven:t=>m(t),jsMap(...t){E(m,t.length,"even n# of args");let e=new Map;for(let s=0;s<t.length;)e.set(t[s],t[s+1]),s+=2;return e},jsObj(...t){E(m,t.length,"even n# of args");let e={};for(let s=0;s<t.length;)e[t[s]]=t[s+1],s+=2;return e},jsVec:(...t)=>0===t.length?[]:t.slice(),lastIndex:t=>c(t)&&t.length>0?t.length-1:-1,first(t){if(c(t)&&t.length>0)return t[0]},last(t){if(c(t)&&t.length>0)return t[t.length-1]},head(t){return this.first(t)},tail(t){return this.last(t)},floor:t=>Math.floor(t),ceil:t=>Math.ceil(t),abs:t=>Math.abs(t),sqrt:t=>Math.sqrt(t),min:(...t)=>Math.min(...t),max:(...t)=>Math.max(...t),slice:(t,e)=>n.call(t,e),every(t,e){E(c,t,"array");for(let s=0;s<t.length;++s)if(a(e)){if(!e(t[s]))return!1}else if(t[s]!=e)return!1;return t.length>0},notAny(t,e){E(c,t,"array");for(let s=0;s<t.length;++s)if(a(e)){if(e(t[s]))return!1}else if(t[s]===e)return!1;return t.length>0},copy(t,e=[]){x([[c,t],[c,e]],"arrays");const s=Math.min(t.length,e.length);for(let i=0;i<s;++i)t[i]=e[i];return t},append(t,e=[],s=!1){x([[c,t],[c,e]],"arrays"),s&&(t.length=0);for(let s=0;s<e.length;++s)t.push(e[s]);return t},fill(t,e,...s){if(g(t)&&(t=new Array(t)),c(t))for(let i=0;i<t.length;++i)t[i]=a(e)?e(i,...s):e;return t},size(t){return c(t)||f(t)?t.length:d(t)||u(t)?t.size:t?this.keys(t).length:0},nextId:()=>++T,now:()=>Date.now(),fileExt:t=>M(t),fileBase(t){let e,s,i=t.indexOf("?");return i>0&&(t=t.substring(0,i)),t=t.replace(/(\/|\\\\)$/,""),s=N.exec(t),e="",s&&(e=s[2],i=e.lastIndexOf("."),i>0&&(e=e.substring(0,i))),e},range(t,e,s=1){1===arguments.length&&(e=t,t=0,s=1);let i=(e-t)/s;const r=[];i=Math.ceil(i),i=Math.max(0,i),r.length=i;for(let e=0;e<i;++e)r[e]=t,t+=s;return r},shuffle(t,e=!0){E(c,t,"array");const s=n.call(t,0);switch(s.length){case 0:case 1:break;case 2:if(this.randSign()>0){let t=s[0];s[0]=s[1],s[1]=t}break;default:for(let t,e,i=s.length-1;i>0;--i)e=r(v()*(i+1)),t=s[i],s[i]=s[e],s[e]=t}return e?this.copy(t,s):s},shuffle2(t,e=!0){if(E(c,t,"array"),t.length<3)t=this.shuffle(t,e);else{const e=t.length;n.call(t,0);for(let s,i,n=0;n<e;++n)i=n+r(v()*(e-n)),s=t[i],t[i]=t[n],t[n]=s}return t},uniq:t=>(E(c,t,"array"),Array.from(new Set(t))),map(t,e,s){if(E(w,t,"array/map/object"),c(t))return t.map(e,s);{const i=u(t)?new Map:{};return this.doseq(t,(r,n)=>{this.assoc(i,n,e.call(s,r,n,t))}),i}},find(t,e,s){let i,r=!0,o=n.call(arguments,3);return this.doseq(t,(t,n)=>{r&&e.apply(s,[t,n].concat(o))&&(i=[n,t],r=!1)}),i},some(t,e,s){let i,r=!0,o=n.call(arguments,3);return this.doseq(t,(t,n)=>{r&&(i=e.apply(s,[t,n].concat(o)),i?r=!1:i=void 0)}),i},equals(t,e){if(l(t)&&l(e)){let s,i,r=Object.keys(t),n=Object.keys(e);if(r.length==n.length){for(let o=0;o<r.length;++o)if(s=r[o],i=n[o],!this.equals(s,i)||!this.equals(t[s],e[i]))return!1;return!0}return!1}if(c(t)&&c(e)){if(t.length==e.length){for(let s=0;s<t.length;++s)if(!this.equals(t[s],e[s]))return!1;return!0}return!1}if(g(t)&&g(e))return t==e;if(f(t)&&f(e))return t==e;if(p(t)&&p(e))return t==e;if(null===t&&null===e)return!0;if(void 0===t&&void 0===e)return!0;throw Error("cant call equals for these types")},invoke(t,e){let s=n.call(arguments,2);c(t)&&t.forEach(t=>t[e].apply(t,s))},delay:(t,e)=>setTimeout(e,t),timer:(t,e=0,s=!1)=>({repeat:!!s,id:s?setInterval(t,e):setTimeout(t,e)}),clear(t){t&&t.id?(t.repeat?clearInterval(t.id):clearTimeout(t.id),t.id=0):S.pos(t)&&clearTimeout(t)},dotimes(t,e,s,...i){for(let r=0;r<t;++r)e.call(s,r,...i)},rseq(t,e,s){if(E(c,t,"array"),t.length>0)for(let i=t.length-1;i>=0;--i)e.call(s,t[i],i,t)},doseq(t,e,s){c(t)?t.forEach(e,s):u(t)?t.forEach((i,r)=>e.call(s,i,r,t)):h(t)&&Object.keys(t).forEach(i=>e.call(s,t[i],i,t))},doseqEx(t,e,s){this.doseq(t,(i,r)=>null!=i&&e.call(s,i,r,t))},dissoc(t,e){if(arguments.length>2){let e,s=1;for(;s<arguments.length;++s)e=this.dissoc(t,arguments[s]);return e}{let s;return u(t)?(s=t.get(e),t.delete(e)):h(t)&&(s=t[e],delete t[e]),s}},get(t,e){if(void 0!==e){if(u(t))return t.get(e);if(t)return t[e]}},assoc(t,e,s){if(arguments.length>3){if((arguments.length-1)%2!=0)throw"wanted even count of args";let e,s=1;for(;s<arguments.length;)e=this.assoc(t,arguments[s],arguments[s+1]),s+=2;return e}{let i;return u(t)?(i=t.get(e),t.set(e,s)):t&&(i=t[e],t[e]=s),i}},disj(t,e){const s=t?t.indexOf(e):-1;return s>-1&&t.splice(s,1),s>-1},conj:(t,...e)=>(t&&e.forEach(e=>t.push(e)),t),seq:(t,e=/[,; \t\n]+/)=>("string"==typeof t&&(t=t.split(e).map(t=>t.trim()).filter(t=>t.length>0)),c(t)||(t=[t]),t),has(t,e){return 1!==arguments.length&&(u(t)?t.has(e):c(t)?-1!==t.indexOf(e):!!h(t)&&S.own(t,e))},patch(t,e){return E(h,t=t||{},"object"),e&&Object.keys(e).forEach(s=>{this.has(t,s)||(t[s]=e[s])}),t},clone(t){return t?this.unpack(this.pack(t)):t},inject:(t,...e)=>(t=t||{},e.forEach(e=>e&&function(t,e){let s=Object.keys(e).reduce((t,s)=>(t[s]=Object.getOwnPropertyDescriptor(e,s),t),{});return Object.getOwnPropertySymbols(e).forEach(t=>{let i=Object.getOwnPropertyDescriptor(e,t);i.enumerable&&(s[t]=i)}),Object.defineProperties(t,s),t}(t,e)),t),deepCopyArray(t){E(c,t,"array");const e=[];for(let s=0,i=t.length;s<i;++s)e[s]=c(t[s])?this.deepCopyArray(t[s]):t[s];return e},mergeEx(t,e){return this.merge(this.merge({},t),e)},merge(t,e){let s;return Object.keys(e).forEach(i=>{s=e[i],"object"==typeof s&&null!==s&&t[i]?("object"!=typeof t[i]&&(t[i]=s instanceof Array?[]:{}),this.merge(t[i],s)):t[i]=s}),t},throttle(t,e,s){let i=!0,r=!0;if("function"!=typeof t)throw new TypeError("Expected a function");return h(s)&&(i="leading"in s?!!s.leading:i,r="trailing"in s?!!s.trailing:r),this.debounce(t,e,{leading:i,trailing:r,maxWait:e})},debounce(t,e,s){let r,n,o,h,a,c,u=0,d=!1,f=!1,g=!0;const p=!e&&0!==e&&"function"==typeof i.requestAnimationFrame;if("function"!=typeof t)throw new TypeError("Expected a function");function m(e){const s=r,i=n;return r=n=void 0,u=e,h=t.apply(i,s),h}function y(t,e){return p?(i.cancelAnimationFrame(a),i.requestAnimationFrame(t)):setTimeout(t,e)}function w(t){const s=t-c;return void 0===c||s>=e||s<0||f&&t-u>=o}function _(){const t=Date.now();if(w(t))return v(t);a=y(_,function(t){const s=t-u,i=e-(t-c);return f?Math.min(i,o-s):i}(t))}function v(t){return a=void 0,g&&r?m(t):(r=n=void 0,h)}function x(...t){const s=Date.now(),i=w(s);if(r=t,n=this,c=s,i){if(void 0===a)return function(t){return u=t,a=y(_,e),d?m(t):h}(c);if(f)return a=y(_,e),m(c)}return void 0===a&&(a=y(_,e)),h}return e=+e||0,l(s)&&(d=!!s.leading,f="maxWait"in s,o=f?Math.max(+s.maxWait||0,e):o,g="trailing"in s?!!s.trailing:g),x.cancel=function(){void 0!==a&&function(t){if(p)return i.cancelAnimationFrame(t);clearTimeout(t)}(a),u=0,r=c=n=a=void 0},x.flush=function(){return void 0===a?h:v(Date.now())},x.pending=function(){return void 0!==a},x},negate:t=>(E(a,t,"function"),function(...e){return!t.apply(this,e)}),strPadRight:(t,e,s)=>(e-=t.length)>0?t+new Array(Math.ceil(e/s.length)+1).join(s).substr(0,e):t,strPadLeft:(t,e,s)=>(e-=t.length)>0?new Array(Math.ceil(e/s.length)+1).join(s).substr(0,e)+t:t,safeSplit:(t,e)=>(t||"").trim().split(e).filter(t=>t.length>0),capitalize:t=>t.charAt(0).toUpperCase()+t.slice(1),prettyNumber(t,e=2,s="0"){return this.strPadLeft(Number(t).toString(),e,s)},prettyMillis(t){let e,s,i=r(t/1e3);s=r(i/60),t-=1e3*i,i-=60*s,e=r(s/60),s-=60*e;let n=[];return n.push(`${i}.${t} secs`),(s>0||e>0)&&n.push(s+" mins, "),e>0&&n.push(e+" hrs, "),n.reverse().join("")},swap(t,e,s){let i=t[e];return t[e]=t[s],t[s]=i,t},listIndexesOf(t,e){let s=A.fill(t.length,t=>t);return e?this.shuffle(s):s},dropArgs:(t,e)=>t.length>e?n.call(t,e):[],isSSL:()=>t&&t.location&&t.location.protocol.indexOf("https")>=0,isMobile:t=>t&&/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(t.userAgent),isSafari:t=>t&&/Safari/.test(t.userAgent)&&/Apple Computer/.test(t.vendor),isCrossOrigin(e){let s=t;if(2===arguments.length&&911===arguments[1].hack&&(s=arguments[1]),s&&s.location&&e){const t=e.indexOf("://");if(t>0){let i=e.indexOf("/",t+3);return(i<0?e:e.substring(0,i))!=s.location.origin}}},addEvent(t,e,s,i){c(t)&&1===arguments.length?t.forEach(t=>this.addEvent.apply(this,t)):e.addEventListener(t,s,i)},delEvent(t,e,s,i){c(t)&&1===arguments.length?t.forEach(t=>this.delEvent.apply(this,t)):e.removeEventListener(t,s,i)},rounded(t){return this.roundUnderOffset(t,.5)},roundUnderOffset(t,e){let s=Math.floor(t);return t-s<e?s:s+1}},O={qSelector:t=>e.querySelectorAll(t),qId:t=>e.getElementById(t),parent(t){if(t)return t.parentNode},conj:(t,e)=>t.appendChild(e),byTag:(t,s)=>f(s)?e.getElementsByTagNameNS(s,t):e.getElementsByTagName(id),attrs(t,e){return!h(e)&&e?(arguments.length>2&&t.setAttribute(e,arguments[2]),t.getAttribute(e)):(e&&A.doseq(e,(e,s)=>t.setAttribute(s,e)),t)},css(t,e){return!h(e)&&e?(arguments.length>2&&(t.style[e]=arguments[2]),t.style[e]):(e&&A.doseq(e,(e,s)=>t.style[s]=e),t)},wrap(t,e){const s=t.parentNode;return e.appendChild(t),s.appendChild(e),e},newElm(t,s,i){const r=e.createElement(t);return this.attrs(r,s),this.css(r,i),r},newTxt(t,s,i){const r=e.createTextNode(t);return this.attrs(r,s),this.css(r,i),r}},z={},P=[];class D{constructor(){this._tree=new Map,this._targets=new Map}sub(t,e,s,i){let r=t[0],n=t[1];return n&&!this._targets.has(n)&&this._targets.set(n,1),A.seq(r).forEach(t=>{if(e||(e=t),f(e)&&(e=(s=s||n)[e]),!e)throw"Error: no callback for sub()";this._tree.has(t)||this._tree.set(t,A.jsMap());let r=this._tree.get(t);n=n||z,!r.has(n)&&r.set(n,[]),r.get(n).push([e,s,i])}),this}pub(t,...e){let s,i,r=t[0],n=t[1]||z;return(n===z||this._targets.has(n))&&A.seq(r).forEach(t=>{i=this._tree.get(t),s=i&&i.get(n),s&&s.forEach(t=>{t[0].apply(t[1],e.concat(t[2]||P))})}),this}reset(){return this._targets.clear(),this._tree.clear(),this}drop(t){if(this._targets.has(t)){this._targets.delete(t);let e=this._tree.values();for(let s=e.next();!s.done;)s.value.delete(t),s=e.next()}return this}unsub(t,e,s){if(1!==arguments.length||S.vec(t)){let i=t[0],r=t[1]||z;if(r===z||this._targets.has(r)){let t,n;A.seq(i).forEach(i=>{if(t=this._tree.get(i),n=t&&t.get(r),n&&(f(e)&&(e=(s=s||r)[e]),e))for(let t=n.length-1;t>=0;--t)n[t][0]===e&&n[t][1]===s&&n.splice(t,1)})}}else this.drop(t);return this}}return e?I.dom=O:(delete A.addEvent,delete A.delEvent),I.EventBus=function(){return new D},I.is=S,I.u=A,I}"object"==typeof module&&module.exports?s=require("../tpcl/seedrandom.min"):e=t.document,"object"==typeof module&&module.exports?module.exports=i():t["io/czlab/mcfud/core"]=i}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const s=360,i=2*Math.PI,{is:r,u:n}=(Math.PI,e);function o(t){return t<0?- -t%s:t%s}return{lerp:(t,e,s)=>(1-s)*t+s*e,xmod:(t,e)=>t<0?t- -(e+e*Math.floor(-t/e)):t%e,clamp:(t,e,s)=>s<t?t:s>e?e:s,sqr:t=>t*t,fuzzyEq:(t,e)=>n.feq(t,e),fuzzyZero:t=>n.feq0(t),radToDeg:t=>o(s*t/i),degToRad:t=>i*o(t)/s,pythag2:(t,e)=>t*t+e*e,pythag:(t,e)=>Math.sqrt(t*t+e*e),wrap:(t,e)=>(t+1)%e,biasGreater:(t,e)=>t>=.95*e+.01*t}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/math"]=e}(this),function(t){"use strict";function e(e=null){e||(e=t["io/czlab/mcfud/core"]());const{u:s,is:i}=e;function r(t,e){s.assert(!i.num(t)&&!i.num(e)&&t&&e,"wanted 2 vecs")}function n(t,e=0,s=0){return t?[e,s]:{x:e,y:s}}const o={};class h{constructor(){this.x=0,this.y=0}unit(t){return i.bool(t)&&(t=n(t)),i.vec(t)?(t[0]=this.x,t[1]=this.y):(t.x=this.x,t.y=this.y),t}bind(t){return i.vec(t)?(this.x=t[0],this.y=t[1]):(this.x=t.x,this.y=t.y),this}op(t,e,s){let r=o.take();switch(r.x=this.x,r.y=this.y,t){case"+":i.num(e)&&(r.x+=e),i.num(s)&&(r.y+=s);break;case"-":i.num(e)&&(r.x-=e),i.num(s)&&(r.y-=s);break;case"*":i.num(e)&&(r.x*=e),i.num(s)&&(r.y*=s);break;case"/":i.num(e)&&(r.x/=e),i.num(s)&&(r.y/=s)}return r}"+"(t){return this.op("+",t.x,t.y)}"-"(t){return this.op("-",t.x,t.y)}"*"(t){return this.op("*",t.x,t.y)}"/"(t){return this.op("/",t.x,t.y)}}function l(t,e,s,r,n,o,h){const l=t-n,a=e-o,c=n+(l*s-a*r),u=o+(l*r+a*s);return i.vec(h)?(h[0]=c,h[1]=u):(h.x=c,h.y=u),h}function a(t,e,s,r){let n,h,l=o.take().bind(t);if(i.num(e))h=l.op(s,e,e);else{let t=o.take().bind(e);h=l[s](t),o.drop(t)}return n=h.unit(r?t:i.vec(t)),o.drop(l,h),n}s.inject(o,{take(){return this._pool.pop()},drop(...t){t.forEach(t=>{t.x=0,t.y=0,this._pool.push(t)})},_pool:s.fill(16,()=>new h)});return{vec:(t=0,e=0)=>n(!0,t,e),vecXY:(t=0,e=0)=>n(!1,t,e),add(t,e){return s.assert(2===arguments.length)&&a(t,e,"+")},add$(t,e){return s.assert(2===arguments.length)&&a(t,e,"+",!0)},sub(t,e){return s.assert(2===arguments.length)&&a(t,e,"-")},sub$(t,e){return s.assert(2===arguments.length)&&a(t,e,"-",!0)},mul(t,e){return s.assert(2===arguments.length)&&a(t,e,"*")},mul$(t,e){return s.assert(2===arguments.length)&&a(t,e,"*",!0)},div(t,e){return s.assert(2===arguments.length)&&a(t,e,"/")},div$(t,e){return s.assert(2===arguments.length)&&a(t,e,"/",!0)},dot(t,e){r(t,e);let s=o.take().bind(t),i=o.take().bind(e),n=s.x*i.x+s.y*i.y;return o.drop(s,i),n},equals(t,e){let s=o.take().bind(t),i=o.take().bind(e);return ok=s.x==i.x&&s.y==i.y,o.drop(s,i),ok},vecAB(t,e){r(t,e);let s=o.take().bind(t),n=o.take().bind(e),h=o.take();h.x=n.x-s.x,h.y=n.y-s.y;let l=h.unit(i.vec(t));return o.drop(s,n,h),l},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},dist2(t,e){return this.len2(this.sub(e,t))},dist(t,e){return Math.sqrt(this.dist2(t,e))},unit(t){let e=o.take().bind(t),r=this.len(t);s.feq0(r)?(e.x=0,e.y=0):(e.x/=r,e.y/=r);let n=e.unit(i.vec(t));return o.drop(e),n},unit$(t){let e=o.take().bind(t),i=this.len(t);s.feq0(i)?(e.x=0,e.y=0):(e.x/=i,e.y/=i);let r=e.unit(t);return o.drop(e),r},copy(t,e){r(t,e);let s=o.take().bind(t),i=o.take().bind(e);s.x=i.x,s.y=i.y;let n=s.unit(t);return o.drop(s,i),n},clone(t){let e=o.take().bind(t),s=e.unit(i.vec(t));return o.drop(e),s},set(t,e,s){let r=o.take().bind(t);i.num(e)&&(r.x=e),i.num(s)&&(r.y=s);let n=r.unit(t);return o.drop(r),n},setX(t,e){return this.set(t,e)},setY(t,e){return this.set(t,null,e)},rot(t,e,s=null){let r=o.take().bind(t),h=0,a=0;if(s){let t=o.take().bind(s);h=t.x,a=t.y,o.drop(t)}let c=l(r.x,r.y,Math.cos(e),Math.sin(e),h,a,n(i.vec(t)));return o.drop(r),c},rot$(t,e,s){let i=o.take().bind(t),r=0,n=0;if(s){let t=o.take().bind(s);r=t.x,n=t.y,o.drop(t)}let h=l(i.x,i.y,Math.cos(e),Math.sin(e),r,n,t);return o.drop(i),h},cross(t,e){let s;if(i.num(t)){let r=o.take().bind(e),n=o.take();n.x=-t*r.y,n.y=t*r.x,s=n.unit(i.vec(e)),o.drop(r,n)}else if(i.num(e)){let r=o.take().bind(t),n=o.take();n.x=e*r.y,n.y=-e*r.x,s=n.unit(i.vec(t)),o.drop(r,n)}else{r(t,e);let i=o.take().bind(t),n=o.take().bind(e);s=i.x*n.y-i.y*n.x,o.drop(i,n)}return s},angle(t,e){return Math.acos(this.dot(t,e)/(this.len(t)*this.len(e)))},normal(t,e=!1){let s=o.take().bind(t),r=o.take();e?(r.x=-s.y,r.y=s.x):(r.x=s.y,r.y=-s.x);let n=r.unit(i.vec(t));return o.drop(s,r),n},normal$(t,e=!1){let s=o.take().bind(t),i=o.take();e?(i.x=-s.y,i.y=s.x):(i.x=s.y,i.y=-s.x);let r=i.unit(t);return o.drop(s,i),r},proj_scalar(t,e){return this.dot(t,e)/this.len(e)},proj(t,e){const s=this.unit(e);this.mul$(s,this.dot(t,s));let r=o.take().bind(s),n=r.unit(i.vec(t));return o.drop(r),n},perp(t,e){return this.sub(t,this.proj(t,e))},reflect(t,e){let s=2*this.dot(t,e);return this.sub(t,this.mul(e,s))},flip(t){return this.mul(t,-1)},flip$(t){return this.mul$(t,-1)},translate(t,...e){let s,r,n,h,l=o.take().bind(t);return 1===e.length&&i.vec(e[0])&&!i.num(e[0][0])&&(e=e[0]),n=e.map(t=>(r=o.take().bind(t),s=r["+"](l),h=s.unit(i.vec(t)),o.drop(r,s),h)),o.drop(l),n}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/vec2"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());Math.atan2;const s=Math.cos,i=Math.sin,r=(Math.tan,Math.floor),{u:n,is:o}=e;function h(t){return t%2!=0}function l(t,e,s,i){return i-1+(s-1)*e}function a(t,e,s){return{dim:[t,e],cells:s}}function c(t,e){return a(t,e,n.fill(t*e,0))}return{v4:(t=0,e=0,s=0,i=0)=>[t,e,s,i],v3:(t=0,e=0,s=0)=>[t,e,s],dot:(t,e)=>t[0]*e[0]+t[1]*e[1]+t[2]*e[2],cross(t,e){return this.v3(t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0])},len2(t){return this.dot(t,t)},len(t){return Math.sqrt(this.len2(t))},unit(t){let e=this.len(t);if(!n.feq0(e))return[t[0]/e,t[1]/e,t[2]/e]},sub(t,e){return o.num(e)?this.v3(t[0]-e,t[1]-e,t[2]-e):this.v3(t[0]-e[0],t[1]-e[1],t[2]-e[2])},add(t,e){return o.num(e)?this.v3(t[0]+e,t[1]+e,t[2]+e):this.v3(t[0]+e[0],t[1]+e[1],t[2]+e[2])},mul(t,e){return o.num(e)?this.v3(t[0]*e,t[1]*e,t[2]*e):this.v3(t[0]*e[0],t[1]*e[1],t[2]*e[2])},div(t,e){return o.num(e)?this.v3(t[0]/e,t[1]/e,t[2]/e):this.v3(t[0]/e[0],t[1]/e[1],t[2]/e[2])},matrix([t,e],...s){const i=t*e;return 0===s.length?c(t,e):n.assert(i===s.length)&&a(t,e,s)},matCell(t,e,s,i){const r=l(t.dim[0],t.dim[1],e,s);if(r>=0&&r<t.cells.length)return o.num(i)?(t.cells[r]=i,t):t.cells[r]},matIdentity(t){const e=n.assert(t>0)&&n.fill(t*t,0);for(let s=0;s<t;++s)e[l(0,t,s+1,s+1)]=1;return a(t,t,e)},matZero:t=>n.assert(t>0)&&a(t,t,n.fill(t*t,0)),matRowMajors(t){const[e,s]=t.dim;return n.partition(s,t.cells)},matColMajors(t){const[e,s]=t.dim,i=[];for(let r,n=0;n<s;++n){r=[];for(let i=0;i<e;++i)r.push(t.cells[i*s+n]);i.push(r)}return i},mat2(t,e,s,i){return this.matrix([2,2],t,e,s,i)},mat3(t,e,s,i,r,n,o,h,l){return this.matrix([3,3],t,e,s,i,r,n,o,h,l)},mat4(t,e,s,i,r,n,o,h,l,a,c,u,d,f,g,p){return this.matrix([4,4],t,e,s,i,r,n,o,h,l,a,c,u,d,f,g,p)},matEq:(t,e)=>t.dim[0]===e.dim[0]&&t.dim[1]===e.dim[1]&&function(t,e){for(let s=0;s<t.length;++s)if(!n.feq(t[s],e[s]))return!1;return!0}(t.cells,e.cells),matXpose(t){const[e,s]=t.dim,i=e*s,n=[];for(let o=0;o<i;++o)n.push(t.cells[r(o/e)+s*(o%e)]);return a(s,e,n)},matScale:(t,e)=>a(t.dim[0],t.dim[1],t.cells.map(t=>t*e)),matMult(t,e){let[s,i]=t.dim,[r,o]=e.dim,h=t.cells,l=e.cells;n.assert(i===r,"mismatch matrices");let c=new Array(s*o);for(let t=0;t<s;++t)for(let e=0;e<o;++e)c[e+t*o]=n.range(r).reduce((s,r)=>s+h[r+t*i]*l[e+r*o],0);return a(s,o,c)},matDet(t){let[e,s]=t.dim,i=[];if(2===s)return this._matDet2x2(t);for(let e=0;e<s;++e)n.conj(i,this.matDet(this.matCut(t,1,e+1)));return n.range(s).reduce((e,s)=>{let r=i[s];return e+t.cells[s]*(h(s)?-r:r)},0)},_matDet2x2:t=>(n.assert(4===t.cells.length),t.cells[0]*t.cells[3]-t.cells[1]*t.cells[2]),matCut(t,e,s){const[i,r]=t.dim;let o=e-1,h=s-1,l=[];for(let e=0;e<i;++e)for(let s=0;s<r;++s)e!==o&&s!==h&&n.conj(l,t.cells[s+e*r]);return a(i-1,r-1,l)},matMinor(t){const[e,s]=t.dim;let i=[];if(n.assert(e===s),2===s)return this._matMinor2x2(t);for(let r=0;r<e;++r)for(let e=0;e<s;++e)n.conj(i,this.matDet(this.matCut(t,r+1,e+1)));return a(e,s,i)},_matMinor2x2(t){return n.assert(4===t.cells.length)&&this.mat2(t.cells[3],t.cells[2],t.cells[1],t.cells[0])},matCofactor(t){const e=this.matMinor(t),[s,i]=e.dim;let r=e.cells.slice();for(let t=0;t<s;++t)for(let e,s=0;s<i;++s)e=t*i+s,h(t+s)&&(r[e]=-r[e]);return a(s,i,r)},matAdjugate(t){return this.matXpose(this.matCofactor(t))},_minv2x2(t){const[e,s]=t.dim;n.assert(4===t.cells.length&&2===e&&2===s);let i,r=t.cells,o=r[0]*r[3]-r[1]*r[2];if(n.feq0(o))i=this.matIdentity(e);else{let t=1/o;i=this.mat2(r[3]*t,-r[1]*t,-r[2]*t,r[0]*t)}return i},matInv(t){const[e,s]=t.dim;if(2===s)return this._minv2x2(t);let i=this.matDet(t);return n.feq0(i)?this.matIdentity(e):this.matScale(this.matAdjugate(t),1/i)},matFromColMajor(t){let e=t.length,s=c(t[0].length,e);for(let i,r=0;r<t.length;++r){i=t[r];for(let t=0;t<i.length;++t)s.cells[t*e+r]=i[t]}return s},matToColMajor(t){const[e,s]=t.dim,i=[];t.cells.slice();for(let r,n=0;n<s;++n){r=[];for(let i=0;i<e;++i)r.push(t.cells[i*s+n]);i.push(r)}return i},scale3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,1,1)]=t[0],e.cells[l(0,4,2,2)]=t[1],e.cells[l(0,4,3,3)]=t[2],e},translate3D(t){const e=this.matIdentity(4);return e.cells[l(0,4,4,1)]=t[0],e.cells[l(0,4,4,2)]=t[1],e.cells[l(0,4,4,3)]=t[2],e},rot3D(t,e,s){return this.matMult(this.zRot3D(s),this.matMult(this.yRot3D(e),this.xRot3D(t)))},matVMult(t,e){let s=t.dim[1],i=e.length;n.assert(s===i);let r=this.matMult(t,a(i,1,e)),o=r.cells;return r.cells=null,o},rot2D(t){return this.mat2(s(t),-i(t),i(t),s(t))},xRot3D(t){return this.mat4(1,0,0,0,0,s(t),-i(t),0,0,i(t),s(t),0,0,0,0,1)},yRot3D(t){return this.mat4(s(t),0,i(t),0,0,1,0,0,-i(t),0,s(t),0,0,0,0,1)},zRot3D(t){return this.mat4(s(t),-i(t),0,0,i(t),s(t),0,0,0,0,1,0,0,0,0,1)},isIdentity(t){const[e,s]=t.dim;if(e===s){for(let i,r=0;r<e;++r)for(let e=0;e<s;++e)if(i=t.cells[r*s+e],r+1===e+1){if(1!==i)return!1}else if(0!==i)return!1;return!0}return!1},isOrthogonal(t){let e=this.matDet(t);return 1===Math.abs(e)&&this.isIdentity(this.matMult(this.matXpose(t),this.matInv(t)))}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/matrix"]=e}(this),function(t){"use strict";const e=" @N/\\Ri2}aP`(xeT4F3mt;8~%r0v:L5$+Z{'V)\"CKIc>z.*fJEwSU7juYg<klO&1?[h9=n,yoQGsW]BMHpXb6A|D#q^_d!-",s=e.length;function i(i){i||(i=t["io/czlab/mcfud/core"]());const{u:r}=i;function n(t){return Math.abs(t)%s}function o(t,s){return(s||e).charAt(t)}function h(t){for(let e=0;e<s;++e)if(o(e)===t)return e;return-1}function l(t,e){let i=e+t;return o(i>=s?i-s:i)}function a(t,e){let i=e-t;return o(i<0?s+i:i)}return{encrypt(t,e){if(0===e)return t;let s,i=[],r=n(e);return t.split("").forEach(t=>{s=h(t),i.push(s<0?t:function(t,e,s){return t<0?l(e,s):a(e,s)}(e,r,s))}),i.join("")},decrypt(t,e){if(0===e)return t;let s,i=[],r=n(e);return t.split("").forEach(t=>{s=h(t),i.push(s<0?t:function(t,e,s){return t<0?a(e,s):l(e,s)}(e,r,s))}),i.join("")}}}"object"==typeof module&&module.exports?module.exports=i(require("./core")):t["io/czlab/mcfud/crypt"]=i}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());return{fsm(t){let e=t.initState();return{state:()=>e,process(){const s=t[e];s&&s.run&&s.run()},trigger(s="change",i){const r=t[e],n=r&&r.transitions[s];if(n){const s=n.target,o=t[s];if(o)return r.exit&&r.exit(),o.enter&&o.enter(),i&&i.action?i.action():n.action&&(i?n.action(i):n.action()),e=s}}}}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/fsm"]=e}(this),function(t){"use strict";function e(e,s,i){e||(e=t["io/czlab/mcfud/core"]()),s||(s=t["io/czlab/mcfud/math"]()),i||(i=t["io/czlab/mcfud/matrix"]());const r=2*Math.PI,{u:n}=e;return{setContextTransform(t,e){t.transform(e.cells[0],e.cells[3],e.cells[1],e.cells[4],e.cells[2],e.cells[5])},textStyle(t,e,s,i){const r={font:t,fill:e};return s&&(r.align=s),i&&(r.base=i),r},drawShape(t,e,...s){e&&e.draw&&e.draw(t,...s)},cfgStyle(t,e){const{line:s,stroke:i}=e;s&&(s.cap&&(t.lineCap=s.cap),s.width&&(t.lineWidth=s.width)),i&&i.style&&(t.strokeStyle=i.style)},drawPoints(t,e,s){void 0===s&&(s=e.length),n.assert(s<=e.length),t.beginPath();for(let i,r,n,o=0;o<s;++o)n=(o+1)%s,i=e[o],r=e[n],t.moveTo(i[0],i[1]),t.lineTo(r[0],r[1]);t.stroke()},drawShapePoly(t,e){return this.drawPoints(t,e.points)},drawCircle(t,e,s,i){t.beginPath(),t.arc(e,s,i,0,r,!0),t.closePath(),t.stroke()},drawShapeCircle(t,e){return this.drawCircle(t,e.pos[0],e.pos[1],e.radius)},drawRect(t,e,s,i,r,n){let o=e,h=s-r;t.save(),t.translate(o,h),t.rotate(n),t.strokeRect(0,0,i,r),t.restore()},drawShapeRect(t,e){return this.drawRect(t,e.pos[0],e.pos[1],e.width,e.height,e.rotation)},drawLine(t,e,s,i,r){t.beginPath(),t.moveTo(e,s),t.lineTo(i,r),t.stroke()},drawShapeLine(t,e){return this.drawLine(t,e.p[0],e.p[1],e.q[0],e.q[1])}}}"object"==typeof module&&module.exports?module.exports=e(require("./core"),require("./math"),require("./matrix")):t["io/czlab/mcfud/gfx"]=e}(this),function(t){"use strict";const[e,s,i]=[1,0,-1];function r(r,n,o,h){r||(r=t["io/czlab/mcfud/core"]()),n||(n=t["io/czlab/mcfud/math"]()),o||(o=t["io/czlab/mcfud/vec2"]()),h||(h=t["io/czlab/mcfud/matrix"]());const l=Math.floor,a=Math.abs,{is:c,u:u}=r;function d(t){const e=t.length,s=u.assert(e<=36)&&u.fill(36);let i=0,r=t[0][0];for(let s,n=1;n<e;++n)s=t[n][0],s>r?(r=s,i=n):u.feq(s,r)&&t[n][1]<t[i][1]&&(i=n);let n=0,h=i;for(;;){s[n]=h;let r=0,l=s[n];for(let s,i,n,a=1;a<e;++a)r!==h?(s=o.sub(t[r],t[l]),i=o.sub(t[a],t[l]),n=o.cross(s,i),n<0&&(r=a),u.feq0(n)&&o.len2(i)>o.len2(s)&&(r=a)):r=a;if(h=r,++n,r===i)break}const l=[];for(let e=0;e<n;++e)l.push(o.clone(t[s[e]]));return l}class f{constructor(t,e,s,i){switch(arguments.length){case 2:this.pos=o.vec(),this.width=t,this.height=e;break;case 4:this.pos=o.vec(t,e),this.width=s,this.height=i;break;default:throw"Error: bad input to Rect()"}}}class g{constructor(t,e){this.width=t,this.height=e}half(){return new g(l(this.width/2),l(this.height/2))}}class p{constructor(t,e,s,i){this.p=o.vec(t,e),this.q=o.vec(s,i)}}class m{constructor(t,e){this.calcPoints=null,this.normals=null,this.edges=null,this.points=null,this.orient=0,this.pos=o.vec(),this.setPos(t,e)}setPos(t=0,e=0){return o.set(this.pos,t,e),this}set(t){return this.calcPoints=this.calcPoints||[],this.normals=this.normals||[],this.edges=this.edges||[],this.calcPoints.length=0,this.normals.length=0,this.edges.length=0,this.points=u.assert(t.length>2)&&d(t),u.doseq(this.points,t=>{this.calcPoints.push(o.vec()),this.edges.push(o.vec()),this.normals.push(o.vec())}),this._recalc()}setOrient(t){return this.orient=t,this._recalc()}translate(t,e){return u.doseq(this.points,s=>{s[0]+=t,s[1]+=e}),this._recalc()}_recalc(){if(this.points){let t,e,s;u.doseq(this.points,(t,e)=>{o.copy(this.calcPoints[e],t),u.feq0(this.orient)||o.rot$(this.calcPoints[e],this.orient)}),u.doseq(this.points,(i,r)=>{t=(r+1)%this.calcPoints.length,e=this.calcPoints[r],s=this.calcPoints[t],this.edges[r]=o.sub(s,e),this.normals[r]=o.unit(o.normal(this.edges[r]))})}return this}static translateCalcPoints(t){return o.translate(t.pos,t.calcPoints)}}class y{constructor(t,e){this.overlapN=o.vec(),this.overlapV=o.vec(),this.A=t,this.B=e,this.clear()}swap(){let t=new y,e=this.AInB,s=this.BInA,i=this.A;return t.overlap=this.overlap,t.A=this.B,t.B=i,t.AInB=s,t.BInA=e,t.overlapN=o.flip(this.overlapN),t.overlapV=o.flip(this.overlapV),t}clear(){return this.overlap=1/0,this.AInB=!0,this.BInA=!0,this}}function w(t,e){let s=1/0,i=-1/0;for(let r,n=0;n<t.length;++n)r=o.dot(t[n],e),r<s&&(s=r),r>i&&(i=r);return[s,i]}function _(t,r){let n=o.len2(t),h=o.dot(r,t);return h<0?e:h>n?i:s}function v(t,e,s,i,r,n){let[h,l]=w(e,r),[a,c]=w(i,r),u=o.vecAB(t,s),d=o.dot(u,r);if(a+=d,c+=d,h>c||a>l)return!0;if(n){let t=0;if(h<a)if(n.AInB=!1,l<c)t=l-a,n.BInA=!1;else{let[e,s]=[l-a,c-h];t=e<s?e:-s}else if(n.BInA=!1,l>c)t=h-c,n.AInB=!1;else{let[e,s]=[l-a,c-h];t=e<s?e:-s}let e=Math.abs(t);e<n.overlap&&(n.overlap=e,o.copy(n.overlapN,r),t<0&&o.flip$(n.overlapN))}}new y,x=new f(0,0,1,1),new m(x.pos[0],x.pos[1]).set([o.vec(x.width,0),o.vec(x.width,x.height),o.vec(0,x.height),o.vec()]);var x;function k(t,e,s){let i=o.vecAB(t.pos,e.pos),r=t.radius+e.radius,n=r*r,h=o.len2(i),l=!(h>n);if(l&&s){let n=Math.sqrt(h);s.A=t,s.B=e,s.overlap=r-n,o.copy(s.overlapN,o.unit$(i)),o.copy(s.overlapV,o.mul(i,s.overlap)),s.AInB=t.radius<=e.radius&&n<=e.radius-t.radius,s.BInA=e.radius<=t.radius&&n<=t.radius-e.radius}return l}function E(t,s,r){let n,h=o.vecAB(t.pos,s.pos),l=s.radius*s.radius,a=t.calcPoints,c=o.vec();for(let u,d,f,g,p=a.length,m=0;m<p;++m){u=m===p-1?0:m+1,d=0===m?p-1:m-1,f=0,g=null,o.copy(c,t.edges[m]),n=o.vecAB(a[m],h),r&&o.len2(n)>l&&(r.AInB=!1);let y=_(c,n);if(y===e){if(o.copy(c,t.edges[d]),y=_(c,o.vecAB(a[d],h)),y===i){let t=o.len(n);if(t>s.radius)return!1;r&&(r.BInA=!1,g=o.unit(n),f=s.radius-t)}}else if(y===i){if(o.copy(c,t.edges[u]),o.sub$(o.copy(n,h),a[u]),y=_(c,n),y===e){let t=o.len(n);if(t>s.radius)return!1;r&&(r.BInA=!1,g=o.unit(n),f=s.radius-t)}}else{let t=o.unit$(o.normal(c)),e=o.dot(n,t),i=Math.abs(e);if(e>0&&i>s.radius)return!1;r&&(g=t,f=s.radius-e,(e>=0||f<2*s.radius)&&(r.BInA=!1))}g&&r&&Math.abs(f)<Math.abs(r.overlap)&&(r.overlap=f,o.copy(r.overlapN,g))}return r&&(r.A=t,r.B=s,o.mul$(o.copy(r.overlapV,r.overlapN),r.overlap)),!0}function N(t,e,s){let i=E(e,t,s);if(i&&s){let t=s.A,e=s.AInB;o.flip$(s.overlapN),o.flip$(s.overlapV),s.A=s.B,s.B=t,s.AInB=s.BInA,s.BInA=e}return i}function b(t,e,s){let i=t.calcPoints,r=e.calcPoints;for(let n=0;n<i.length;++n)if(v(t.pos,i,e.pos,r,t.normals[n],s))return!1;for(let n=0;n<r.length;++n)if(v(t.pos,i,e.pos,r,e.normals[n],s))return!1;if(s){if(0===s.overlap||u.feq0(s.overlap))return!1;s.A=t,s.B=e,o.copy(s.overlapV,s.overlapN),o.mul$(s.overlapV,s.overlap)}return!0}class M{static create(){return new M}constructor(){this.identity()}identity(){return this.m=h.matIdentity(3),this}translate(t,e){return this.m=h.matMult(this.m,h.mat3(1,0,t,0,1,e,0,0,1)),this}scale(t,e){return this.m=h.matMult(this.m,h.mat3(t,0,0,0,e,0,0,0,1)),this}shear(t,e){return this.m=h.matMult(this.m,h.mat3(1,t,0,e,1,0,0,0,1)),this}rotateCCW(t,e,s){let i=Math.sin(t),r=Math.cos(t);return void 0!==e&&void 0!==s?(this.translate(-e,-s),this.rotateCCW(t),this.translate(e,s)):this.m=h.matMult(this.m,h.mat3(r,-i,0,i,r,0,0,0,1)),this}rotateCW(t,e,s){let i=Math.sin(t),r=Math.cos(t);return void 0!==e&&void 0!==s?(this.translate(-e,-s),this.rotateCW(t),this.translate(e,s)):this.m=h.matMult(this.m,h.mat3(r,i,0,-i,r,0,0,0,1)),this}transformXY(t,e){let s=[t,e,1];return h.matVMult(this.m,s).length=2,2}transformPoints(t){let e,s=[0,0,1];t.forEach(t=>{c.vec(t)?(s[0]=t[0],s[1]=t[1]):(s[0]=t.x,s[1]=t.y),e=h.matVMult(this.m,s),c.vec(t)?(t[0]=e[0],t[1]=e[1]):(t.x=e[0],t.y=e[1])})}}return{Rect:f,Area:g,Line:p,Circle:class{constructor(t){this.radius=t,this.orient=0,this.pos=o.vec()}setOrient(t){return this.orient=t,this}setPos(t,e){return o.set(this.pos,t,e),this}},Polygon:m,Manifold:y,C2DMatrix:M,orderVertices:t=>d(t),polyArea(t,e=!1){let s=e?this.orderVertices(t):t,i=0;for(let t,e,r,n=s.length,o=0;o<n;++o)r=(o+1)%n,t=s[o],e=s[r],i+=t[0]*e[1]-e[0]*t[1];return l(a(i)/2)},calcPolygonCenter(t,e=!1){const s=e?this.orderVertices(t):t,i=6*this.polyArea(s);let r=0,n=0;for(let t,e,i,o=0,h=s.length;o<h;++o)i=(o+1)%h,t=s[o],e=s[i],r+=(t[0]+e[0])*(t[0]*e[1]-e[0]*t[1]),n+=(t[1]+e[1])*(t[0]*e[1]-e[0]*t[1]);return o.vec(l(r/i),l(n/i))},getAABB(t,e=null){if(e||(e=t.pos),u.has(t,"radius"))return new f(e[0]-t.radius,e[1]-t.radius,2*t.radius,2*t.radius);{let s=o.translate(e,t.calcPoints),i=s[0][0],r=s[0][1],n=i,h=r;for(let t,e=1;e<s.length;++e)t=s[e],t[0]<i&&(i=t[0]),t[0]>n&&(n=t[0]),t[1]<r&&(r=t[1]),t[1]>h&&(h=t[1]);return new f(i,r,n-i,h-r)}},shiftPoints:(t,e)=>t.map(t=>o.add(t,e)),rotPoints:(t,e,s)=>t.map(t=>o.rot(t,e,s)),calcRectPoints(t,e){const s=l(t/2),i=l(e/2);return[o.vec(s,-i),o.vec(s,i),o.vec(-s,i),o.vec(-s,-i)]},line:(t,e,s,i)=>new p(t,e,s,i),rectEqRect:(t,e)=>t.width===e.width&&t.height===e.height&&t.pos[0]===e.pos[0]&&t.pos[1]===e.pos[1],rectContainsRect:(t,e)=>!(t.pos[0]>=e.pos[0]||t.pos[1]>=e.pos[1]||t.pos[0]+t.width<=e.pos[0]+e.width||t.pos[1]+t.height<=e.pos[1]+e.height),rectGetMaxX:t=>t.pos[0]+t.width,rectGetMidX:t=>t.pos[0]+l(t.width/2),rectGetMinX:t=>t.pos[0],rectGetMaxY:t=>t.pos[1]+t.height,rectGetMidY:t=>t.pos[1]+l(t.height/2),rectGetMinY:t=>t.pos[1],rectContainsPoint(t,e,s){return e>=this.rectGetMinX(t)&&e<=this.rectGetMaxX(t)&&s>=this.rectGetMinY(t)&&s<=this.rectGetMaxY(t)},rectOverlayRect:(t,e)=>!(t.pos[0]+t.width<e.pos[0]||e.pos[0]+e.width<t.pos[0]||t.pos[1]+t.height<e.pos[1]||e.pos[1]+e.height<t.pos[1]),rectUnion(t,e){const s=Math.min(t.pos[0],e.pos[0]),i=Math.min(t.pos[1],e.pos[1]);return new f(s,i,Math.max(t.pos[0]+t.width,e.pos[0]+e.width)-s,Math.max(t.pos[1]+t.height,e.pos[1]+e.height)-i)},rectIntersection(t,e){if(this.rectOverlayRect(t,e)){const s=Math.max(t.pos[0],e.pos[0]),i=Math.max(t.pos[1],e.pos[1]);return new f(s,i,Math.min(t.pos[0]+t.width,e.pos[0]+e.width)-s,Math.min(t.pos[1]+t.height,e.pos[1]+e.height)-i)}},hitTestPointCircle(t,e,s){let i=t-s.pos[0],r=e-s.pos[1];return i*i+r*r<=s.radius*s.radius},hitCircleCircle(t,e){let s=new y;if(k(t,e,s))return s},hitTestCircleCircle:(t,e)=>k(t,e,new y),hitPolygonCircle(t,e){let s=new y;if(E(t,e,s))return s},hitTestPolygonCircle:(t,e)=>E(t,e,new y),hitCirclePolygon(t,e){let s=new y;if(N(t,e,s))return s},hitTestCirclePolygon:(t,e)=>N(t,e,new y),hitPolygonPolygon(t,e){let s=new y;if(b(t,e,s))return s},hitTestPolygonPolygon:(t,e)=>b(t,e,new y),hitTestPointInPolygon(t,e,s){let i;for(let r,n,o=s.length,h=0,l=o-1;h<o;)r=s[h],n=s[l],r[1]>e!=n[1]>e&&t<(n[0]-r[0])*(e-r[1])/(n[1]-r[1])+r[0]&&(i=!i),l=h,++h;return i},hitTestPointPolygon(t,e,s){return this.hitTestPointInPolygon(t,e,o.translate(s.pos,s.calcPoints))},hitTestLinePolygon(t,e,s){let i=m.translateCalcPoints(s);for(let s=0,r=0;s<i.length;++s){r=s+1,r==i.length&&(r=0);let[n,o]=this.lineIntersect2D(t,e,i[s],i[r]);if(n)return[n,o]}return[!1]},lineIntersect2D(t,e,s,i){let r,n,o=t[0],h=t[1],l=e[0],a=e[1],c=s[0],d=s[1],f=i[0],g=i[1],p=(o-l)*(d-g)-(h-a)*(c-f);return u.feq0(p)?[!1]:(r=(o-c)*(d-g)-(h-d)*(c-f),r/=p,n=(o-c)*(h-a)-(h-d)*(o-l),n/=p,0<=r&&r<=1&&0<=n&&n<=1?[!0,r,[o+r*(l-o),h+r*(a-h)]]:[!1])},lineIntersection2D(t,e,s,i){if(t[1]>i[1]&&e[1]>i[1]&&t[1]>s[1]&&e[1]>s[1]||e[1]<s[1]&&t[1]<s[1]&&e[1]<i[1]&&t[1]<i[1]||t[0]>i[0]&&e[0]>i[0]&&t[0]>s[0]&&e[0]>s[0]||e[0]<s[0]&&t[0]<s[0]&&e[0]<i[0]&&t[0]<i[0])return[!1,0];let r=(t[1]-s[1])*(i[0]-s[0])-(t[0]-s[0])*(i[1]-s[1]),n=(e[0]-t[0])*(i[1]-s[1])-(e[1]-t[1])*(i[0]-s[0]),o=(t[1]-s[1])*(e[0]-t[0])-(t[0]-s[0])*(e[1]-t[1]),h=(e[0]-t[0])*(i[1]-s[1])-(e[1]-t[1])*(i[0]-s[0]),l=r*n,a=o*h;return l>0&&l<n*n&&a>0&&a<h*h?[!0,r/n]:[!1,0]}}}"object"==typeof module&&module.exports?module.exports=r(require("./core"),require("./math"),require("./vec2"),require("./matrix")):t["io/czlab/mcfud/geo2d"]=r}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const s=Math.floor,{u:i,is:r}=e;return{spatialGrid:(t=320,e=320)=>function(t,e){const n=new Map;return{searchAndExec(t,e){let s,i=t.getSpatial();for(let r,o,h=i.y1;h<=i.y2;++h)if(o=n.get(h))for(let n,l,a=i.x1;a<=i.x2;++a)if(r=o.get(a))for(n=r.values(),l=n.next();!l.done;){if(t!==l.value&&(s=e(t,l.value))){a=h=1/0;break}s=null,l=n.next()}return s},search(t,e=!1){let s,i,r=[],o=t.getSpatial();for(let h=o.y1;h<=o.y2;++h)if(i=n.get(h))for(let n=o.x1;n<=o.x2;++n)(s=i.get(n))&&s.forEach(s=>{(s!==t||e)&&r.push(s)});return r},engrid(i,r){if(!i)return;let n=i.getBBox(),o=i.getSpatial(),h=s(n.x1/t),l=s(n.y1/e),a=s(n.x2/t),c=s(n.y2/e);return o.x1===h&&o.x2===a&&o.y1===l&&o.y2===c||(this.degrid(i),o.x1=h,o.x2=a,o.y1=l,o.y2=c,r||this._register(i)),i},reset(){n.clear()},_register(t){let e=t.getSpatial();if(r.num(e.x1))for(let s,r,o=e.y1;o<=e.y2;++o){n.has(o)||n.set(o,new Map),r=n.get(o);for(let n=e.x1;n<=e.x2;++n)r.has(n)||r.set(n,new Map),s=r.get(n),i.assoc(s,t.getGuid(),t)}},degrid(t){if(t){let e=t.getSpatial();if(r.num(e.x1))for(let s,r,o=e.y1;o<=e.y2;++o)if(r=n.get(o))for(let n=e.x1;n<=e.x2;++n)(s=r.get(n))&&i.dissoc(s,t.getGuid())}}}}(t,e)}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/spatial"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const s=Math.floor,{u:i}=e;function r(t,e,o,h,l,a,c){let u=null,d=[],f=o<h,g=s((t+e)/2),p=s((o+h)/2);function m(t){let e,s,i,r;if(t.getBBox){let{x1:n,x2:o,y1:h,y2:l}=t.getBBox();e=n,s=h,i=o-n,r=f?l-h:h-l}else void 0!==t.x&&void 0!==t.y&&void 0!==t.width&&void 0!==t.height&&(e=t.x,s=t.y,i=t.width,r=t.height);let n=[],o=e<g,h=e+i>g,l=f?s+r>p:s<p;return(f?s<p:s+r>p)&&(o&&n.push(3),h&&n.push(0)),l&&(o&&n.push(2),h&&n.push(1)),n}function y(){i.assert(null===u),u=[r(g,e,o,p,l,a,c+1),r(g,e,p,h,l,a,c+1),r(t,g,p,h,l,a,c+1),r(t,g,o,p,l,a,c+1)]}const w={x1:t,x2:e,y1:o,y2:h};return{boundingBox:()=>w,subTrees:()=>u,dbg:t=>t(d,u,l,a,c),insert:function(t){for(let e=0;e<arguments.length;++e)t=arguments[e],u?m(t).forEach(e=>u[e].insert(t)):(d.push(t),d.length>l&&c<a&&(y(),d.forEach(t=>m(t).forEach(e=>u[e].insert(t))),d.length=0))},remove(t){u?u.forEach(e=>e.remove(t)):i.disj(d,t)},isLeaf:()=>null===u?-1:d.length,prune(){if(u){let t=0,e=0;for(let s,i=0;i<u.length;++i)s=u[i],s.prune(),n=s.isLeaf(),n>=0&&(++t,e+=n);t===u.length&&e<l&&(i.assert(0===d.length,"quadtree wanted zero items"),u.forEach(t=>t._swap(d)),u=null)}},_swap(t){d.forEach(e=>t.push(e)),d.length=0},reset(){d.length=0,u&&u.forEach(t=>t.reset()),u=null},searchAndExec(t,e,s){let i;if(u){let r=m(t);for(let n=0;n<r.length&&(i=u[r[n]].searchAndExec(t,e,s),!i);++n);}else for(let r,n=0;n<d.length&&(r=d[n],s&&r===t||!(i=e(r,t)));++n);return i},search(t,e){const s=new Map,i=[];return e&&s.set(t,null),u&&m(t).forEach(e=>{u[e].search(t).forEach(t=>{s.has(t)||(s.set(t,null),i.push(t))})}),d.forEach(t=>{s.has(t)||(s.set(t,null),i.push(t))}),s.clear(),i}}}return{quadtree(t,e=12,s=5){const{left:i,right:n,top:o,bottom:h}=t;return r(i,n,o,h,e,s,0)}}}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/qtree"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const{u:s}=e;class i{constructor(t,e){this.lastBestMove=null,this.state=null,this.other=e,this.cur=t}clone(t){const e=new i;return e.state=t(this.state),e.lastBestMove=this.lastBestMove,e.other=this.other,e.cur=this.cur,e}}function r(t,e,s,i){return t.evalScore(e,s,i)*(1+.001*s)}function n(t,e,i,o,h,l){if(0===i||t.isOver(e))return{depth:i,value:r(t,e,i,o)};let a=e,c=t.getStateCopier(),u=s.shuffle(t.getNextMoves(e));for(let r,d,f=0;f<u.length;++f)if(d=u[f],t.undoMove||(s.assert(c,"Missing state copier!"),e=a.clone(c)),t.makeMove(e,d),r=n(t,e,i-1,o,{value:-l.value,move:l.move},{value:-h.value,move:h.move}),t.undoMove&&t.unmakeMove(e,d),r.value=-r.value,r.move=d,r.value>h.value&&(h={value:r.value,move:d,depth:r.depth}),h.value>=l.value)return l;return JSON.parse(JSON.stringify(h))}function o(t,e,i,n,h,l){if(0===i||t.isOver(e))return[r(t,e,i,n),null];let a=s.shuffle(t.getNextMoves(e)),c=t.getStateCopier(),u=e,d=-1/0,f=a[0];i===n&&(u.lastBestMove=f);for(let r,g,p=0;p<a.length&&(t.undoMove||(s.assert(c,"Missing state copier!"),e=u.clone(c)),g=a[p],t.makeMove(e,g),r=-o(t,e,i-1,n,-l,-h)[0],t.undoMove&&t.unmakeMove(e,g),d<r&&(d=r,f=g),!(h<r&&(h=r,i===n&&(u.lastBestMove=g),h>=l)));++p);return[d,u.lastBestMove]}const h={algo:"negamax",GFrame:i,GameBoard:class{constructor(){}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t){}isStalemate(t){}isOver(t){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}takeGFrame(){}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let i=this.getFirstMove();return s.nichts(i)&&(i=h.evalNegaMax(this)),i}},XXevalNegaMax(t){const e=t.takeGFrame(),i=t.depth;let r,n;return[r,n]=o(t,e,i,i,-1/0,1/0),s.nichts(n)&&console.log(`evalNegaMax: score=${r}, pos= ${n}, lastBestMove=${n}`),n},evalNegaMax(t){const e=t.takeGFrame(),i=t.depth;let{value:r,move:o}=n(t,e,i,i,{value:-1/0},{value:1/0});return s.nichts(o)&&console.log(`evalNegaMax: score= ${r}, pos= ${o}`),o}};return h}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/negamax"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const{u:s}=e;class i{constructor(t,e){this.cur=t,this.state=null,this.other=e}clone(t){const e=new i;return e.state=t(this.state),e.other=this.other,e.cur=this.cur,e}}function r(t,e,s,i){return t.evalScore(e,s,i)}function n(t,e,i,o,h,l,a){if(0===i||t.isOver(e))return[r(t,e,i,o),null];let c=e,u=t.getStateCopier(),d=s.shuffle(t.getNextMoves(e));if(a){let r,f,g=d[0],p=-1/0;for(let m=0;m<d.length&&(t.undoMove||(s.assert(u,"Missing state copier!"),e=c.clone(u)),f=d[m],t.makeMove(e,f),r=n(t,e,i-1,o,h,l,!a)[0],t.undoMove&&t.unmakeMove(e,f),h=Math.max(r,h),r>p&&(p=r,g=f),!(l<=h));++m);return[p,g]}{let r,f,g=d[0],p=1/0;for(let m=0;m<d.length&&(t.undoMove||(s.assert(u,"Missing state copier!"),e=c.clone(u)),f=d[m],t.makeMove(e,f),r=n(t,e,i-1,o,h,l,!a)[0],t.undoMove&&t.unmakeMove(e,f),l=Math.min(r,l),r<p&&(p=r,g=f),!(l<=h));++m);return[p,g]}}const o={algo:"minimax",GFrame:i,GameBoard:class{constructor(){this.aiActor=null}getStateCopier(){}getFirstMove(t){}getNextMoves(t){}evalScore(t,e,s){}isStalemate(t){}isOver(t,e){}unmakeMove(t,e){if(!this.undoMove)throw Error("Need Implementation");this.switchPlayer(t),this.undoMove(t,e)}makeMove(t,e){if(!this.doMove)throw Error("Need Implementation!");this.doMove(t,e),this.switchPlayer(t)}takeGFrame(){}switchPlayer(t){let e=t.cur;t.cur=t.other,t.other=e}getOtherPlayer(t){return t===this.actors[1]?this.actors[2]:t===this.actors[2]?this.actors[1]:void 0}getPlayer(){return this.actors[0]}run(t,e){this.getAlgoActor=()=>e,this.syncState(t,e);let i=this.getFirstMove();return s.nichts(i)&&(i=o.evalMiniMax(this)),i}},evalMiniMax(t){const e=t.takeGFrame(),i=t.depth;let r,o;return[r,o]=n(t,e,i,i,-1/0,1/0,!0),s.nichts(o)&&console.log(`evalMiniMax: score=${r}, pos= ${o}`),o}};return o}"object"==typeof module&&module.exports?module.exports=e(require("./core")):t["io/czlab/mcfud/minimax"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const s=(t,e)=>t<e?-1:t>e?1:0,i=Math.floor,{is:r,u:n}=e;function o(t,e=" ",s=""){for(;t.hasNext();)s+=`${t.next()}${e}`;return s}function h(t){return n.assert(r.num(t)||r.str(t),"expected number or string")}class l{constructor(t){this.current=t}hasNext(){return n.echt(this.current)}remove(){throw Error("Unsupported")}next(){if(!this.hasNext())throw Error("NoSuchElementException");let t=this.current.item;return this.current=this.current.next,t}}function a(t,e=null){return{item:t,next:e}}class c{constructor(){this.first=null,this.n=0}clone(){let t,e=new c,s=this.first;for(;s;)t?(t.next=a(s.item),t=t.next):e.first=t=a(s.item),e.n+=1,s=s.next;return e}isEmpty(){return n.nichts(this.first)}size(){return this.n}add(t){this.first=a(t,this.first),this.n+=1}iter(){return new l(this.first)}static test(){let t=new c;"to be or not to - be - - that - - - is".split(" ").forEach(e=>t.add(e)),console.log("size of bag = "+t.size()),console.log(o(t.iter()));let e=t.clone();console.log("size of cloned = "+e.size()),console.log(o(e.iter()))}}class u{constructor(){this.first=null,this.n=0}clone(){let t,e=new u,s=this.first;for(;s;)t?(t.next=a(s.item),t=t.next):e.first=t=a(s.item),e.n+=1,s=s.next;return e}isEmpty(){return n.nichts(this.first)}size(){return this.n}push(t){this.first=a(t,this.first),this.n+=1}pop(){if(this.isEmpty())throw Error("Stack underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,t}peek(){if(this.isEmpty())throw Error("Stack underflow");return this.first.item}toString(){return o(this.iter())}iter(){return new l(this.first)}static test(){let t=new u;"to be or not to - be - - that - - - is".split(" ").forEach(e=>{"-"!=e?t.push(e):t.isEmpty()||console.log("(-)"+t.pop()+" ")}),console.log("("+t.size()+" left on stack)");let e=t.clone();console.log("cloned= "+o(e.iter())),console.log("("+e.size()+" left on stack)")}}class d{constructor(){this.first=null,this.last=null,this.n=0}clone(){let t=new d,e=this.first;for(;e;)t.enqueue(e.item),e=e.next;return t}isEmpty(){return n.nichts(this.first)}size(){return this.n}peek(){if(this.isEmpty())throw Error("Queue underflow");return this.first.item}enqueue(t){let e=this.last;this.last=a(t),this.isEmpty()?this.first=this.last:e.next=this.last,this.n+=1}dequeue(){if(this.isEmpty())throw Error("Queue underflow");let t=this.first.item;return this.first=this.first.next,this.n-=1,this.isEmpty()&&(this.last=null),t}toString(){return o(this.iter())}iter(){return new l(this.first)}static test(){let t=new d;"to be or not to - be - - that - - - is".split(/\s+/).forEach(e=>{"-"!=e?t.enqueue(e):t.isEmpty()||console.log(t.dequeue()+" ")}),console.log("("+t.size()+" left on queue)");let e=t.clone();console.log("cloned= "+o(e.iter())),console.log("("+e.size()+" left on queue)")}}class f{constructor(t){this.compare=t||s,this.root=null,this.n=0}size(){return this.n}contains(t){return void 0!==this.get(t)}get(t){const e=(t,s,i)=>{if(s){let r=this.compare(t,s.key);i=r<0?e(t,s.left):r>0?e(t,s.right):s.value}return i};if(h(t)&&this.n>0)return e(t,this.root)}set(t,e){const s=(t,e,i)=>{if(!i)return this.n+=1,{key:t,value:e,left:null,right:null};let r=this.compare(t,i.key);return r<0?i.left=s(t,e,i.left):r>0?i.right=s(t,e,i.right):i.value=e,i};h(t)&&void 0!==e&&(this.root=s(t,e,this.root))}_getMaxNode(t){for(;null!==t&&null!==t.right;)t=t.right;return t}_getMaxKey(){let t=this._getMaxNode(this.root);if(t)return t.key}_getMinNode(t){for(;null!==t&&null!==t.left;)t=t.left;return t}_getMinKey(){let t=this._getMinNode(this.root);if(t)return t.key}remove(t){const e=(t,s)=>{if(s){let i,r,n,o=this.compare(t,s.key);o<0?s.left=e(t,s.left):o>0?s.right=e(t,s.right):s.left&&s.right?(n=this._getMaxNode(s.left),i=n.key,r=n.value,n.value=s.value,n.key=s.key,s.key=i,s.value=r,s.left=e(t,s.left)):s.left?(s=s.left,this.n-=1):s.right?(s=s.right,this.n-=1):(s=null,this.n-=1)}return s};h(t)&&(this.root=e(t,this.root))}keys(){let t=new d;return this.forEach((e,s)=>t.enqueue(s)),t.iter()}firstKey(){let t;try{this.forEach((e,s)=>{throw t=s,Error("????")})}catch(t){}return t}lastKey(){let t;return this.forEach((e,s)=>{t=s}),t}forEach(t,e){function s(t,e){return e&&e.apply(t,Array.prototype.slice.call(arguments,2))}!function t(e,i,r,n){if(!e)return s(r,n);t(e.left,i,r,(function(){s(r,i,e.value,e.key),t(e.right,i,r,(function(){s(r,n)}))}))}(this.root,t,e)}static test(){let t=new f;t.set(3,"3"),t.set(2,"2"),t.set(7,"7"),t.set(1,"1"),console.log("firstKey= "+t.firstKey()),console.log("lastKey= "+t.lastKey()),console.log(o(t.keys())),console.log("k= "+t.get(3)),console.log("has 2 = "+t.contains(2)),console.log("has size = "+t.size()),t.remove(1),console.log("has size = "+t.size()),console.log(o(t.keys())),console.log("k= "+t.get(2))}}class g{constructor(){this.st=new f}get(t){if(n.nichts(t))throw Error("calls get() with null key");return this.st.get(t)}put(t,e){if(n.nichts(t))throw Error("calls put() with null key");void 0===e?this.st.remove(t):this.st.set(t,e)}remove(t){if(n.nichts(t))throw Error("calls remove() with null key");this.st.remove(t)}contains(t){if(n.nichts(t))throw Error("calls contains() with null key");return this.st.contains(t)}size(){return this.st.size()}isEmpty(){return 0==this.size()}keys(){return this.st.keys()}min(){if(this.isEmpty())throw Error("calls min() with empty symbol table");return this.st.firstKey()}max(){if(this.isEmpty())throw Error("calls max() with empty symbol table");return this.st.lastKey()}ceiling(t){if(n.nichts(t))throw Error("argument to ceiling() is null");let e,s,i=this.st.keys();for(;i.hasNext();)if(s=i.next(),s==t||s>t){e=s;break}if(void 0===e)throw Error("argument to ceiling() is too large");return e}floor(t){if(n.nichts(t))throw Error("argument to floor() is null");let e,s,i=this.st.keys();for(;i.hasNext();)s=i.next(),(s==t||s<t)&&(e=s);if(void 0===e)throw Error("argument to floor() is too small");return e}static test(){let t=new g;t.put("a",1),t.put("g",9),t.put("c",3),t.put("j",10),t.put("z",26),t.put("x",24),console.log("isEmpty= "+t.isEmpty()),console.log("size= "+t.size()),console.log("get-c= "+t.get("c")),console.log("contains z= "+t.contains("z")),console.log("contains m= "+t.contains("m")),console.log(o(t.keys())),console.log("ceil w= "+t.ceiling("w")),console.log("floor k= "+t.floor("k")),console.log("min = "+t.min()),console.log("max = "+t.max()),t.remove("x"),console.log(o(t.keys()))}}class p{static M=4;Node(t){return{m:t,children:new Array(p.M)}}Entry(t,e,s=null){return{key:t,val:e,next:s}}constructor(t){this.root=this.Node(0),this.compare=t,this._height=0,this.n=0}isEmpty(){return 0==this.size()}size(){return this.n}height(){return this._height}get(t){if(n.nichts(t))throw Error("argument to get() is null");return this._search(this.root,t,this._height)}_search(t,e,s){let i=t.children;if(0==s){for(let s=0;s<t.m;++s)if(0==this.compare(e,i[s].key))return i[s].val}else for(let r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,i[r+1].key)<0)return this._search(i[r].next,e,s-1)}put(t,e){if(n.nichts(t))throw Error("argument key to put() is null");let s,i=this._insert(this.root,t,e,this._height);this.n+=1,i&&(s=this.Node(2),s.children[0]=this.Entry(this.root.children[0].key,null,this.root),s.children[1]=this.Entry(i.children[0].key,null,i),this.root=s,this._height+=1)}_insert(t,e,s,i){let r,n=this.Entry(e,s);if(0==i)for(r=0;r<t.m&&!(this.compare(e,t.children[r].key)<0);++r);else for(r=0;r<t.m;++r)if(r+1==t.m||this.compare(e,t.children[r+1].key)<0){let o=this._insert(t.children[r++].next,e,s,i-1);if(!o)return null;n.key=o.children[0].key,n.val=null,n.next=o;break}for(let e=t.m;e>r;--e)t.children[e]=t.children[e-1];if(t.children[r]=n,t.m++,t.m>=p.M)return this._split(t)}_split(t){let e=i(p.M/2),s=this.Node(e);t.m=e;for(let i=0;i<e;++i)s.children[i]=t.children[e+i];return s}toString(){return function t(e,s,i){let r="",n=e.children;if(0==s)for(let t=0;t<e.m;++t)r+=`${i}${n[t].key} ${n[t].val}\n`;else for(let o=0;o<e.m;++o)o>0&&(r+=`${i}(${n[o].key})\n`),r+=t(n[o].next,s-1,i+"     ");return r}(this.root,this._height,"")+"\n"}static test(){let t=new p(s);t.put("www.cs.princeton.edu","128.112.136.12"),t.put("www.cs.princeton.edu","128.112.136.11"),t.put("www.princeton.edu","128.112.128.15"),t.put("www.yale.edu","130.132.143.21"),t.put("www.simpsons.com","209.052.165.60"),t.put("www.apple.com","17.112.152.32"),t.put("www.amazon.com","207.171.182.16"),t.put("www.ebay.com","66.135.192.87"),t.put("www.cnn.com","64.236.16.20"),t.put("www.google.com","216.239.41.99"),t.put("www.nytimes.com","199.239.136.200"),t.put("www.microsoft.com","207.126.99.140"),t.put("www.dell.com","143.166.224.230"),t.put("www.slashdot.org","66.35.250.151"),t.put("www.espn.com","199.181.135.201"),t.put("www.weather.com","63.111.66.11"),t.put("www.yahoo.com","216.109.118.65"),console.log("cs.princeton.edu:  "+t.get("www.cs.princeton.edu")),console.log("hardvardsucks.com: "+t.get("www.harvardsucks.com")),console.log("simpsons.com:      "+t.get("www.simpsons.com")),console.log("apple.com:         "+t.get("www.apple.com")),console.log("ebay.com:          "+t.get("www.ebay.com")),console.log("dell.com:          "+t.get("www.dell.com")),console.log(""),console.log("size:    "+t.size()),console.log("height:  "+t.height()),console.log(t.toString()),console.log("")}}class m{constructor(t){this.d=t,this.st=new g}put(t,e){if(t<0||t>=this.d)throw Error("Illegal index");n.feq0(e)?this.st.remove(t):this.st.put(t,e)}get(t){if(t<0||t>=this.d)throw Error("Illegal index");return this.st.contains(t)?this.st.get(t):0}nnz(){return this.st.size()}dimension(){return this.d}dot(t){if(n.assert(t instanceof m,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e,s=0,i=(this.st.size()<=t.st.size()?this:t).st.keys();for(;i.hasNext();)e=i.next(),t.st.contains(e)&&(s+=this.get(e)*t.get(e));return s}dotWith(t){let e=0;for(let s,i=this.st.keys();i.hasNext();)s=i.next(),e+=t[s]*this.get(s);return e}magnitude(){return Math.sqrt(this.dot(this))}scale(t){let e=new m(this.d);for(let s,i=this.st.keys();i.hasNext();)s=i.next(),e.put(s,t*this.get(s));return e}plus(t){if(n.assert(t instanceof m,"expected SparseVector data"),this.d!=t.d)throw Error("Vector lengths disagree");let e=new m(this.d);for(let t,s=this.st.keys();s.hasNext();)t=s.next(),e.put(t,this.get(t));for(let s,i=t.st.keys();i.hasNext();)s=i.next(),e.put(s,t.get(s)+e.get(s));return e}toString(){let t="";for(let e,s=this.st.keys();s.hasNext();)e=s.next(),t+=`(${e}, ${this.st.get(e)}) `;return t}static test(){let t=new m(10),e=new m(10);t.put(3,.5),t.put(9,.75),t.put(6,.11),t.put(6,0),e.put(3,.6),e.put(4,.9),console.log("a = "+t.toString()),console.log("b = "+e.toString()),console.log("a dot b = "+t.dot(e)),console.log("a + b   = "+t.plus(e).toString())}}return{BTree:p,Bag:c,Stack:u,Queue:d,ST:g,TreeMap:f,SparseVector:m,Iterator:l,prnIter:o,StdCompare:s}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core")):t["io/czlab/mcfud/algo/basic"]=e}(this),function(t){"use strict";function e(e,s){e||(e=t["io/czlab/mcfud/core"]()),s||(s=t["io/czlab/mcfud/algo/basic"]());const{prnIter:i,Bag:r,Stack:n,Iterator:o,StdCompare:h}=s,l=Math.floor,{is:a,u:c}=e;function u(t,e,s,i,r){c.assert(t>e,"bad resize capacity");let n=new Array(t);for(let t=s;t<i;++t)n[t]=r[t];return n}function d(t,e,s){return s(t,e)<0}function f(t,e,s){const i=t[e];t[e]=t[s],t[s]=i}function g(t){let e="";for(let s=0;s<t.length;++s)e+=t[s]+" ";console.log(e)}class p{static sort(t,e){const s=t.length;for(let i=1;i<s;++i)for(let s=i;s>0&&d(t[s],t[s-1],e);--s)f(t,s,s-1);return t}static sortRange(t,e,s,i){for(let r=e+1;r<s;++r)for(let s=r;s>e&&d(t[s],t[s-1],i);--s)f(t,s,s-1);return t}static indexSort(t,e){const s=t.length,i=c.fill(s,t=>t);for(let r=1;r<s;++r)for(let s=r;s>0&&d(t[i[s]],t[i[s-1]],e);--s)f(i,s,s-1);return i}static test(){let t="SORTEXAMPLE".split("");g(p.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(p.sortRange(t,0,t.length,h)),t="SORTEXAMPLE".split(""),g(p.indexSort(t,h))}}class m{static sort(t,e){let s,i,r,n=t.length;for(let o,h=1;h<n;++h){for(i=0,r=h,o=t[h];i<r;)s=i+l((r-i)/2),d(o,t[s],e)?r=s:i=s+1;for(let e=h;e>i;--e)t[e]=t[e-1];t[i]=o}return t}static test(){let t="SORTEXAMPLE".split("");g(m.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(m.sort(t,h))}}class y{static sort(t,e){let s,i=t.length;for(let r=0;r<i;++r){s=r;for(let n=r+1;n<i;++n)d(t[n],t[s],e)&&(s=n);f(t,r,s)}return t}static test(){let t="SORTEXAMPLE".split("");g(y.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(y.sort(t,h))}}class w{static sort(t,e){let s=t.length,i=1,r=l(s/3);for(;i<r;)i=3*i+1;for(;i>=1;){for(let r=i;r<s;++r)for(let s=r;s>=i&&d(t[s],t[s-i],e);s-=i)f(t,s,s-i);i=l(i/3)}return t}static test(){let t="SORTEXAMPLE".split("");g(w.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(w.sort(t,h))}}function _(t,e,s,i,r,n){if(r<=i);else{let o=i+l((r-i)/2);_(t,e,s,i,o,n),_(t,e,s,o+1,r,n),function(t,e,s,i,r,n,o){for(let t=i;t<=n;++t)s[t]=e[t];let h=i,l=r+1;for(let a=i;a<=n;++a)h>r?e[a]=s[l++]:l>n?e[a]=s[h++]:d(t[s[l]],t[s[h]],o)?e[a]=s[l++]:e[a]=s[h++]}(t,e,s,i,o,r,n)}return t}class v{static sort(t,e){return function t(e,s,i,r,n){if(r<=i);else{let o=i+l((r-i)/2);t(e,s,i,o,n),t(e,s,o+1,r,n),function(t,e,s,i,r,n){for(let i=s;i<=r;++i)e[i]=t[i];let o=s,h=i+1;for(let l=s;l<=r;++l)o>i?t[l]=e[h++]:h>r?t[l]=e[o++]:d(e[h],e[o],n)?t[l]=e[h++]:t[l]=e[o++]}(e,s,i,o,r,n)}return e}(t,new Array(t.length),0,t.length-1,e),t}static indexSort(t,e){let s=t.length,i=c.fill(s,t=>t);return _(t,i,new Array(s),0,s-1,e),i}static test(){let t="SORTEXAMPLE".split("");g(v.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(v.sort(t,h)),t="SORTEXAMPLE".split(""),g(v.indexSort(t,h))}}class x{static sort(t,e){const s=t.length;for(let i,r=0;r<s;++r){i=0;for(let n=s-1;n>r;--n)d(t[n],t[n-1],e)&&(f(t,n,n-1),++i);if(0==i)break}return t}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");x.sort(t,h),g(t)}}function k(t,e,s,i){let r=e,n=t[e],o=s+1;for(;;){for(;d(t[++r],n,i)&&r!=s;);for(;d(n,t[--o],i)&&o!=e;);if(r>=o)break;f(t,r,o)}return f(t,e,o),o}class E{static sort(t,e){return function t(e,s,i,r){if(i<=s);else{let n=k(e,s,i,r);t(e,s,n-1,r),t(e,n+1,i,r)}return e}(t,0,t.length-1,e),t}static select(t,e,s){if(e<0||e>=t.length)throw Error(`index is not between 0 and ${t.length}: ${e}`);let i=0,r=t.length-1;for(;r>i;){let n=k(t,i,r,s);if(n>e)r=n-1;else{if(!(n<e))return t[n];i=n+1}}return t[i]}static test(){let t="bed bug dad yes zoo all bad yet".split(" ");g(E.sort(t,h)),t="SORTEXAMPLE".split(""),g(E.sort(t,h)),c.shuffle(t),t.forEach((e,s)=>console.log(E.select(t,s,h)))}}function N(t,e,s,i){return d(t[e],t[s],i)}class b{Node(t){return{key:t,order:0,prev:null,next:null,child:null}}constructor(t,e){this.compare=t,this.table=new Map,this.head=null,this._min=null,this.n=0,a.vec(e)&&e.forEach(t=>this.insert(t))}isEmpty(){return 0==this.n}size(){return this.n}insert(t){let e=this.Node(t);this.n+=1,this.head=this._insertNode(e,this.head),this._min=this._min?this._greater(this._min.key,t)?this.head:this._min:this.head}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cut(this._min,this.head);let t=this._min.child,e=this._min.key;return this._min.key=null,t&&(this.head=this._meld(this.head,t),this._min.child=null),this.n-=1,this.isEmpty()?this._min=null:this._consolidate(),e}union(t){return this.head=this._meld(this.head,t.head),this._min=this._greater(this._min.key,t._min.key)?t._min:this._min,this.n=this.n+t.n,this}_greater(t,e){return!c.nichts(t)&&(!!c.nichts(e)||this.compare(t,e)>0)}_link(t,e){e.child=this._insertNode(t,e.child),e.order+=1}_consolidate(){this.table.clear();let t=this.head,e=null,s=null,i=0;this._min=this.head;do{for(e=t,t=t.next,s=this.table.get(e.order);s;)this.table.delete(e.order),this._greater(e.key,s.key)?(this._link(e,s),e=s):this._link(s,e),s=this.table.get(e.order);this.table.set(e.order,e),e.order>i&&(i=e.order)}while(t!==this.head);this.head=null,this.table.forEach(t=>{t&&(this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head))})}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cut(t,e){if(t.next===t)return t.next=null,t.prev=null,null;{t.next.prev=t.prev,t.prev.next=t.next;let s=t.next;return t.next=null,t.prev=null,e===t?s:e}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new b(this.compare),e=s=>{if(!s)return;let i=s;do{t.insert(i.key),e(i.child),i=i.next}while(i!==s)};return e(this.head),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new b(h);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ",e.isEmpty(),console.log(t),console.log("min= "+e.min()),console.log(i(e.iter())),console.log("("+e.size()+" left on pq)");let s=new b(h);"ZTAK".split("").forEach(t=>s.insert(t)),s=s.union(e),console.log(i(s.iter()))}}class M{Node(t){return{key:t,order:0,index:0,prev:null,next:null,parent:null,child:null,mark:!1}}constructor(t,e){if(t<0)throw Error("Cannot create a priority queue of negative size");this.maxN=t,this.n=0,this.head=null,this._min=null,this.compare=e,this.table=new Map,this.nodes=new Array(t)}isEmpty(){return 0==this.n}contains(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");return c.echt(this.nodes[t])}size(){return this.n}insert(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(this.contains(t))throw Error("Specified index is already in the queue");let s=this.Node(e);s.index=t,this.nodes[t]=s,this.n+=1,this.head=this._insertNode(s,this.head),this._min=this._min?this._greater(this._min.key,e)?this.head:this._min:this.head}minIndex(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.index}min(){if(this.isEmpty())throw Error("Priority queue is empty");return this._min.key}delMin(){if(this.isEmpty())throw Error("Priority queue is empty");this.head=this._cutNode(this._min,this.head);let t=this._min.child,e=this._min.index;if(this._min.key=null,t){do{t.parent=null,t=t.next}while(t!==this._min.child);this.head=this._meld(this.head,t),this._min.child=null}return this.n-=1,this.isEmpty()?this._min=null:this._consolidate(),this.nodes[e]=null,e}keyOf(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");return this.nodes[t].key}changeKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");this._greater(e,this.nodes[t].key)?this.increaseKey(t,e):this.decreaseKey(t,e)}decreaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(e,this.nodes[t].key))throw Error("Calling with this argument would not decrease the key");let s=this.nodes[t];s.key=e,this._greater(this._min.key,e)&&(this._min=s),s.parent&&this._greater(s.parent.key,e)&&this._cut(t)}increaseKey(t,e){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");if(this._greater(this.nodes[t].key,e))throw Error("Calling with this argument would not increase the key");this.delete(t),this.insert(t,e)}delete(t){if(t<0||t>=this.maxN)throw Error("IllegalArgumentException");if(!this.contains(t))throw Error("Specified index is not in the queue");let e=this.nodes[t];if(e.key=null,e.parent&&this._cut(t),this.head=this._cutNode(e,this.head),e.child){let t=e.child;e.child=null,e=t;do{t.parent=null,t=t.next}while(t!==e);this.head=this._meld(this.head,t)}this.isEmpty()?this._min=null:this._consolidate(),this.nodes[t]=null,this.n-=1}_greater(t,e){return!c.nichts(t)&&(!!c.nichts(e)||this.compare(t,e)>0)}_link(t,e){t.parent=e,e.child=this._insertNode(t,e.child),e.order+=1}_cut(t){let e=this.nodes[t],s=e.parent;s.child=this._cutNode(e,s.child),e.parent=null,s.order-=1,this.head=this._insertNode(e,this.head),s.mark=!s.mark,!s.mark&&s.parent&&this._cut(s.index)}_consolidate(){let t=null,e=null,s=0,i=this.head;this.table.clear(),this._min=this.head;do{for(t=i,i=i.next,e=this.table.get(t.order);e;)this.table.delete(t.order),this._greater(t.key,e.key)?(this._link(t,e),t=e):this._link(e,t),e=this.table.get(t.order);this.table.set(t.order,t),t.order>s&&(s=t.order)}while(i!==this.head);this.head=null,this.table.forEach(t=>{this._min=this._greater(this._min.key,t.key)?t:this._min,this.head=this._insertNode(t,this.head)})}_insertNode(t,e){return e?(e.prev.next=t,t.next=e,t.prev=e.prev,e.prev=t):(t.prev=t,t.next=t),t}_cutNode(t,e){if(t.next===t)return t.next=null,t.prev=null,null;{t.next.prev=t.prev,t.prev.next=t.next;let s=t.next;return t.next=null,t.prev=null,e===t?s:e}}_meld(t,e){return t?e?(t.prev.next=e.next,e.next.prev=t.prev,t.prev=e,e.next=t,t):t:e}iter(){let t=new M(this.maxN,this.compare);return this.nodes.forEach(e=>{e&&t.insert(e.index,e.key)}),{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new M(t.length,h);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(console.log("min= "+e.min()),console.log("minindex= "+e.minIndex()),console.log("size= "+e.size()),console.log("contains(3)="+e.contains(3)),console.log("keyOf(3)="+e.keyOf(3)),e.changeKey(3,"bbbb");!e.isEmpty();){let t=e.minIndex();console.log(t+" "+e.keyOf(t)),e.delMin()}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class T{constructor(t,e){if(this.comparator=t,this.n=0,a.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=l(this.n/2);t>=1;--t)this._sink(t,this)}else this.pq=new Array(a.num(e)?e:2);c.assert(this._isMinHeap(),"not min heap")}isEmpty(){return 0==this.n}size(){return this.n}min(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=u(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.pq[++this.n]=t,this._swim(this.n),c.assert(this._isMinHeap(),"not min heap-insert")}delMin(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return f(this.pq,1,this.n--),this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==l((this.pq.length-1)/4)&&(this.pq=u(l(this.pq.length/2),this.n,1,this.n+1,this.pq)),t}_swim(t){for(;t>1&&this._greater(l(t/2),t);)f(this.pq,t,l(t/2)),t=l(t/2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&e++,!this._greater(t,e))break;f(this.pq,t,e),t=e}}_greater(t,e){return this.comparator(this.pq[t],this.pq[e])>0}_isMinHeap(){for(let t=1;t<=this.n;++t)if(c.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(!c.nichts(this.pq[t]))return!1;return!c.echt(this.pq[0])&&this._isMinHeapOrdered(1)}_isMinHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&this._greater(t,e))&&(!(s<=this.n&&this._greater(t,s))&&(this._isMinHeapOrdered(e)&&this._isMinHeapOrdered(s)))}iter(){let t=new T(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t="",e=new T(h);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMin()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}class q{constructor(t,e){if(this.comparator=t,this.n=0,a.vec(e)){this.pq=new Array(e.length+1),this.n=e.length;for(let t=0;t<this.n;++t)this.pq[t+1]=e[t];for(let t=l(this.n/2);t>=1;--t)this._sink(t)}else this.pq=new Array(a.num(e)?e:2);c.assert(this._isMaxHeap(),"not max heap")}isEmpty(){return 0==this.n}size(){return this.n}max(){if(this.isEmpty())throw Error("Priority queue underflow");return this.pq[1]}insert(t){this.n==this.pq.length-1&&(this.pq=u(2*this.pq.length,this.n,1,this.n+1,this.pq)),this.n+=1,this.pq[this.n]=t,this._swim(this.n),c.assert(this._isMaxHeap(),"not max heap-insert")}delMax(){if(this.isEmpty())throw Error("Priority queue underflow");let t=this.pq[1];return f(this.pq,1,this.n),this.n-=1,this._sink(1),this.pq[this.n+1]=null,this.n>0&&this.n==l((this.pq.length-1)/4)&&(this.pq=u(l(this.pq.length/2),this.n,1,this.n+1,this.pq)),t}_isMaxHeap(){for(let t=1;t<=this.n;++t)if(c.nichts(this.pq[t]))return!1;for(let t=this.n+1;t<this.pq.length;++t)if(c.echt(this.pq[t]))return!1;return!c.echt(this.pq[0])&&this._isMaxHeapOrdered(1)}_isMaxHeapOrdered(t){if(t>this.n)return!0;let e=2*t,s=2*t+1;return!(e<=this.n&&N(this.pq,t,e,this.comparator))&&(!(s<=this.n&&N(this.pq,t,s,this.comparator))&&(this._isMaxHeapOrdered(e)&&this._isMaxHeapOrdered(s)))}_swim(t){for(;t>1&&N(this.pq,l(t/2),t,this.comparator);)f(this.pq,t,l(t/2)),t=l(t/2)}_sink(t){let e;for(;2*t<=this.n&&(e=2*t,e<this.n&&N(this.pq,e,e+1,this.comparator)&&++e,N(this.pq,t,e,this.comparator));)f(this.pq,t,e),t=e}iter(){const t=new q(this.comparator,this.size());for(let e=1;e<=this.n;++e)t.insert(this.pq[e]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t="",e=new q(h);"PQE".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ","XAM".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ","PLE".split("").forEach(t=>e.insert(t)),t+=e.delMax()+" ",console.log(t),console.log("("+e.size()+" left on pq)")}}function I(t,e,s,i){return i(t[e-1],t[s-1])<0}function S(t,e,s){const i=t[e-1];t[e-1]=t[s-1],t[s-1]=i}class A{static sort(t,e){function s(t,e,s,i){for(;2*e<=s;){let r=2*e;if(r<s&&I(t,r,r+1,i)&&++r,!I(t,e,r,i))break;S(t,e,r),e=r}}let i,r=t.length;for(i=l(r/2);i>=1;--i)s(t,i,r,e);for(i=r;i>1;)S(t,1,i--),s(t,1,i,e);return t}static test(){let t="SORTEXAMPLE".split("");g(A.sort(t,h)),t="bed bug dad yes zoo all bad yet".split(" "),g(A.sort(t,h))}}class O{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}minIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}minKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMin(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),c.assert(t==this.pq[this.n+1],"No good"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(s<0)throw Error("Calling decreaseKey() with a key strictly greater than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let s=this.compare(this.mKeys[t],e);if(0==s)throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(s>0)throw Error("Calling increaseKey() with a key strictly less than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let e=this.qp[t];this._exch(e,this.n--),this._swim(e),this._sink(e),this.mKeys[t]=null,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_greater(t,e){return this.compare(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]])>0}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._greater(l(t/2),t);)this._exch(t,l(t/2)),t=l(t/2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._greater(e,e+1)&&++e,!this._greater(t,e))break;this._exch(t,e),t=e}}iter(){let t=new O(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMin()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new O(t.length,h);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(;!e.isEmpty();){let s=e.delMin();console.log(s+" "+t[s])}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);for(;!e.isEmpty();)e.delMin()}}class z{constructor(t,e){if(t<0)throw Error("IllegalArgumentException");this.compare=e,this.maxN=t,this.n=0,this.mKeys=new Array(t+1),this.pq=new Array(t+1),this.qp=new Array(t+1);for(let e=0;e<=t;++e)this.qp[e]=-1}isEmpty(){return 0==this.n}contains(t){return this._validateIndex(t),-1!=this.qp[t]}size(){return this.n}insert(t,e){if(this._validateIndex(t),this.contains(t))throw Error("index is already in the priority queue");++this.n,this.qp[t]=this.n,this.pq[this.n]=t,this.mKeys[t]=e,this._swim(this.n)}maxIndex(){if(0==this.n)throw Error("Priority queue underflow");return this.pq[1]}maxKey(){if(0==this.n)throw Error("Priority queue underflow");return this.mKeys[this.pq[1]]}delMax(){if(0==this.n)throw Error("Priority queue underflow");let t=this.pq[1];return this._exch(1,this.n--),this._sink(1),c.assert(this.pq[this.n+1]==t,"bad delMax"),this.qp[t]=-1,this.mKeys[t]=null,this.pq[this.n+1]=-1,t}keyOf(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");return this.mKeys[t]}changeKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t]),this._sink(this.qp[t])}increaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling increaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)>0)throw Error("Calling increaseKey() with a key that is strictly less than the key in the priority queue");this.mKeys[t]=e,this._swim(this.qp[t])}decreaseKey(t,e){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");if(0==this.compare(this.mKeys[t],e))throw Error("Calling decreaseKey() with a key equal to the key in the priority queue");if(this.compare(this.mKeys[t],e)<0)throw Error("Calling decreaseKey() with a key that is strictly greater than the key in the priority queue");this.mKeys[t]=e,this._sink(this.qp[t])}delete(t){if(this._validateIndex(t),!this.contains(t))throw Error("index is not in the priority queue");let e=this.qp[t];this._exch(e,this.n--),this._swim(e),this._sink(e),this.mKeys[t]=null,this.qp[t]=-1}_validateIndex(t){if(t<0)throw Error("index is negative: "+t);if(t>=this.maxN)throw Error("index >= capacity: "+t)}_less(t,e){return d(this.mKeys[this.pq[t]],this.mKeys[this.pq[e]],this.compare)}_exch(t,e){let s=this.pq[t];this.pq[t]=this.pq[e],this.pq[e]=s,this.qp[this.pq[t]]=t,this.qp[this.pq[e]]=e}_swim(t){for(;t>1&&this._less(l(t/2),t);)this._exch(t,l(t/2)),t=l(t/2)}_sink(t){for(;2*t<=this.n;){let e=2*t;if(e<this.n&&this._less(e,e+1)&&++e,!this._less(t,e))break;this._exch(t,e),t=e}}iter(){let t=new z(this.pq.length-1,this.compare);for(let e=1;e<=this.n;++e)t.insert(this.pq[e],this.mKeys[this.pq[e]]);return{remove(){throw Error("UnsupportedOperationException")},hasNext:()=>!t.isEmpty(),next(){if(!this.hasNext())throw Error("NoSuchElementException");return t.delMax()}}}static test(){let t=["it","was","the","best","of","times","it","was","the","worst"],e=new z(t.length,h);for(let s=0;s<t.length;++s)e.insert(s,t[s]);for(let s,i=e.iter();i.hasNext();)s=i.next(),console.log(s+" "+t[s]);console.log("");for(let s=0;s<t.length;++s)c.rand()<.5?e.increaseKey(s,t[s]+t[s]):e.decreaseKey(s,t[s].substring(0,1));for(;!e.isEmpty();){let t=e.maxKey(),s=e.delMax();console.log(s+" "+t)}console.log("");for(let s=0;s<t.length;++s)e.insert(s,t[s]);let s=new Array(t.length);for(let e=0;e<t.length;++e)s[e]=e;c.shuffle(s);for(let t=0;t<s.length;++t){let i=e.keyOf(s[t]);e.delete(s[t]),console.log(s[t]+" "+i)}}}return{FibonacciMinPQ:b,IndexFibonacciMinPQ:M,Insertion:p,BinaryInsertion:m,Selection:y,Shell:w,Merge:v,Bubble:x,Quick:E,MinPQ:T,MaxPQ:q,Heap:A,IndexMinPQ:O,IndexMaxPQ:z}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic")):t["io/czlab/mcfud/algo/sort"]=e}(this),function(t){"use strict";function e(e,s,i){e||(e=t["io/czlab/mcfud/core"]()),s||(s=t["io/czlab/mcfud/algo/basic"]()),i||(i=t["io/czlab/mcfud/algo/sort"]());const{Bag:r,Stack:n,Queue:o,StdCompare:h,prnIter:l}=s,{MinPQ:a}=i,c=Math.floor,{is:u,u:d}=e;class f{static count(t,e){let s=new Map,i=0,r="",n=0;for(let r,o=0;o<t.length;++o)r=t[o],r.length<e||(++i,s.has(r)?s.set(r,s.get(r)+1):(s.set(r,1),++n));return s.set(r,0),Array.from(s.keys()).forEach(t=>{s.get(t)>s.get(r)&&(r=t)}),[r,s.get(r),[n,i]]}static test(){let t="it was the best of times it was the worst of times\n        it was the age of wisdom it was the age of foolishness\n        it was the epoch of belief it was the epoch of incredulity\n        it was the season of light it was the season of darkness\n        it was the spring of hope it was the winter of despair".split(" "),[e,s,i]=f.count(t,1);console.log(e+" "+s),console.log("distinct = "+i[0]),console.log("words= "+i[1])}}class g{constructor(){this.first=null,this.n=0}size(){return this.n}isEmpty(){return 0==this.size()}contains(t){if(d.nichts(t))throw Error("argument to contains is null");return void 0!==this.get(t)}get(t){if(d.nichts(t))throw Error("argument to get is null");for(let e=this.first;e;e=e.next)if(t==e.key)return e.val}put(t,e){if(d.nichts(t))throw Error("first argument to put is null");if(void 0===e)this.delete(t);else{let s,i;for(i=this.first;i&&!s;i=i.next)t==i.key&&(i.val=e,s=!0);s||(this.first=function(t,e,s){return{key:t,val:e,next:s}}(t,e,this.first),this.n+=1)}}delete(t){const e=(t,s)=>t?s==t.key?(this.n-=1,t.next):(t.next=e(t.next,s),t):null;if(d.nichts(t))throw Error("argument to delete is null");this.first=e(this.first,t)}keys(){let t=new o;for(let e=this.first;e;e=e.next)t.enqueue(e.key);return t.iter()}static load(t){let e=new g;return t.forEach((t,s)=>e.put(t,s)),e}static test(){let t=g.load("SEARCHEXAMPLE".split(""));console.log(((e="",s=0,i=0)=>{for(i=t.keys();i.hasNext();)e+=`${s=i.next()}=${t.get(s)} `;return e})()),console.log("size= "+t.size()),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),t.delete("R"),t.isEmpty(),console.log("contains R= "+t.contains("R")),console.log("get R= "+t.get("R")),console.log("size= "+t.size())}}class p{constructor(t,e=2){this.mKeys=new Array(e),this.vals=new Array(e),this.compare=t,this.n=0,this._resize=t=>{let e=new Array(t),s=new Array(t);for(let t=0;t<this.n;++t)e[t]=this.mKeys[t],s[t]=this.vals[t];this.vals=s,this.mKeys=e},this._argOk=t=>d.echt(t,"Invalid argument"),this._check=()=>(()=>{for(let t=1;t<this.size();++t)if(this.compare(this.mKeys[t],this.mKeys[t-1])<0)return!1;return!0})()&&(()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t=0;t<this.size();++t)if(0!=this.compare(this.mKeys[t],this.select(this.rank(this.mKeys[t]))))return!1;return!0})()}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){if(this._argOk(t)&&!this.isEmpty()){let e=this.rank(t);if(e<this.n&&0==this.compare(this.mKeys[e],t))return this.vals[e]}}rank(t){let e,s,i=0,r=this.n-1;for(this._argOk(t);i<=r;)if(e=i+c((r-i)/2),s=this.compare(t,this.mKeys[e]),s<0)r=e-1;else{if(!(s>0))return e;i=e+1}return i}put(t,e){if(this._argOk(t)&&void 0===e)this.delete(t);else{let s=this.rank(t);if(s<this.n&&0==this.compare(this.mKeys[s],t))this.vals[s]=e;else{this.n==this.mKeys.length&&this._resize(2*this.mKeys.length);for(let t=this.n;t>s;--t)this.mKeys[t]=this.mKeys[t-1],this.vals[t]=this.vals[t-1];this.n+=1,this.mKeys[s]=t,this.vals[s]=e}}}delete(t){if(this._argOk(t)&&this.isEmpty());else{let e=this.rank(t);if(e==this.n||0!=this.compare(this.mKeys[e],t));else{for(let t=e;t<this.n-1;++t)this.mKeys[t]=this.mKeys[t+1],this.vals[t]=this.vals[t+1];this.n-=1,this.mKeys[this.n]=null,this.vals[this.n]=null,this.n>0&&this.n==c(this.mKeys.length/4)&&this._resize(c(this.mKeys.length/2)),this._check()}}}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.min())}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow error");this.delete(this.max())}min(){if(this.isEmpty())throw Error("called min with empty symbol table");return this.mKeys[0]}max(){if(this.isEmpty())throw Error("called max with empty symbol table");return this.mKeys[this.n-1]}select(t){if(t<0||t>=this.size())throw Error("called select with invalid argument: "+t);return this.mKeys[t]}floor(t){let e=this._argOk(t)&&this.rank(t);if(e<this.n&&0==this.compare(t,this.mKeys[e]))return this.mKeys[e];if(0==e)throw Error("argument to floor is too small");return this.mKeys[e-1]}ceiling(t){let e=this._argOk(t)&&this.rank(t);if(e==this.n)throw Error("argument to ceiling is too large");return this.mKeys[e]}size(t,e){return 0==arguments.length?this.n:(this._argOk(t)&&this._argOk(e),this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t))}keys(t,e){0==arguments.length&&(t=this.min(),e=this.max()),this._argOk(t)&&this._argOk(e);let s=new o;if(this.compare(t,e)>0);else{for(let i=this.rank(t);i<this.rank(e);++i)s.enqueue(this.mKeys[i]);this.contains(e)&&s.enqueue(this.mKeys[this.rank(e)])}return s.iter()}static load(t,e){let s=new p(e);return t.forEach((t,e)=>s.put(t,e)),s}static test(){let t=p.load("SEARCHEXAMPLE".split(""),h),e=e=>{e="";for(let s,i=t.keys();i.hasNext();)s=i.next(),e+=`${s}=${t.get(s)} `;return e};console.log(e()),t.deleteMin(),console.log(e()),t.deleteMax(),t.isEmpty(),console.log(e()),console.log("floor of Q= "+t.floor("Q")),console.log("ceil of Q= "+t.ceiling("Q")),console.log("size= "+t.size()),console.log("size= "+t.size("E","P")),console.log("keys E->P = "+l(t.keys("E","P")))}}class m{constructor(t){this.compare=t,this.root=null,this._argOk=t=>d.assert(t,"Invalid argument"),this._check=()=>(this.isBST(this.root,null,null)||console.log("Not in symmetric order"),this.isSizeConsistent(this.root)||console.log("Subtree counts not consistent"),this.isRankConsistent()||console.log("Ranks not consistent"),this.isBST(this.root,null,null)&&this.isSizeConsistent(this.root)&&this.isRankConsistent()),this.isBST=(t,e,s)=>!!d.nichts(t)||!(d.echt(e)&&this.compare(t.key,e)<=0)&&(!(d.echt(s)&&this.compare(t.key,s)>=0)&&(this.isBST(t.left,e,t.key)&&this.isBST(t.right,t.key,s))),this.isSizeConsistent=t=>!!d.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(this.isSizeConsistent(t.left)&&this.isSizeConsistent(t.right)),this.isRankConsistent=()=>{for(let t=0;t<this.size();++t)if(t!=this.rank(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this.rank(t))))return!1;return!0}}Node(t,e,s){return{key:t,val:e,size:s,left:null,right:null}}isEmpty(){return 0==this.size()}contains(t){return this._argOk(t)&&void 0!==this.get(t)}get(t){return this._getNode(this.root,t)}_getNode(t,e){if(!this._argOk(e)||!d.nichts(t)){let s=this.compare(e,t.key);return s<0?this._getNode(t.left,e):s>0?this._getNode(t.right,e):t.val}}put(t,e){this._argOk(t)&&d.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this._check())}_putNode(t,e,s){if(d.nichts(t))t=this.Node(e,s,1);else{let i=this.compare(e,t.key);i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right)}return t}deleteMin(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMinNode(this.root),this._check()}_deleteMinNode(t){return d.nichts(t.left)?t=t.right:(t.left=this._deleteMinNode(t.left),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}deleteMax(){if(this.isEmpty())throw Error("Symbol table underflow");this.root=this._deleteMaxNode(this.root),this._check()}_deleteMaxNode(t){return d.nichts(t.right)?t=t.left:(t.right=this._deleteMaxNode(t.right),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1),t}delete(t){this.root=this._argOk(t)&&this._deleteNode(this.root,t),this._check()}_deleteNode(t,e){if(d.echt(t)){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(d.nichts(t.right))return t.left;if(d.nichts(t.left))return t.right;let e=t;(t=this._minNode(e.right)).right=this._deleteMinNode(e.right),t.left=e.left}t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1}return t}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return d.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return d.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(d.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(d.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0)return this._floorNode(t.left,e);let i=this._floorNode(t.right,e);return d.nichts(i)?t:i}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(d.nichts(e))throw Error("argument to floor is too large");return e.key}_ceilingNode(t,e){if(d.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0){let s=this._ceilingNode(t.left,e);return s||t}return this._ceilingNode(t.right,e)}select(t){if(t<0||t>=this.size())throw Error("argument to select is invalid: "+t);return this._selectNode(this.root,t)}_selectNode(t,e){if(d.nichts(t))return null;let s=this._sizeNode(t.left);return s>e?this._selectNode(t.left,e):s<e?this._selectNode(t.right,e-s-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(d.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new o;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(d.nichts(t));else{let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}_sizeNode(t){return d.nichts(t)?0:t.size}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}height(){return this._heightNode(this.root)}_heightNode(t){return d.nichts(t)?-1:1+Math.max(this._heightNode(t.left),this._heightNode(t.right))}levelOrder(){let t,e=[],s=new o;for(e.push(this.root);e.length>0;)t=e.pop(),d.echt(t)&&(s.enqueue(t.key),e.push(t.left,t.right));return s.iter()}static load(t,e){let s=new m(e);return t.forEach((t,e)=>s.put(t,e)),s}static test(){let t,e=m.load("SEARCHEXAMPLE".split(""),h);t="";for(let s,i=e.levelOrder();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("level-order:\n"+t),t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;e.isEmpty(),console.log("keys=\n"+t),console.log("size="+e.size()),console.log("size E->Q = ",e.size("E","Q")),t="";for(let s,i=e.keys("E","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[E->Q]= "+t),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank P= "+e.rank("P")),console.log("contains X= "+e.contains("X")),console.log("contains Z= "+e.contains("Z")),e.delete("X"),console.log("get C="+e.get("C")),console.log("max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("height= "+e.height()),console.log("min= "+e.min()),console.log("max= "+e.max()),console.log("rank E= "+e.rank("E")),console.log("floor G= "+e.floor("G")),console.log("ceiling G= "+e.ceiling("G"))}}class y{static BLACK=!1;static RED=!0;constructor(t){this.compare=t,this.root=null,this._argOk=t=>d.assert(t,"Invalid argument"),this._check=()=>{let t=(e,s,i)=>!!d.nichts(e)||!(s&&this.compare(e.key,s)<=0)&&(!(i&&this.compare(e.key,i)>=0)&&(t(e.left,s,e.key)&&t(e.right,e.key,i))),e=t=>!!d.nichts(t)||t.size==this._sizeNode(t.left)+this._sizeNode(t.right)+1&&(e(t.left)&&e(t.right)),s=t=>!!d.nichts(t)||!this._isRed(t.right)&&((t===this.root||!this._isRed(t)||!this._isRed(t.left))&&(s(t.left)&&s(t.right))),i=(t,e)=>d.nichts(t)?0==e:(this._isRed(t)||--e,i(t.left,e)&&i(t.right,e));return t(this.root,null,null)&&e(this.root)&&(()=>{for(let t=0;t<this.size();++t)if(t!=this._rankNode(this.select(t)))return!1;for(let t,e=this.keys();e.hasNext();)if(t=e.next(),0!=this.compare(t,this.select(this._rankNode(t))))return!1;return!0})()&&s(this.root)&&(()=>{let t=0,e=this.root;for(;e;)this._isRed(e)||++t,e=e.left;return i(this.root,t)})()}}Node(t,e,s,i){return{key:t,val:e,color:s,size:i,left:null,right:null}}_isRed(t){return!d.nichts(t)&&t.color===y.RED}_sizeNode(t){return d.nichts(t)?0:t.size}isEmpty(){return d.nichts(this.root)}get(t){return this._argOk(t)&&this._getNode(this.root,t)}_getNode(t,e){for(;t;){let s=this.compare(e,t.key);if(s<0)t=t.left;else{if(!(s>0))return t.val;t=t.right}}}contains(t){return void 0!==this.get(t)}put(t,e){this._argOk(t)&&d.nichts(e)?this.delete(t):(this.root=this._putNode(this.root,t,e),this.root.color=y.BLACK)}_putNode(t,e,s){if(d.nichts(t))return this.Node(e,s,y.RED,1);let i=this.compare(e,t.key);return i<0?t.left=this._putNode(t.left,e,s):i>0?t.right=this._putNode(t.right,e,s):t.val=s,this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}deleteMin(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=y.RED),this.root=this._deleteMinNode(this.root),this.isEmpty()||(this.root.color=y.BLACK)}_deleteMinNode(t){return d.nichts(t.left)?null:(this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteMinNode(t.left),this._balance(t))}deleteMax(){if(this.isEmpty())throw Error("BST underflow");this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=y.RED),this.root=this._deleteMaxNode(this.root),this.isEmpty()||(this.root.color=y.BLACK)}_deleteMaxNode(t){return this._isRed(t.left)&&(t=this._rotateRight(t)),d.nichts(t.right)?null:(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),t.right=this._deleteMaxNode(t.right),this._balance(t))}delete(t){this._argOk(t)&&!this.contains(t)||(this._isRed(this.root.left)||this._isRed(this.root.right)||(this.root.color=y.RED),this.root=this._deleteNode(this.root,t),this.isEmpty()||(this.root.color=y.BLACK))}_deleteNode(t,e){if(this.compare(e,t.key)<0)this._isRed(t.left)||this._isRed(t.left.left)||(t=this._moveRedLeft(t)),t.left=this._deleteNode(t.left,e);else{if(this._isRed(t.left)&&(t=this._rotateRight(t)),0==this.compare(e,t.key)&&d.nichts(t.right))return null;if(this._isRed(t.right)||this._isRed(t.right.left)||(t=this._moveRedRight(t)),0==this.compare(e,t.key)){let e=this._minNode(t.right);t.key=e.key,t.val=e.val,t.right=this._deleteMinNode(t.right)}else t.right=this._deleteNode(t.right,e)}return this._balance(t)}_rotateRight(t){if(d.nichts(t)||!this._isRed(t.left))throw Error("bad input to rotateRight");let e=t.left;return t.left=e.right,e.right=t,e.color=e.right.color,e.right.color=y.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_rotateLeft(t){if(d.nichts(t)||!this._isRed(t.right))throw Error("bad input to rotateLeft");let e=t.right;return t.right=e.left,e.left=t,e.color=e.left.color,e.left.color=y.RED,e.size=t.size,t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,e}_flipColors(t){t.color=!t.color,t.left.color=!t.left.color,t.right.color=!t.right.color}_moveRedLeft(t){return this._flipColors(t),this._isRed(t.right.left)&&(t.right=this._rotateRight(t.right),t=this._rotateLeft(t),this._flipColors(t)),t}_moveRedRight(t){return this._flipColors(t),this._isRed(t.left.left)&&(t=this._rotateRight(t),this._flipColors(t)),t}_balance(t){return this._isRed(t.right)&&!this._isRed(t.left)&&(t=this._rotateLeft(t)),this._isRed(t.left)&&this._isRed(t.left.left)&&(t=this._rotateRight(t)),this._isRed(t.left)&&this._isRed(t.right)&&this._flipColors(t),t.size=this._sizeNode(t.left)+this._sizeNode(t.right)+1,t}height(){return this._height(this.root)}_height(t){return d.nichts(t)?-1:1+Math.max(this._height(t.left),this._height(t.right))}min(){if(this.isEmpty())throw Error("calls min with empty symbol table");return this._minNode(this.root).key}_minNode(t){return d.nichts(t.left)?t:this._minNode(t.left)}max(){if(this.isEmpty())throw Error("calls max with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return d.nichts(t.right)?t:this._maxNode(t.right)}floor(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls floor with empty symbol table");let e=this._floorNode(this.root,t);if(d.nichts(e))throw Error("argument to floor is too small");return e.key}_floorNode(t,e){if(d.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0)return this._floorNode(t.left,e);let i=this._floorNode(t.right,e);return i||t}ceiling(t){if(this._argOk(t)&&this.isEmpty())throw Error("calls ceiling with empty symbol table");let e=this._ceilingNode(this.root,t);if(d.nichts(e))throw Error("argument to ceiling is too small");return e.key}_ceilingNode(t,e){if(d.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s>0)return this._ceilingNode(t.right,e);let i=this._ceilingNode(t.left,e);return i||t}select(t){if(t<0||t>=this.size())throw Error("argument to select is invalid: "+t);return this._selectNode(this.root,t)}_selectNode(t,e){if(d.nichts(t))return null;let s=this._sizeNode(t.left);return s>e?this._selectNode(t.left,e):s<e?this._selectNode(t.right,e-s-1):t.key}rank(t){return this._argOk(t)&&this._rankNode(t,this.root)}_rankNode(t,e){if(d.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keys(t,e){let s=new o;return 0==arguments.length&&(this.isEmpty()||(t=this.min(),e=this.max())),!this.isEmpty()&&this._argOk(t)&&this._argOk(e)&&this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}return e}size(t,e){return 0==arguments.length?this._sizeNode(this.root):this._argOk(t)&&this._argOk(e)&&this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}static load(t,e){let s=new y(e);return t.forEach((t,e)=>s.put(t,e)),s}static test(){let t,e=y.load("SEARCHEXAMPLE".split(""),h);t="";for(let s,i=e.keys();i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log(t),e.isEmpty(),console.log("height= "+e.height()+", size= "+e.size()),console.log("get X= "+e.get("X")),console.log("contains X= "+e.contains("X")),console.log("min= "+e.min()+",max= "+e.max()),e.deleteMin(),e.deleteMax(),console.log("min= "+e.min()+",max= "+e.max()),e.delete("R"),console.log("contains R= "+e.contains("R")),console.log("floor J= "+e.floor("J")),console.log("ceiling J= "+e.ceiling("J")),console.log("rank M= "+e.rank("M")),t="";for(let s,i=e.keys("D","Q");i.hasNext();)s=i.next(),t+=`${s}=${e.get(s)} `;console.log("keys[D-Q]= "+t),console.log("size[E-P]= "+e.size("E","P"))}}class w{static indexOf(t,e){let s=0,i=t.length-1;for(;s<=i;){let r=s+c((i-s)/2);if(e<t[r])i=r-1;else{if(!(e>t[r]))return r;s=r+1}}return-1}static test(){let t="84 48 68 10 18 98 12 23 54 57 33 16 77 11 29".split(" ").map(t=>+t).sort();"23 50 10 99 18 23 98 84 11 10 48 77 13 54 98 77 77 68".split(" ").map(t=>+t).forEach(e=>{w.indexOf(t,e)<0&&console.log(e)})}}class _{Node(t,e,s,i){return{key:t,val:e,height:s,size:i,left:null,right:null}}constructor(t){this.compare=t,this.root=null}isEmpty(){return d.nichts(this.root)}_sizeNode(t){return d.nichts(t)?0:t.size}height(){return this._heightNode(this.root)}_heightNode(t){return d.nichts(t)?-1:t.height}get(t){if(d.nichts(t))throw Error("argument to get() is null");let e=this._getNode(this.root,t);if(e)return e.val}_getNode(t,e){if(!t)return null;let s=this.compare(e,t.key);return s<0?this._getNode(t.left,e):s>0?this._getNode(t.right,e):t}contains(t){return void 0!==this.get(t)}put(t,e){if(d.nichts(t))throw Error("first argument to put() is null");void 0===e?this.delete(t):this.root=this._putNode(this.root,t,e)}_putNode(t,e,s){if(!t)return this.Node(e,s,0,1);let i=this.compare(e,t.key);if(i<0)t.left=this._putNode(t.left,e,s);else{if(!(i>0))return t.val=s,t;t.right=this._putNode(t.right,e,s)}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balanceNode(t)}_balanceNode(t){return this._balanceFactor(t)<-1?(this._balanceFactor(t.right)>0&&(t.right=this._rotateRight(t.right)),t=this._rotateLeft(t)):this._balanceFactor(t)>1&&(this._balanceFactor(t.left)<0&&(t.left=this._rotateLeft(t.left)),t=this._rotateRight(t)),t}_balanceFactor(t){return this._heightNode(t.left)-this._heightNode(t.right)}_rotateRight(t){let e=t.left;return t.left=e.right,e.right=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}_rotateLeft(t){let e=t.right;return t.right=e.left,e.left=t,e.size=t.size,t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),e.height=1+Math.max(this._heightNode(e.left),this._heightNode(e.right)),e}delete(t){if(d.nichts(t))throw Error("argument to delete() is null");this.contains(t)&&(this.root=this._deleteNode(this.root,t))}_deleteNode(t,e){let s=this.compare(e,t.key);if(s<0)t.left=this._deleteNode(t.left,e);else if(s>0)t.right=this._deleteNode(t.right,e);else{if(!t.left)return t.right;if(!t.right)return t.left;let e=t;(t=this.min(e.right)).right=this.deleteMin(e.right),t.left=e.left}return t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)}deleteMin(){if(this.isEmpty())throw Error("called deleteMin() with empty symbol table");this.root=this._deleteMinNode(this.root)}_deleteMinNode(t){return t.left?(t.left=this._deleteMinNode(t.left),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.right}deleteMax(){if(this.isEmpty())throw Error("called deleteMax() with empty symbol table");this.root=this._deleteMaxNode(this.root)}_deleteMaxNode(t){return t.right?(t.right=this._deleteMaxNode(t.right),t.size=1+this._sizeNode(t.left)+this._sizeNode(t.right),t.height=1+Math.max(this._heightNode(t.left),this._heightNode(t.right)),this._balance(t)):t.left}min(){if(this.isEmpty())throw Error("called min() with empty symbol table");return this._minNode(this.root).key}_minNode(t){return t.left?this._minNode(t.left):t}max(){if(this.isEmpty())throw Error("called max() with empty symbol table");return this._maxNode(this.root).key}_maxNode(t){return t.right?this._maxNode(t.right):t}floor(t){if(d.nichts(t))throw Error("argument to floor() is null");if(this.isEmpty())throw Error("called floor() with empty symbol table");let e=this._floorNode(this.root,t);if(e)return e.key}_floorNode(t,e){if(d.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s<0)return this._floorNode(t.left,e);let i=this._floorNode(t.right,e);return i||t}ceiling(t){if(d.nichts(t))throw Error("argument to ceiling() is null");if(this.isEmpty())throw Error("called ceiling() with empty symbol table");let e=this._ceilingNode(this.root,t);if(e)return e.key}_ceilingNode(t,e){if(d.nichts(t))return null;let s=this.compare(e,t.key);if(0==s)return t;if(s>0)return this._ceilingNode(t.right,e);let i=this._ceilingNode(t.left,e);return i||t}select(t){if(t<0||t>=this.size())throw Error("k is not in range 0-"+(this.size()-1));let e=this._selectNode(this.root,t);if(e)return e.key}_selectNode(t,e){if(d.nichts(t))return null;let s=this._sizeNode(t.left);return s>e?this._selectNode(t.left,e):s<e?this._selectNode(t.right,e-s-1):t}rank(t){if(d.nichts(t))throw Error("argument to rank() is null");return this._rankNode(t,this.root)}_rankNode(t,e){if(d.nichts(e))return 0;let s=this.compare(t,e.key);return s<0?this._rankNode(t,e.left):s>0?1+this._sizeNode(e.left)+this._rankNode(t,e.right):this._sizeNode(e.left)}keysInOrder(){let t=new o;return this._keysInOrderNode(this.root,t),t.iter()}_keysInOrderNode(t,e){d.nichts(t)||(this._keysInOrderNode(t.left,e),e.enqueue(t.key),this._keysInOrderNode(t.right,e))}keysLevelOrder(){let t=new o;if(!this.isEmpty()){let e=new o;for(e.enqueue(this.root);!e.isEmpty();){let s=e.dequeue();t.enqueue(s.key),s.left||e.enqueue(s.left),s.right&&e.enqueue(s.right)}}return t}keys(t,e){if(0==arguments.length)return this.keysInOrder();if(d.nichts(t))throw Error("first argument to keys() is null");if(d.nichts(e))throw Error("second argument to keys() is null");let s=new o;return this._keysNode(this.root,s,t,e),s.iter()}_keysNode(t,e,s,i){if(t){let r=this.compare(s,t.key),n=this.compare(i,t.key);r<0&&this._keysNode(t.left,e,s,i),r<=0&&n>=0&&e.enqueue(t.key),n>0&&this._keysNode(t.right,e,s,i)}}size(t,e){if(0==arguments.length)return this._sizeNode(this.root);if(d.nichts(t))throw Error("first argument to size() is null");if(d.nichts(e))throw Error("second argument to size() is null");return this.compare(t,e)>0?0:this.contains(e)?this.rank(e)-this.rank(t)+1:this.rank(e)-this.rank(t)}_check(){let t=this;return function e(s,i,r){return!s||!(!i&&t.compare(s.key,i)<=0)&&(!(!r&&t.compare(s.key,r)>=0)&&(e(s.left,i,s.key)&&e(s.right,s.key,r)))}(this.root,null,null)&&function e(s){if(!s)return!0;let i=t._balanceFactor(s);return!(i>1||i<-1)&&(e(s.left)&&e(s.right))}(this.root)&&function e(s){return!s||s.size==t._sizeNode(s.left)+t._sizeNode(s.right)+1&&(e(s.left)&&e(s.right))}(this.root)&&function(){for(let e=0;e<t.size();e++)if(e!=t.rank(t.select(e)))return!1;for(let e,s=t.keys().iterator();s.hasNext();)if(e=s.next(),0!=this.compare(e,t.select(t.rank(key))))return!1;return!0}()}static test(){let t=new _(h);"SEARCHEXAMPLE".split("").forEach((e,s)=>t.put(e,s));for(let e,s=t.keys();s.hasNext();)e=s.next(),console.log(e+" "+t.get(e))}}const v=Math.sqrt(2);function x(t,e){return{parent:e,pos:t,f:0,g:0,h:0,pid:`${t[0]},${t[1]}`,equals(t){return this.pos[0]==t.pos[0]&&this.pos[1]==t.pos[1]}}}class k{static manhattan(t,e,s=1){return s*Math.abs(t[1]-e[1])+s*Math.abs(t[0]-e[0])}static euclidean(t,e,s=1){let i=e[0]-t[0],r=e[1]-t[1];return s*(i*i+r*r)}static diagonal(t,e,s=1,i=v){let r=Math.abs(e[0]-t[0]),n=Math.abs(e[1]-t[1]);return s*(r+n)+(i-2*s)*Math.min(r,n)}constructor(t){this.grid=t}pathTo(t,e,s){return this._search(this.grid,t,e,s)}_search(t,e,s,i){const r=i.compare,n=t.length,o=t[0].length,h=new Map,l=new Map,c=new a(r,10),u=x(s),d=x(e),f=[[1,0],[-1,0],[0,1],[0,-1]],g=(t,e)=>{for(;t;t=t.parent)e.unshift(t.pos);return e};i.wantDiagonal&&f.push([1,1],[1,-1],[-1,1],[-1,-1]),l.set(d.pid,d.g),c.insert(d);let p,m=[];for(;!c.isEmpty();){if(p=c.delMin(),l.delete(p.pid),h.set(p.pid,0),p.equals(u))return g(p,[]);m.length=0;for(let t,e=0;e<f.length;++e)t=[p.pos[0]+f[e][0],p.pos[1]+f[e][1]],t[0]>o-1||t[0]<0||t[1]>n-1||t[1]<0||i.blocked(t)||m.push(x(t,p));m.forEach(t=>{h.has(t.pid)||(t.g=p.g+i.cost(),t.h=i.calcHeuristic(t.pos,u.pos),t.f=t.g+t.h,l.has(t.pid)&&t.g>l.get(t.pid)||(c.insert(t),l.set(t.pid,t.g)))})}}static test(){let t,e,s,i=[[0,1,0,0,0,0],[0,0,0,0,0,0],[0,1,0,1,0,0],[0,1,0,0,1,0],[0,0,0,0,1,0]],r=i.length,n=i[0].length,o={wantDiagonal:!1,compare:(t,e)=>t.f-e.f,cost:()=>1,blocked:t=>0!=i[t[1]][t[0]],calcHeuristic:(t,e)=>k.euclidean(t,e)},h=new k(i).pathTo([0,0],[5,4],o);h?(s="",h.forEach(t=>{s+=`[${t[0]},${t[1]}] `}),console.log(s),e=d.fill(r,()=>d.fill(n,"#")),t=0,h.forEach(s=>{e[s[1]][s[0]]=""+t,++t}),e.forEach(t=>{console.log(t.toString())})):console.log("no path")}}return{AStarGrid:k,AVLTreeST:_,BinarySearch:w,RedBlackBST:y,BST:m,BinarySearchST:p,SequentialSearchST:g,FrequencyCounter:f}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/search"]=e}(this),function(t){"use strict";function e(e,s,i){s||(s=t["io/czlab/mcfud/algo/basic"]()),i||(i=t["io/czlab/mcfud/algo/sort"]()),e||(e=t["io/czlab/mcfud/core"]());const{prnIter:r,TreeMap:n,Bag:o,Stack:h,Queue:l,ST:a,StdCompare:c}=s,{IndexMinPQ:u,MinPQ:d}=i,{is:f,u:g}=(Math.floor,e);function p(t,e){if(t<0||t>=e)throw Error(`vertex ${t} is not between 0 and ${e-1}`);return!0}class m{constructor(t){g.assert(t>=0,"Number of vertices must be non-negative"),this.verts=t,this.edges=0,this.adjls=g.fill(t,()=>new o)}clone(){let t=new m(this.V());t.edges=this.E(),t.adjls=[];for(let e=0,s=this.V();e<s;++e)t.adjls.push(this.adjls[e].clone());return t}V(){return this.verts}E(){return this.edges}addEdge(t,e){p(t,this.verts),p(e,this.verts),this.edges+=1,this.adjls[t].add(e),this.adjls[e].add(t)}adj(t){return p(t,this.verts)&&this.adjls[t]}degree(t){return p(t,this.verts)&&this.adjls[t].size()}toString(){let t=`${this.verts} vertices, ${this.edges} edges\n`;for(let e=0;e<this.verts;++e)t+=e+": "+r(this.adjls[e].iter()),t+="\n";return t}static load(t,e){let s=new m(t);g.assert(e.length%2==0,"wanted even n# of data points");for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}static test(){let t=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);t.degree(1),console.log(t.toString());let e=t.clone();console.log("cloned=\n"+e.toString())}}class y{constructor(t,e){this.bMarked=new Array(t.V()),this.nCount=0,p(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.nCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return p(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.nCount}static test(){let t,e,s=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach(i=>{e=new y(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=i+" ");console.log(t),console.log(e.count()!=s.V()?"NOT connected":"connected")})}}class w{constructor(t,e){this.bMarked=new Array(t.V()),p(e,this.bMarked.length);let s,i,r=g.fill(t.V(),e=>t.adj(e).iter()),n=new h;for(this.bMarked[e]=!0,n.push(e);!n.isEmpty();)s=n.peek(),r[s].hasNext()?(i=r[s].next(),this.bMarked[i]||(this.bMarked[i]=!0,n.push(i))):n.pop()}marked(t){return p(t,this.bMarked.length)&&this.bMarked[t]}static test(){let t,e,s=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]);[0,9].forEach(i=>{e=new w(s,i),t="";for(let i=0;i<s.V();++i)e.marked(i)&&(t+=i+" ");console.log(t)})}}class _{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,p(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new h;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t=m.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new _(t,0);for(let s,i,r=0;r<t.V();++r)if(e.hasPathTo(r)){s=`0 to ${r}:  `;for(let t=e.pathTo(r);t.hasNext();)i=t.next(),s+=0==i?i:"-"+i;console.log(s)}else console.log(`0 to ${r}:  not connected\n`)}}function v(t,e,s){let i,r=[];for(i=0;i<t.V();++i)s.mDistTo[i]=1/0;for(e.forEach(t=>{s.bMarked[t]=!0,s.mDistTo[t]=0,r.push(t)});r.length>0;){i=r.shift();for(let e,n=t.adj(i).iter();n.hasNext();)e=n.next(),s.bMarked[e]||(s.edgeTo[e]=i,s.mDistTo[e]=s.mDistTo[i]+1,s.bMarked[e]=!0,r.push(e))}}function x(t,e){if(!t||0==t.length)throw Error("argument is null or empty");return t.forEach(t=>p(t,e)),!0}class k{constructor(t,e){this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V()),f.vec(e)||(e=[e]),x(e,t.V()),v(t,e,this),function(t,e,s){if(0!=s.mDistTo[e])throw Error(`dist of source ${e} to itself = ${s.mDistTo[e]}`);for(let e=0;e<t.V();++e)for(let i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s.hasPathTo(e)!==s.hasPathTo(i))throw Error(`edge ${e}-${i}hasPathTo(${e})=${s.hasPathTo(e)}hasPathTo(${i})=${s.hasPathTo(i)}`);if(s.hasPathTo(e)&&s.mDistTo[i]>s.mDistTo[e]+1)throw Error(`edge ${e}-${i}distTo[${e}]=${s.mDistTo[e]}distTo[${i}]=${s.mDistTo[i]}`)}for(let i,r=0;r<t.V();++r)if(s.hasPathTo(r)&&r!=e&&(i=s.edgeTo[r],s.mDistTo[r]!=s.mDistTo[i]+1))throw Error(`shortest path edge ${i}-${r} distTo[${i}]= ${s.mDistTo[i]}distTo[${r}]= ${s.mDistTo[r]}`)}(t,e,this)}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return p(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new h;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t=m.load(6,[0,5,2,4,2,3,1,2,0,1,3,4,3,5,0,2]),e=new k(t,0);for(let s,i=0;i<t.V();++i)if(e.hasPathTo(i)){s=`0 to ${i}(${e.distTo(i)}): `;for(let t,r=e.pathTo(i);r.hasNext();)t=r.next(),s+=0==t?""+t:"-"+t;console.log(s)}else console.log(`0 to ${i} (-):  not connected\n`)}}class E{constructor(t,e,s){if(t<0)throw Error("vertex index must be a non-negative integer");if(e<0)throw Error("vertex index must be a non-negative integer");this.v=t,this.w=e,this._weight=s}weight(){return this._weight}either(){return this.v}other(t){if(t==this.v)return this.w;if(t==this.w)return this.v;throw Error("Illegal endpoint")}static comparator(t,e){return t._weight<e._weight?-1:t._weight>e._weight?1:0}toString(){return`${this.v}-${this.w} ${this._weight}`}static test(){console.log(new E(12,34,5.67).toString())}}class N{constructor(t){if(t<0)throw Error("Number of vertices must be non-negative");this._V=t,this._E=0,this.adjls=g.fill(t,()=>new o)}static randGraph(t,e){let s=new N(t);if(e<0)throw Error("Number of edges must be non-negative");for(let i,r,n,o=0;o<e;++o)r=g.randInt(t),n=g.randInt(t),i=Math.round(100*g.rand())/100,s.addEdge(new E(r,n,i));return s}clone(){let t=new N(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){let e=t.either(),s=t.other(e);p(e,this._V),p(s,this._V),this.adjls[e].add(t),this.adjls[s].add(t),this._E+=1}adj(t){return p(t,this._V)&&this.adjls[t]}degree(t){return p(t,this._V)&&this.adjls[t].size()}edges(){const t=new o;for(let e,s,i,r=0;r<this._V;++r)for(s=0,e=this.adjls[r].iter();e.hasNext();)i=e.next(),i.other(r)>r?t.add(i):i.other(r)==r&&(s%2==0&&t.add(i),++s);return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e,s=0;s<this._V;++s){for(t+=s+": ",e=this.adjls[s].iter();e.hasNext();)t+=e.next()+", ";t+="\n"}return t}static load(t,e){let s=new N(t);g.assert(e.length%3==0,"Invalid data size");for(let i=0;i<e.length;i+=3)p(e[i],t)&&p(e[i+1],t)&&s.addEdge(new E(e[i],e[i+1],e[i+2]));return s}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38 2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34 6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(" ").map(t=>+t),e=N.load(8,t);console.log(e.toString())}}class b{constructor(t){this.bMarked=new Array(t.V()),this._id=new Array(t.V()),this._size=new Array(t.V()),this.nCount=0;for(let e=0;e<t.V();++e)this.bMarked[e]||(this._dfs(t,e),++this.nCount)}_dfs(t,e){this.bMarked[e]=!0,this._id[e]=this.nCount,this._size[this.nCount]+=1;for(let s,i,r=t.adj(e).iter();r.hasNext();)s=r.next(),t instanceof N?(i=s.other(e),this.bMarked[i]||this._dfs(t,i)):this.bMarked[s]||this._dfs(t,s)}id(t){return p(t,this.bMarked.length)&&this._id[t]}size(t){return p(t,this.bMarked.length)&&this._size[this._id[t]]}count(){return this.nCount}connected(t,e){return p(t,this.bMarked.length)&&p(e,this.bMarked.length)&&this.id(t)==this.id(e)}static test(){let t=m.load(13,[0,5,4,3,0,1,9,12,6,4,5,4,0,2,11,12,9,10,0,6,7,8,9,11,5,3]),e=new b(t),s=e.count();console.log(s+" components");let i=g.fill(s,()=>[]);for(let s=0;s<t.V();++s)i[e.id(s)].push(s);for(let t,e=0;e<s;++e)t="",i[e].forEach(e=>t+=e.toString()+" "),console.log(t)}}class M{static load(t,e){if(t<0)throw Error("verts in a Digraph must be non-negative");g.assert(e.length%2==0,"expected even n# of data-length");let s=new M(t);for(let t=0;t<e.length;t+=2)s.addEdge(e[t],e[t+1]);return s}constructor(t){if(t<0)throw Error("verts in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=g.fill(t,0),this.adjls=g.fill(t,()=>new o)}clone(){let t=this,e=new M(this.V());e._E=this.E(),e._indegree=g.fill(e.V(),e=>t._indegree[e]);for(let t=0;t<e.V();++t)e.adjls[t]=this.adjls[t].clone();return e}V(){return this._V}E(){return this._E}addEdge(t,e){p(t,this._V)&&p(e,this._V),this.adjls[t].add(e),this._indegree[e]+=1,++this._E}adj(t){return p(t,this._V)&&this.adjls[t]}outdegree(t){return p(t,this._V)&&this.adjls[t].size()}indegree(t){return p(t,this._V)&&this._indegree[t]}reverse(){let t=new M(this._V);for(let e,s=0;s<this._V;++s)for(e=this.adjls[s].iter();e.hasNext();)t.addEdge(e.next(),s);return t}toString(){let t=`${this._V} vertices, ${this._E} edges\n`;for(let e,s=0;s<this._V;++s){for(t+=s+": ",e=this.adjls[s].iter();e.hasNext();)t+=e.next()+" ";t+="\n"}return t}static test(){let t=M.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t)),e="",s="";for(let i=0;i<t.V();++i)e+=`${i}=${t.indegree(i)}, `,s+=`${i}=${t.outdegree(i)},`;console.log("indegreee= "+e),console.log("outdegreee= "+s),console.log(t.toString());let i=t.clone();console.log("cloned=\n"+i.toString());let r=t.reverse();console.log("rev'ed=\n"+r.toString())}}class T{constructor(t,e){this.bMarked=new Array(t.V()),f.vec(e)||(e=[e]),x(e,t.V()),e.forEach(e=>{this.bMarked[e]||this._dfs(t,e)})}_dfs(t,e){this.mCount+=1,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||this._dfs(t,s)}marked(t){return p(t,this.bMarked.length)&&this.bMarked[t]}count(){return this.mCount}static test(){let t=M.load(13,"4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t)),e="",s=new T(t,[1,2,6]);for(let i=0;i<t.V();++i)s.marked(i)&&(e+=i+" ");s.count(),console.log(e)}}class q{constructor(t){this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V()),this.mCycle=null;for(let e=0;e<t.V();++e)this.bMarked[e]||null!==this.mCycle||this._dfs(t,e)}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();){if(s=i.next(),null!==this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new h;for(let t=e;t!=s;t=this.edgeTo[t])this.mCycle.push(t);this.mCycle.push(s),this.mCycle.push(e),this._check()}}else this.edgeTo[s]=e,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return null!==this.mCycle}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=-1,e=-1;for(let s,i=this.cycle();i.hasNext();)s=i.next(),-1==t&&(t=s),e=s;if(t!=e)throw Error(`cycle begins with ${t} and ends with ${e}\n`)}return!0}static test(){let t="2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map(t=>+t),e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9\n               10 9 11 7  9 10 12 11  4 4  3 3  5 6  8 8\n               6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t);[new q(M.load(13,e)),new q(M.load(13,t))].forEach(t=>{t.hasCycle()?(console.log("Directed cycle: "),console.log(r(t.cycle()))):console.log("No directed cycle")})}}class I{constructor(t,e,s){if(t<0)throw Error("Vertex names must be non-negative integers");if(e<0)throw Error("Vertex names must be non-negative integers");this.v=t,this.w=e,this._weight=s}from(){return this.v}to(){return this.w}weight(){return this._weight}toString(){return`${this.v}->${this.w} ${Number(this._weight).toFixed(2)}`}static test(){console.log(new I(12,34,5.67).toString())}}class S{constructor(t){if(t<0)throw Error("Number of vertices in a Digraph must be non-negative");this._V=t,this._E=0,this._indegree=new Array(t),this.adjls=g.fill(t,()=>new o)}static randGraph(t,e){if(e<0)throw Error("n# edges in a Digraph must be non-negative");let s=new S(t);for(let i=0;i<e;++i)s.addEdge(new I(g.randInt(t),g.randInt(t),.01*_randInt(100)));return s}static load(t,e){if(t<0)throw Error("n# vertices in a Digraph must be non-negative");g.assert(e.length%3==0,"bad data length");let s=new S(t);for(let i=0;i<e.length;i+=3)p(e[i],t)&&p(e[i+1],t)&&s.addEdge(new I(e[i],e[i+1],e[i+2]));return s}clone(){let t=new S(this.V());t._E=this.E();for(let e=0;e<this.V();++e)t._indegree[e]=this._indegree(e);for(let e=0;e<this.V();++e)t.adjls[e]=this.adjls[e].clone();return t}V(){return this._V}E(){return this._E}addEdge(t){g.assert(t instanceof I,"Expected DirectedEdge");let e=t.to(),s=t.from();p(s,this._V),p(e,this._V),this.adjls[s].add(t),this._indegree[e]+=1,this._E++}adj(t){return p(t,this._V)&&this.adjls[t]}outdegree(t){return p(t,this._V)&&this.adjls[t].size()}indegree(t){return p(t,this._V)&&this._indegree[t]}edges(){const t=new o;for(let e=0;e<this._V;++e)for(let s=this.adj(e).iter();s.hasNext();)t.add(s.next());return t.iter()}toString(){let t=`${this._V} ${this._E}\n`;for(let e=0;e<this._V;++e)t+=e+": "+r(this.adjls[e].iter())+"\n";return t}static test(){let t="4 5 0.35\n        5 4 0.35\n        4 7 0.37\n        5 7 0.28\n        7 5 0.28\n        5 1 0.32\n        0 4 0.38\n        0 2 0.26\n        7 3 0.39\n        1 3 0.29\n        2 7 0.34\n        6 2 0.40\n        3 6 0.52\n        6 0 0.58\n        6 4 0.93".split(/\s+/).map(t=>+t),e=S.load(8,t);console.log(e.toString())}}class A{constructor(t){this._pre=new Array(t.V()),this._post=new Array(t.V()),this.preCounter=0,this.postCounter=0,this.postorder=new l,this.preorder=new l,this.bMarked=new Array(t.V());for(let e=0;e<t.V();e++)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.bMarked[e]=!0,this._pre[e]=this.preCounter++,this.preorder.enqueue(e);for(let s,i=t.adj(e).iter();i.hasNext();)s=t instanceof S?i.next().to():i.next(),this.bMarked[s]||this._dfs(t,s);this.postorder.enqueue(e),this._post[e]=this.postCounter++}pre(t){return p(t,this.bMarked.length)&&this._pre[t]}post(t){return p(t,this.bMarked.length)&&this._post[t]}postOrder(){return this.postorder.iter()}preOrder(){return this.preorder.iter()}reversePost(){let t=new h;for(let e=this.postorder.iter();e.hasNext();)t.push(e.next());return t.iter()}_check(){let t,e=0;for(t=this.postOrder();t.hasNext();){if(this.post(t.next())!=e)throw Error("post(v) and post() inconsistent");++e}for(e=0,t=this.preOrder();t.hasNext();){if(this.pre(t.next())!=e)throw Error("pre(v) and pre() inconsistent");++e}return!0}static test(){let t=M.load(13,"2 3 0 6 0 1 2 0 11 12  9 12  9 10  9 11 3 5 8 7 5 4 0 5 6 4 6 9 7 6".split(/\s+/).map(t=>+t));console.log(t.toString());let e=new A(t);console.log("   v  pre  post"),console.log("--------------");for(let s=0;s<t.V();++s)console.log(`    ${s}  ${e.pre(s)}  ${e.post(s)}\n`);console.log("Preorder:  "),console.log(r(e.preOrder())),console.log("Postorder:  "),console.log(r(e.postOrder())),console.log(""),console.log("Reverse postorder: "),console.log(r(e.reversePost()))}}class O{constructor(t){g.assert(t instanceof S,"Expected EdgeWeightedDigraph"),this.bMarked=new Array(t.V()),this.onStack=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.bMarked[e]||this._dfs(t,e);this._check()}_dfs(t,e){this.onStack[e]=!0,this.bMarked[e]=!0;for(let s,i,r=t.adj(e).iter();r.hasNext();){if(i=r.next(),s=i.to(),this.mCycle)return;if(this.bMarked[s]){if(this.onStack[s]){this.mCycle=new h;let t=i;for(;t.from()!=s;)this.mCycle.push(t),t=this.edgeTo[t.from()];return void this.mCycle.push(t)}}else this.edgeTo[s]=i,this._dfs(t,s)}this.onStack[e]=!1}hasCycle(){return g.echt(this.mCycle)}cycle(){return this.mCycle&&this.mCycle.iter()}_check(){if(this.hasCycle()){let t=null,e=null;for(let s,i=this.cycle();i.hasNext();){if(s=i.next(),t||(t=s),e&&e.to()!=s.from())throw Error(`cycle edges ${e} and ${s} not incident\n`);e=s}if(e.to()!=t.from())throw Error(`cycle edges ${e} and ${t} not incident\n`)}return!0}static test(){let t=13,e=new S(t);g.shuffle(g.fill(t,t=>t));for(let s,i,r,n=0;n<8;++n){do{i=g.randInt(t),r=g.randInt(t)}while(i>=r);s=g.rand(),e.addEdge(new I(i,r,s))}for(let s=0;s<6;++s)e.addEdge(new I(g.randInt(t),g.randInt(t),g.rand()));console.log(e.toString());let s=new O(e);s.hasCycle()?console.log("Cycle: "+r(s.cycle())):console.log("No directed cycle")}}class z{constructor(t){this.st=new a,t.forEach(t=>t.forEach((t,e)=>{this.st.contains(t)||this.st.put(t,this.st.size())})),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this._graph=new m(this.st.size()),t.forEach(t=>{let e=this.st.get(t[0]);for(let s,i=1;i<t.length;++i)s=this.st.get(t[i]),this._graph.addEdge(e,s)})}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return p(t,this._graph.V())&&this.keys[t]}graph(){return this._graph}static test(){let t="JFK MCO\n                  ORD DEN\n                  ORD HOU\n                  DFW PHX\n                  JFK ATL\n                  ORD DFW\n                  ORD PHX\n                  ATL HOU\n                  DEN PHX\n                  PHX LAX\n                  JFK ORD\n                  DEN LAS\n                  DFW HOU\n                  ORD ATL\n                  LAS LAX\n                  ATL MCO\n                  HOU MCO\n                  LAS PHX".split(/\s+/),e=new z(g.partition(2,t)),s=e.graph();["JFK","LAX"].forEach(t=>{if(e.contains(t)){let i=e.indexOf(t);console.log(t);for(let t=s.adj(i).iter();t.hasNext();)console.log("   "+e.nameOf(t.next()))}else console.log("input not contain '"+t+"'")})}}class P{constructor(t){this.st=new a,t.forEach(t=>t.forEach(t=>{this.st.contains(t)||this.st.put(t,this.st.size())})),this.keys=new Array(this.st.size());for(let t,e=this.st.keys();e.hasNext();)t=e.next(),this.keys[this.st.get(t)]=t;this.graph=new M(this.st.size()),t.forEach(t=>{let e=this.st.get(t[0]);for(let s=1;s<t.length;++s)this.graph.addEdge(e,this.st.get(t[s]))})}contains(t){return this.st.contains(t)}indexOf(t){return this.st.get(t)}nameOf(t){return p(t,this.graph.V())&&this.keys[t]}digraph(){return this.graph}static test(){let t="JFK MCO\n              ORD DEN\n              ORD HOU\n              DFW PHX\n              JFK ATL\n              ORD DFW\n              ORD PHX\n              ATL HOU\n              DEN PHX\n              PHX LAX\n              JFK ORD\n              DEN LAS\n              DFW HOU\n              ORD ATL\n              LAS LAX\n              ATL MCO\n              HOU MCO\n              LAS PHX".split(/\s+/),e=new P(g.partition(2,t)),s=e.digraph();["JFK","ATL","LAX"].forEach(t=>{console.log(""+t);let i=s.adj(e.indexOf(t)).iter();for(;i.hasNext();)console.log("   "+e.nameOf(i.next()))})}}class D{constructor(t){let e;if(this._order=null,this.rank=null,t instanceof S?e=new O(t):t instanceof M?(e=new q(t),e.hasCycle()||(this.rank=new Array(t.V()))):g.assert(!1,"bad arg for Topological"),e&&!e.hasCycle()){this._order=new l;for(let e,s=0,i=new A(t).reversePost();i.hasNext();)e=i.next(),this.rank&&(this.rank[e]=s++),this._order.enqueue(e)}}order(){return this._order.iter()}hasOrder(){return g.echt(this._order)}rank(t){return this.rank&&p(t,this.rank.length)&&this.hasOrder()?this.rank[t]:-1}static test(){let t=new P([["Algorithms","Theoretical CS","Databases","Scientific Computing"],["Introduction to CS","Advanced Programming","Algorithms"],["Advanced Programming","Scientific Computing"],["Scientific Computing","Computational Biology"],["Theoretical CS","Computational Biology","Artificial Intelligence"],["Linear Algebra","Theoretical CS"],["Calculus","Linear Algebra"],["Artificial Intelligence","Neural Networks","Robotics","Machine Learning"],["Machine Learning","Neural Networks"]]);for(let e=new D(t.digraph()).order();e.hasNext();)console.log(t.nameOf(e.next()))}}class R{constructor(t,e){this.bMarked=new Array(t.V()),this.edgeTo=new Array(t.V()),this.s=e,p(e,this.bMarked.length)&&this._dfs(t,e)}_dfs(t,e){this.bMarked[e]=!0;for(let s,i=t.adj(e).iter();i.hasNext();)s=i.next(),this.bMarked[s]||(this.edgeTo[s]=e,this._dfs(t,s))}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e=new h;for(let s=t;s!=this.s;s=this.edgeTo[s])e.push(s);return e.push(this.s),e.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t),s=M.load(13,e),i=new R(s,3);for(let e=0;e<s.V();++e)if(i.hasPathTo(e)){t=`3 to ${e}:  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?""+s:"-"+s;console.log(t)}else console.log(`3 to ${e}:  not connected`)}}class C{constructor(t,e){f.vec(e)||(e=[e]),this.bMarked=new Array(t.V()),this.mDistTo=new Array(t.V()),this.edgeTo=new Array(t.V());for(let e=0;e<t.V();++e)this.mDistTo[e]=1/0;x(e,t.V())&&this._bfs(t,e)}_bfs(t,e){let s=new l;for(e.forEach(t=>{this.bMarked[t]=!0,this.mDistTo[t]=0,s.enqueue(t)});!s.isEmpty();){let e=s.dequeue();for(let i,r=t.adj(e).iter();r.hasNext();)i=r.next(),this.bMarked[i]||(this.edgeTo[i]=e,this.mDistTo[i]=this.mDistTo[e]+1,this.bMarked[i]=!0,s.enqueue(i))}}hasPathTo(t){return p(t,this.bMarked.length)&&this.bMarked[t]}distTo(t){return p(t,this.bMarked.length)&&this.mDistTo[t]}pathTo(t){if(p(t,this.bMarked.length)&&this.hasPathTo(t)){let e,s=new h;for(e=t;0!=this.mDistTo[e];e=this.edgeTo[e])s.push(e);return s.push(e),s.iter()}}static test(){let t,e="4  2 2  3 3  2 6  0 0  1 2  0 11 12 12  9 9 10\n              9 11 7  9 10 12 11  4 4  3 3  5 6\n              8 8  6 5  4 0  5 6  4 6  9 7  6".split(/\s+/).map(t=>+t),s=M.load(13,e),i=new C(s,3);for(let e=0;e<s.V();++e)if(t="",i.hasPathTo(e)){t=`3 to ${e} (${i.distTo(e)}):  `;for(let s,r=i.pathTo(e);r.hasNext();)s=r.next(),t+=3==s?""+s:"->"+s;console.log(t)}else console.log(`3 to ${e} (-):  not connected`)}}class j{constructor(t,e,s){g.assert(t instanceof S,"Expected EdgeWeightedDigraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw Error(`edge ${e} has negative weight`);this._distTo=new Array(t.V()),this.edgeTo=g.fill(t.V(),null),p(e,t.V());for(let e=0;e<t.V();++e)this._distTo[e]=1/0;for(this._distTo[e]=0,this.pq=new u(t.V(),s),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next())}this._check(t,e)}_relax(t){let e=t.from(),s=t.to();this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return p(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return p(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(p(t,this._distTo.length)&&this.hasPathTo(t)){let e=new h;for(let s=this.edgeTo[t];null!=s;s=this.edgeTo[s.from()])e.push(s);return e.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||null!==this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&null===this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.to(),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(null===this.edgeTo[i]);else{if(s=this.edgeTo[i],e=s.from(),i!=s.to())throw Error("bad edge");if(this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35\n                  5 4 0.35\n                  4 7 0.37\n                  5 7 0.28\n                  7 5 0.28\n                  5 1 0.32\n                  0 4 0.38\n                  0 2 0.26\n                  7 3 0.39\n                  1 3 0.29\n                  2 7 0.34\n                  6 2 0.40\n                  3 6 0.52\n                  6 0 0.58\n                  6 4 0.93".split(/\s+/).map(t=>+t),e=S.load(8,t),s=new j(e,0,c);for(let t=0;t<e.V();++t)s.hasPathTo(t)?console.log(`0 to ${t} (${Number(s.distTo(t)).toFixed(2)})  ${r(s.pathTo(t))}`):console.log(`0 to ${t}         no path\n`)}}class L{constructor(t,e,s){g.assert(t instanceof N,"Expected EdgeWeightedGraph");for(let e,s=t.edges();s.hasNext();)if(e=s.next(),e.weight()<0)throw new Error(`edge ${e} has negative weight`);for(this._distTo=g.fill(t.V(),()=>1/0),this._distTo[e]=0,this.compare=s,this.edgeTo=g.fill(t.V(),()=>null),p(e,t.V()),this.pq=new u(t.V(),this.compare),this.pq.insert(e,this._distTo[e]);!this.pq.isEmpty();){let e=this.pq.delMin();for(let s=t.adj(e).iter();s.hasNext();)this._relax(s.next(),e)}this._check(t,e)}_relax(t,e){let s=t.other(e);this._distTo[s]>this._distTo[e]+t.weight()&&(this._distTo[s]=this._distTo[e]+t.weight(),this.edgeTo[s]=t,this.pq.contains(s)?this.pq.decreaseKey(s,this._distTo[s]):this.pq.insert(s,this._distTo[s]))}distTo(t){return p(t,this._distTo.length)&&this._distTo[t]}hasPathTo(t){return p(t,this._distTo.length)&&this._distTo[t]<1/0}pathTo(t){if(p(t,this._distTo.length)&&this.hasPathTo(t)){let e=t,s=new h;for(let i=this.edgeTo[t];null!==i;i=this.edgeTo[e])s.push(i),e=i.other(e);return s.iter()}}_check(t,e){for(let e=t.edges();e.hasNext();)if(e.next().weight()<0)throw Error("negative edge weight detected");if(0!=this._distTo[e]||null!==this.edgeTo[e])throw Error("distTo[s] and edgeTo[s] inconsistent");for(let s=0;s<t.V();++s)if(s!=e&&null===this.edgeTo[s]&&this._distTo[s]!=1/0)throw Error("distTo[] and edgeTo[] inconsistent");for(let e=0;e<t.V();++e)for(let s,i,r=t.adj(e).iter();r.hasNext();)if(i=r.next(),s=i.other(e),this._distTo[e]+i.weight()<this._distTo[s])throw Error(`edge ${i} not relaxed`);for(let e,s,i=0;i<t.V();++i)if(null!==this.edgeTo[i]){if(s=this.edgeTo[i],i!=s.either()&&i!=s.other(s.either()))return!1;if(e=s.other(i),this._distTo[e]+s.weight()!=this._distTo[i])throw Error(`edge ${s} on shortest path not tight`)}return!0}static test(){let t="4 5 0.35 4 7 0.37 5 7 0.28 0 7 0.16 1 5 0.32 0 4 0.38\n                  2 3 0.17 1 7 0.19 0 2 0.26 1 2 0.36 1 3 0.29 2 7 0.34\n                  6 2 0.40 3 6 0.52 6 0 0.58 6 4 0.93".split(/\s+/).map(t=>+t),e=N.load(8,t),s=new L(e,6,c);for(let t,i=0;i<e.V();++i)if(s.hasPathTo(i)){t=`6 to ${i} (${Number(s.distTo(i)).toFixed(2)})  `;for(let e=s.pathTo(i);e.hasNext();)t+=e.next()+"   ";console.log(t)}else console.log(`6 to ${i}         no path`)}}return{DepthFirstDirectedPaths:R,BreadthFirstDirectedPaths:C,SymbolGraph:z,DijkstraUndirectedSP:L,DijkstraSP:j,Topological:D,SymbolDigraph:P,EdgeWeightedDirectedCycle:O,DepthFirstOrder:A,EdgeWeightedDigraph:S,DirectedEdge:I,DirectedCycle:q,DirectedDFS:T,Digraph:M,CC:b,EdgeWeightedGraph:N,Edge:E,BreadthFirstPaths:k,DepthFirstPaths:_,NonrecursiveDFS:w,DepthFirstSearch:y,Graph:m}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core"),require("./basic"),require("./sort")):t["io/czlab/mcfud/algo/graph"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());Math.floor;const{u:s,is:i}=e,r={NUM_HIDDEN:1,BIAS:-1,NEURONS_PER_HIDDEN:10,ACTIVATION_RESPONSE:1,MAX_PERTURBATION:.3,NUM_ELITE:4,NUM_COPIES_ELITE:1,TOURNAMENT_COMPETITORS:5,probTournament:.75,crossOverRate:.7,mutationRate:.1};class n{constructor(){}gt(t){}lt(t){}eq(t){}clone(){}score(){}update(t){}}class o extends n{constructor(t,e){super(),this.value=t,this.flip=e}gt(t){return this.flip?this.value<t.value:this.value>t.value}eq(t){return this.value==t.value}lt(t){return this.flip?this.value>t.value:this.value<t.value}score(){return this.value}update(t){this.value=t}clone(){return new o(this.value,this.flip)}}class h{constructor(){this.averageScore=0,this.totalScore=0,this.bestScore=0,this.worstScore=0,this.best=null}}class l{constructor(t){let e=s.fill(t+1,()=>s.randMinus1To1());this.numInputs=e.length,this.activation=0,this.weights=e,this.error=0}}class a{constructor(t,e){this.numNeurons=t,this.neurons=s.fill(t,()=>new l(e))}}class c{constructor(t,e){this.fitness=e,this.genes=t,this.age=0}clone(){return new c(this.genes.slice(),this.fitness.clone())}}function u(t){let e=s.randInt(t.length),i=s.randInt(t.length);return e<i?[e,i]:[i,e]}function d(t,e){let i,r=0,n=s.rand(),o=t.map(t=>r+=t.fitness.score()/e);for(i=0;i<o.length-1;++i)if(n>=o[i]&&n<=o[i+1])return t[i];return t[0]}function f(t){let e=s.randInt(t.length),i=s.randInt(t.length);for(;e==i;)i=s.randInt2(0,t.length-1);return s.rand()<r.probTournament?t[e].fitness.gt(t[i].fitness)?t[e]:t[i]:t[e].fitness.lt(t[i].fitness)?t[e]:t[i]}function g(t,e){let s=0,i=1/0,r=new h;function n(t){s=t.fitness.score(),r.bestScore=s,r.best=t}function o(t){i=t.fitness.score(),r.worstScore=i}return e&&(i=0,s=1/0),t.forEach(t=>{e?t.fitness.score()<s?n(t):t.fitness.score()>i&&o(t):t.fitness.score()>s?n(t):t.fitness.score()<i&&o(t),r.totalScore+=t.fitness.score()}),r.averageScore=r.totalScore/t.length,r}function p(t,e="cycles"){let i=t.startTime=s.now();return t[e]=0,i}function m(t){return t.endTime=s.now()}function y(t,e,i,r,n){let o=s.randInt(e.length);for(;e.length>1&&o==t;)o=s.randInt(e.length);let h,l,a=e[t].genes,u=e[o].genes;i?[h,l]=i(a,u):(h=a.slice(),l=u.slice()),r&&(r(h),r(l));let d=n(h,e[t].fitness),f=n(l,e[o].fitness);return d.gt(f)?new c(h,d):new c(l,f)}function w(t,e){let s,i=0;for(;i<t.length&&(s=t[i],!s.fitness.eq(e.fitness)&&!e.fitness.lt(s.fitness));++i);return i}function _(t,{calcFit:e,crossOver:n,create:o,mutate:h}){if(i.num(t))return s.fill(t,()=>o());let l,a,u,p,m=[],y=g(t);t.sort((t,e)=>t.fitness.lt(e.fitness)?-1:t.fitness.gt(e.fitness)?1:0);for(let e=r.NUM_ELITES,s=t.length-1;s>=0&&e>0;--s)m.push(t[s]),--e;for(;m.length<t.length;)void 0!==r.TOURNAMENT_COMPETITORS?(u=f(t),p=f(t)):(u=d(t,y),p=d(t,y)),n?[l,a]=n(u.genes,p.genes):(l=u.genes.slice(),a=p.genes.slice()),h&&(h(l),h(a)),m.push(new c(l,e(l,u.fitness)),new c(a,e(a,p.fitness)));for(;m.length>t.length;)m.pop();return m}return{NeuronLayer:a,Neuron:l,NeuralNet:class{constructor(t,e,s,i){this.layers=function(r){if(s>0){r.push(new a(i,t));for(let t=0;t<s-1;++t)r.push(new a(i,i));r.push(new a(e,i))}else r.push(new a(e,t));return r}([]),this.numOfWeights=this.layers.reduce((t,e)=>t+e.neurons.reduce((t,e)=>t+e.weights.length,0),0),this.numOutputs=e,this.numInputs=t,this.numHidden=s,this.neuronsPerHidden=i}putWeights(t){s.assert(t.length>=this.numOfWeights,"bad input to putWeights");let e=0;this.layers.forEach(s=>{s.neurons.forEach(s=>{s.weights.forEach((i,r)=>s.weights[r]=t[e++])})})}getNumberOfWeights(){return this.numOfWeights}feedForward(t){return this.update(t)}update(t){s.assert(t.length>=this.numInputs,"invalid input size");let e,i,n,o=[];return this.layers.forEach((s,h)=>{h>0&&(t=o),o=[],s.neurons.forEach(s=>{n=0,e=0,i=s.numInputs;for(let r=0;r<i-1;++r)e+=s.weights[r]*t[n++];e+=s.weights[i-1]*r.BIAS,o.push(s.activation=this.sigmoid(e,r.ACTIVATION_RESPONSE))})}),s.assert(o.length==this.numOutputs,"out length incorrect")?o:[]}sigmoid(t,e){return 1/(1+Math.exp(-t/e))}calcSplitPoints(){let t=[],e=0;return this.layers.forEach(s=>s.neurons.forEach(s=>{e+=s.numInputs,t.push(e-1)})),t}},runGASearch:function(t,e){let i,r,n=p(e),o=e.maxCycles||100,h=1e3*(e.maxSeconds||30),l=function*([t,e],{mutate:i,create:r,maxAge:n,calcFit:o,poolSize:h,crossOver:l}){let a,c=r();yield c;let u,d,f,g,p,m=[c],_=[c];h=h||1,n=n||50;for(let t=0;t<h-1;++t)a=r(),a.fitness.gt(c.fitness)&&(yield c=a,_.push(a)),m.push(a);for(p=h-1,g=1;;)if(s.now()-t>e&&(yield c),g=g>0?g-1:p,a=m[g],d=y(g,m,l,i,o),a.fitness.gt(d.fitness)){if(void 0===n)continue;if(a.age+=1,n>a.age)continue;if(f=w(_,d,_.length),u=f/_.length,s.rand()<Math.exp(-u)){m[g]=d;continue}c.age=0,m[g]=c}else d.fitness.gt(a.fitness)?(d.age=0,m[g]=d,d.fitness.gt(c.fitness)&&(yield c=d,_.push(c))):(d.age=a.age+1,m[g]=d)}([n,h],e);for(;;){if(i=l.next().value,r=m(e),r-n>h){r=null;break}if(!t.gt(i.fitness))break;if(e.cycles>=o)break;e.cycles+=1}return[null==r,i]},runGACycle:function(t,e){let i,r,{maxCycles:n,targetScore:o,maxSeconds:h}=e,l=p(e),a=1e3*(h||30);for(n=n||100;;){if(t=_(t,e),r=m(e),r-l>a){r=null;break}if(i=g(t),s.echt(o)&&i.bestScore>=o)break;if(e.cycles>=n)break;e.cycles+=1}return e.gen++,[null==r,t]},calcStats:g,NumFitness:o,Fitness:n,Chromosome:c,mutateSM:function(t){if(s.rand()<r.mutationRate){let e,[i,r]=u(t),n=r-i-1;if(2==n)e=t[i+1],t[i+1]=t[i+2],t[i+2]=e;else if(n>2){e=s.shuffle(t.slice(i+1,r));for(let s=0,n=i+1;n<r;++n)t[n]=e[s++]}}},mutateDM:function(t){if(s.rand()<r.mutationRate){let e,i,r,[n,o]=u(t),h=t.length;o-n-1>0&&(i=t.slice(n+1,o),r=t.slice(0,n+1).concat(t.slice(o)),e=s.randInt(r.length),i=r.slice(0,e).concat(i).concat(r.slice(e)),t.length=0,i.forEach(e=>t.push(e)),s.assert(t.length==h,"mutateDM error"))}},mutateIVM:function(t){if(s.rand()<r.mutationRate){let e,[i,r]=u(t),n=t.length;if(r-i-1>1){e=t.slice(i+1,r).reverse();for(let s=0,n=i+1;n<r;++n)t[n]=e[s++]}s.assert(n==t.length,"mutateIVM error")}},mutateDIVM:function(t){if(s.rand()<r.mutationRate){let e,i,r,[n,o]=u(t),h=t.length;o-n-1>0&&(i=t.slice(n+1,o).reverse(),r=t.slice(0,n+1).concat(t.slice(o)),e=s.randInt(r.length),i=r.slice(0,e).concat(i).concat(r.slice(e)),t.length=0,i.forEach(e=>t.push(e)),s.assert(t.length==h,"mutateDIVM error"))}},crossOverOBX:function(t,e){let i,n,o,h,l;if(s.randInt2(0,t.length-2),o=t.slice(),h=e.slice(),s.rand()>r.crossOverRate||t===e);else{n=s.listIndexesOf(t,!0).slice(0,s.toGoldenRatio(t.length)[1]).sort(),i=n.map(e=>t[e]),l=0;for(let t=0;t<h.length;++t)for(let e=0;e<i.length;++e)if(h[t]==i[e]){h[t]=i[l++];break}i.length=0,l=0;for(let t=0;t<n.length;++t)i.push(e[n[t]]);for(let t=0;t<o.length;++t)for(let e=0;e<i.length;++e)if(o[t]==i[e]){o[t]=i[l++];break}}return[o,h]},crossOverPBX:function(t,e){let i,n;if(s.rand()>r.crossOverRate||t===e)i=t.slice(),n=e.slice();else{i=s.fill(t.length,null),n=s.fill(t.length,null),s.listIndexesOf(t,!0).slice(0,s.toGoldenRatio(t.length)[1]).sort().forEach(s=>{i[s]=t[s],n[s]=e[s]});let r=0,o=0;for(let s=0;s<t.length;++s){for(;null!==n[o]&&o<t.length;)++o;for(n.indexOf(t[s])<0&&(n[o]=t[s]);null!==i[r]&&r<t.length;)++r;i.indexOf(e[s])<0&&(i[r]=e[s])}s.assert(!i.some(t=>null===t),"crossOverPBX null error"),s.assert(!n.some(t=>null===t),"crossOverPBX null error")}return[i,n]},crossOverRND:function(t,e){let i,n;if(s.rand()>r.crossOverRate||t===e)i=t.slice(),n=e.slice();else{let r=s.randInt(t.length);i=[],n=[];for(let s=0;s<r;++s)i.push(t[s]),n.push(e[s]);for(let s=r;s<t.length;++s)i.push(e[s]),n.push(t[s])}return[i,n]},crossOverPMX:function(t,e){let i=t.slice(),n=e.slice();if(s.rand()>r.crossOverRate||t===e);else{let r=s.randInt2(0,t.length-2),o=r;for(;o<=r;)o=s.randInt2(0,t.length-1);for(let h,l,a,c,u=r;u<o+1;++u)a=t[u],c=e[u],a!=c&&(h=i.indexOf(a),l=i.indexOf(c),s.swap(i,h,l),h=n.indexOf(a),l=n.indexOf(c),s.swap(n,h,l))}return[i,n]},crossOverAtSplits:function(t,e,i){let n,o;if(s.rand()>r.crossOverRate||t===e)n=t.slice(),o=e.slice();else{let r=i[s.randInt2(0,i.length-2)],h=i[s.randInt2(r,i.length-1)];n=[],o=[];for(let s=0;s<t.length;++s)s<r||s>=h?(n.push(t[s]),o.push(e[s])):(n.push(e[s]),o.push(t[s]))}return[n,o]},hillClimb:function(t,e,i,r,n,o){o.startTime=s.now();let h,l=t(n);for(;!i(l);)h=t(r(l)),e(l,h)&&(l=h);return o.endTime=s.now(),l},showBest(t,e,i){console.log(s.fill(80,"-").join("")),console.log("total time: "+s.prettyMillis(e.endTime-e.startTime)),i&&console.log("time expired"),console.log("total generations= "+e.gen),console.log("total cycles= "+e.cycles),console.log("fitness= "+t.fitness.score()),console.log(s.fill(80,"-").join(""))},config:t=>s.inject(r,t)}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core")):t["io/czlab/mcfud/algo/NNetGA"]=e}(this),function(t){"use strict";function e(e){e||(e=t["io/czlab/mcfud/core"]());const s=Math.floor,{u:i,is:r}=e,n={INPUT:0,HIDDEN:1,OUTPUT:2,BIAS:3,NONE:4},o={NEURON:0,LINK:1},h={SNAPSHOT:0,ACTIVE:1},l={numInputs:0,numOutputs:0,bias:-1,sigmoidResponse:1,numAddLinkAttempts:5,numTrysToFindLoopedLink:5,numTrysToFindOldLink:5,chanceAddLink:.07,chanceAddNode:.03,chanceAddRecurrentLink:.05,mutationRate:.8,maxWeightPerturbation:.5,probabilityWeightReplaced:.1,activationMutationRate:.1,maxActivationPerturbation:.1,compatibilityThreshold:.26,youngFitnessBonus:1.3,youngBonusAgeThreshhold:10,survivalRate:0,oldAgeThreshold:50,oldAgePenalty:.7,crossOverRate:.7,numGensAllowedNoImprovement:15,maxPermittedNeurons:100,numBestElites:4};function a(t,e=!1){return{value:t,gt(t){return e?this.value<t.value:this.value>t.value},eq(t){return this.value==t.value},lt(t){return e?this.value>t.value:this.value<t.value},score(){return this.value},update(t){this.value=t},clone:()=>a(t,e)}}class c{constructor(t,e=null,s=!1){this.pos=e?e.slice():[0,0],this.activation=1,this.recurrent=s,r.vec(t)?(this.id=t[0],this.neuronType=t[1]):(this.id=0,this.neuronType=t)}clone(){let t=new c(this.neuronType);return t.id=this.id,t.activation=this.activation,t.recurrent=this.recurrent,t.pos=this.pos.slice(),t}static from(t,e,s=null,i=!1){return new c([t,e],s,i)}}class u{constructor(t,e,s,r=!0,n=null,o=!1){this.fromNeuron=t,this.toNeuron=e,this.innovationID=s,this.recurrent=!0===o,this.enabled=!1!==r,this.weight=null===n?i.randMinus1To1():n}clone(){let t=new u;return t.fromNeuron=this.fromNeuron,t.toNeuron=this.toNeuron,t.innovationID=this.innovationID,t.recurrent=this.recurrent,t.enabled=this.enabled,t.weight=this.weight,t}}class d{constructor(t,e,s,i,r=n.NONE,o=null){this.pos=o?o.slice():[0,0],this.innovationID=i,this.innovationType=s,this.neuronID=0,this.neuronType=r,this.neuronIn=t,this.neuronOut=e}static from(t,e){let s=new d(-1,-1,null,e,t.neuronType,t.pos);return s.neuronID=t.id,s}}class f{constructor(t,e){this.NEURON_COUNTER=t.length-1,this.INNOV_COUNTER=0,this.vecInnovs=t.map(t=>d.from(t,this.nextIID())).concat(e.map(t=>new d(t.fromNeuron,t.toNeuron,o.LINK,this.nextIID())))}nextIID(){return this.INNOV_COUNTER++}check(t,e,s){let i=this.vecInnovs.find(i=>i.neuronIn==t&&i.neuronOut==e&&i.innovationType==s);return void 0===i?-1:i.innovationID}create(t,e,s,i=n.NONE,r=null){let h=new d(t,e,s,this.nextIID(),i,r);return o.NEURON==s&&(h.neuronID=++this.NEURON_COUNTER),this.vecInnovs.push(h),h}flush(){this.vecInnovs.length=0}getNeuronID(t){return this.vecInnovs[t].neuronID}}class g{constructor(t,e,s,i=!1){this.weight=t,this.from=e,this.out=s,this.recurrent=!0===i}clone(){let t=new g;return t.weight=this.weight,t.from=this.from,t.out=this.out,t.recurrent=this.recurrent,t}}class p{constructor(t,e,s,i){this.neuronType=t,this.neuronID=e,this.sumActivation=0,this.output=0,this.posX=0,this.posY=0,this.vecLinksIn=[],this.vecLinksOut=[],this.activation=i,this.pos=s?s.slice():[0,0]}clone(){let t=new p;return t.neuronType=this.neuronType,t.neuronID=this.neuronID,t.output=this.output,t.posX=this.posX,t.posY=this.posY,t.pos=this.pos.slice(),t.activation=this.activation,t.sumActivation=this.sumActivation,t.vecLinksIn=this.vecLinksIn.map(t=>t.clone()),t.vecLinksOut=this.vecLinksOut.map(t=>t.clone()),t}}class m{constructor(t,e){this.vecNeurons=t,this.depth=e}clone(){let t=new m(null,this.depth);return t.vecNeurons=this.vecNeurons.map(t=>t.clone()),t}update(t,e=h.ACTIVE){let s=[],r=e==h.SNAPSHOT?this.depth:1;for(let e,h,a=0;a<r;++a){for(s.length=0,h=0;this.vecNeurons[h].neuronType==n.INPUT;)this.vecNeurons[h].output=t[h],++h;for(i.assert(this.vecNeurons[h].neuronType==n.BIAS,"expecting BIAS node"),this.vecNeurons[h].output=1,++h;h<this.vecNeurons.length;)e=this.vecNeurons[h].vecLinksIn.reduce((t,e)=>t+e.weight*e.from.output,0),this.vecNeurons[h].output=(o=e,l=this.vecNeurons[h].activation,1/(1+Math.exp(-o/l))),this.vecNeurons[h].neuronType==n.OUTPUT&&s.push(this.vecNeurons[h].output),++h}var o,l;return e==h.SNAPSHOT&&this.vecNeurons.forEach(t=>t.output=0),s}draw(t,e,s,i,r){}}class y{constructor(t,e,s,i=null,r=null){if(t<0)return;let o,h=0,l=1/(e+2),d=1/(s+1);if(i&&r)this.vecNeurons=i,this.vecLinks=r;else{for(this.vecNeurons=[],this.vecLinks=[],o=0;o<e;++o)this.vecNeurons.push(c.from(h++,n.INPUT,[(o+2)*l,0]));for(this.vecNeurons.push(c.from(h++,n.BIAS,[l,0])),o=0;o<s;++o)this.vecNeurons.push(c.from(h++,n.OUTPUT,[(o+1)*d,1]));for(o=0;o<e+1;++o)for(let t=0;t<s;++t)this.vecLinks.push(new u(this.vecNeurons[o].id,this.vecNeurons[e+1+t].id,e+s+1+this.vecLinks.length))}this.nextNeuronID=h,this.fitness=a(0),this.genomeID=t,this.adjustedFitness=0,this.amountToSpawn=0,this.numInputs=e,this.numOutputs=s,this.species=0}createPhenotype(t){let e=this.vecNeurons.map(t=>new p(t.neuronType,t.id,t.pos,t.activation));return this.vecLinks.forEach(t=>{if(t.enabled){let s=e[this.getIndex(t.toNeuron)],i=e[this.getIndex(t.fromNeuron)],r=new g(t.weight,i,s,t.recurrent);i.vecLinksOut.push(r),s.vecLinksIn.push(r)}}),new m(e,t)}_randAny(){return this.vecNeurons[i.randInt2(0,this.vecNeurons.length-1)]}_randNonInputs(){return this.vecNeurons[i.randInt2(this.numInputs+1,this.vecNeurons.length-1)]}addLink(t,e,s,r,h){if(i.rand()>t)return;let l=-1,a=-1,c=!1;if(i.rand()<e)for(;r--;){let t=this._randNonInputs();if(t.neuronType!=n.BIAS&&t.neuronType!=n.INPUT&&!t.recurrent){l=a=t.id,c=t.recurrent=!0;break}}else for(;h--&&(l=this._randAny().id,a=this._randNonInputs().id,l==a||this.duplicateLink(l,a));)l=a=-1;if(l<0||a<0);else{let t=s.check(l,a,o.LINK);this.vecNeurons[this.getIndex(l)].pos[1]>this.vecNeurons[this.getIndex(a)].pos[1]&&(c=!0),t<0&&(t=s.create(l,a,o.LINK).innovationID),this.vecLinks.push(new u(l,a,t,!0,i.randMinus1To1(),c))}}addNeuron(t,e,r){if(i.rand()>t)return;let h,l,a,d,f=0,g=!1,p=this.numInputs+this.numOutputs+5;if(this.vecLinks.length<p){for(;r--;)if(f=i.randInt2(0,this.numGenes()-1-s(Math.sqrt(this.numGenes()))),h=this.vecLinks[f].fromNeuron,this.vecLinks[f].enabled&&!this.vecLinks[f].recurrent&&this.vecNeurons[this.getIndex(h)].neuronType!=n.BIAS){g=!0;break}if(!g)return}else for(;!g;)f=i.randInt2(0,this.numGenes()-1),h=this.vecLinks[f].fromNeuron,this.vecLinks[f].enabled&&!this.vecLinks[f].recurrent&&this.vecNeurons[this.getIndex(h)].neuronType!=n.BIAS&&(g=!0);this.vecLinks[f].enabled=!1;let m=this.vecLinks[f].weight,y=this.vecLinks[f].fromNeuron,w=this.vecLinks[f].toNeuron,_=(this.vecNeurons[this.getIndex(y)].pos[1]+this.vecNeurons[this.getIndex(w)].pos[1])/2,v=(this.vecNeurons[this.getIndex(y)].pos[0]+this.vecNeurons[this.getIndex(w)].pos[0])/2,x=e.check(y,w,o.NEURON);if(x>=0&&this.hasNeuron(e.getNeuronID(x))&&(x=-1),x<0){let t=e.create(y,w,o.NEURON,n.HIDDEN,[v,_]),s=c.from(this.nextNeuronID,n.HIDDEN,[v,_]);t.neuronID=s.id,d=s.id,this.nextNeuronID++,this.vecNeurons.push(s),l=e.create(y,d,o.LINK).innovationID,this.vecLinks.push(new u(y,d,l,!0,1)),a=e.create(d,w,o.LINK).innovationID,this.vecLinks.push(new u(d,w,a,!0,m))}else d=e.getNeuronID(x),l=e.check(y,d,o.LINK),a=e.check(d,w,o.LINK),(l<0||a<0)&&i.assert(!1,"Error in Genome::AddNeuron"),this.vecLinks.push(new u(y,d,l,!0,1),new u(d,w,a,!0,m)),this.vecNeurons.push(c.from(d,n.HIDDEN,[v,_]))}getIndex(t){for(let e=0;e<this.vecNeurons.length;++e)if(this.vecNeurons[e].id==t)return e;i.assert(!1,"Error in Genome::getIndex")}duplicateLink(t,e){return this.vecLinks.some(s=>s.fromNeuron==t&&s.toNeuron==e)}hasNeuron(t){return this.vecNeurons.some(e=>t==e.id)}mutateWeights(t,e,s){for(let r=0;r<this.vecLinks.length;++r)i.rand()<t&&(i.rand()<e?this.vecLinks[r].weight=i.randMinus1To1():this.vecLinks[r].weight+=i.randMinus1To1()*s)}mutateActivation(t,e){this.vecNeurons.forEach(s=>{i.rand()<t&&(s.activation+=i.randMinus1To1()*e)})}calcCompatibility(t){let e=0,s=0,i=0,r=0,n=0,o=0;for(;e<this.vecLinks.length-1||s<t.vecLinks.length-1;){if(e==this.vecLinks.length-1){++s,++r;continue}if(s==t.vecLinks.length-1){++e,++r;continue}let h=this.vecLinks[e].innovationID,l=t.vecLinks[s].innovationID;h==l?(++e,++s,++n,o+=Math.abs(this.vecLinks[e].weight-t.vecLinks[s].weight)):(++i,h<l?++e:h>l&&++s)}const h=Math.max(this.numGenes(),t.numGenes());let l=1*r/h+1*i/h;return n>0?l+.4*o/n:l}sortGenes(){return this.vecLinks.sort((t,e)=>t.innovationID<e.innovationID?-1:t.innovationID>e.innovationID?1:0),this}id(){return this.genomeID}setID(t){this.genomeID=t}numGenes(){return this.vecLinks.length}numNeurons(){return this.vecNeurons.length}setFitness(t){this.fitness=a(t)}splitY(t){return this.vecNeurons[t].pos[1]}genes(){return this.vecLinks}neurons(){return this.vecNeurons}startOfGenes(){return 0}endOfGenes(){return this.vecLinks.length}clone(){let t=this,e=new y(-911);return e.fitness=t.fitness.clone(),e.genomeID=t.genomeID,e.adjustedFitness=t.adjustedFitness,e.amountToSpawn=t.amountToSpawn,e.numInputs=t.numInputs,e.numOutputs=t.numOutputs,e.species=t.species,e.vecNeurons=t.vecNeurons.map(t=>t.clone()),e.vecLinks=t.vecLinks.map(t=>t.clone()),e}}class w{constructor(t,e){this.speciesID=t,this._gensNoImprovement=0,this._age=0,this.spawnsRqd=0,this.vecMembers=[e],this._leader=e.clone(),this._bestFitness=e.fitness.score()}adjustFitnesses(){let t,e=0;this.vecMembers.forEach(s=>{t=s.fitness.score(),this._age<l.youngBonusAgeThreshhold&&(t*=l.youngFitnessBonus),this._age>l.oldAgeThreshold&&(t*=l.oldAgePenalty),e+=t,s.adjustedFitness=t/this.vecMembers.length})}addMember(t){t.fitness.score()>this._bestFitness&&(this._bestFitness=t.fitness.score(),this._gensNoImprovement=0,this._leader=t.clone()),this.vecMembers.push(t),t.species=this.id()}purge(){return this.vecMembers.length=0,++this._gensNoImprovement,this.spawnsRqd=0,++this._age,this}calculateSpawnAmount(){this.vecMembers.forEach(t=>{this.spawnsRqd+=t.amountToSpawn})}spawn(){let t,e;return 1==this.vecMembers.length?e=this.vecMembers[0]:(t=s(l.survivalRate*this.vecMembers.length)-1,t<0&&(t=1),e=this.vecMembers[i.randInt2(0,t)]),e.clone()}id(){return this.speciesID}bestFitness(){return this._bestFitness}age(){return this._age}leader(){return this._leader}numToSpawn(){return this.spawnsRqd}numMembers(){return this.vecMembers.length}gensNoImprovement(){return this._gensNoImprovement}}function _(t,e,s,i){const r=e-t;return i.push({val:t+r/2,depth:s+1}),s>6||(_(t,t+r/2,s+1,i),_(t+r/2,e,s+1,i)),i}return{NeatGA:class{constructor(t,e,s){let r=new y(0,e,s);this.vecSplits=_(0,1,0,[]),this.vecBestGenomes=[],this.vecSpecies=[],this.SPECIES_COUNTER=0,this.GENOME_COUNTER=0,this.generation=0,this.popSize=t,this.totFitAdj=0,this.avFitAdj=0,this.fittestGenome=0,this._bestEverFitness=0,this.vecGenomes=i.fill(t,()=>new y(this.nextGID(),e,s)),this.innovHistory=new f(r.neurons(),r.genes())}resetAndKill(){this.totFitAdj=0,this.avFitAdj=0;let t=[];this.vecSpecies.forEach(e=>{e.gensNoImprovement()>l.numGensAllowedNoImprovement&&e.bestFitness()<this._bestEverFitness||t.push(e.purge())}),this.vecSpecies.length=0,t.forEach(t=>this.vecSpecies.push(t))}speciateAndCalculateSpawnLevels(){let t=!1;this.vecGenomes.forEach(e=>{for(let s=0;s<this.vecSpecies.length;++s)if(e.calcCompatibility(this.vecSpecies[s].leader())<=l.compatibilityThreshold){this.vecSpecies[s].addMember(e),t=!0;break}t||this.vecSpecies.push(new w(this.nextSID(),e)),t=!1}),this.vecSpecies.forEach(t=>t.adjustFitnesses()),this.vecGenomes.forEach(t=>this.totFitAdj+=t.adjustedFitness),this.avFitAdj=this.totFitAdj/this.vecGenomes.length,this.vecGenomes.forEach(t=>t.amountToSpawn=t.adjustedFitness/this.avFitAdj),this.vecSpecies.forEach(t=>t.calculateSpawnAmount())}crossOver(t,e){let s;function r(t,e){e.indexOf(t)<0&&e.push(t)}s=t.fitness.score()==e.fitness.score()?t.numGenes()==e.numGenes()?i.randSign()>0?1:0:t.numGenes()<e.numGenes()?0:1:t.fitness.score()>e.fitness.score()?0:1;let o,h=[],l=[],a=[],u=0,d=0;for(;u!=t.endOfGenes()||d!=e.endOfGenes();)u==t.endOfGenes()&&d!=e.endOfGenes()?(1==s&&(o=e.vecLinks[d]),++d):d==e.endOfGenes()&&u!=t.endOfGenes()||t.vecLinks[u].innovationID<e.vecLinks[d].innovationID?(0==s&&(o=t.vecLinks[u]),++u):e.vecLinks[d].innovationID<t.vecLinks[u].innovationID?(1==s&&(o=e.vecLinks[d]),++d):e.vecLinks[d].innovationID==t.vecLinks[u].innovationID&&(o=i.rand()<.5?t.vecLinks[u]:e.vecLinks[d],++u,++d),0!=l.length&&i.last(l).innovationID==o.innovationID||l.push(o.clone()),r(o.fromNeuron,a),r(o.toNeuron,a);return a.sort().forEach(t=>h.push(function(t,e){let s=c.from(0,n.HIDDEN);for(let i,r=0;r<t.vecInnovs.length;++r)if(i=t.vecInnovs[r],i.neuronID==e)return s.neuronType=i.neuronType,s.id=i.neuronID,s.pos=i.pos.slice(),s;i.assert(!1,"boom from createNeuronFromID")}(this.innovHistory,t))),new y(this.nextGID(),t.numInputs,t.numOutputs,h,l)}nextSID(){return++this.SPECIES_COUNTER}nextGID(){return++this.GENOME_COUNTER}tournamentSelection(t){let e=0,s=0;for(let r,n=0,o=this.vecGenomes.length-1;n<t;++n)r=i.randInt2(0,o),this.vecGenomes[r].fitness.score()>s&&(e=r,s=this.vecGenomes[r].fitness.score());return this.vecGenomes[e]}calculateNetDepth(t){let e=0;for(let s=0;s<t.numNeurons();++s)for(let i=0;i<this.vecSplits.length;++i)t.splitY(s)==this.vecSplits[i].val&&this.vecSplits[i].depth>e&&(e=this.vecSplits[i].depth);return e+2}sortAndRecord(t){this.vecGenomes.forEach((e,s)=>e.setFitness(t[s])),this.vecGenomes.sort((t,e)=>t.fitness.score()>e.fitness.score()?-1:t.fitness.score()<e.fitness.score()?1:0),this._bestEverFitness=Math.max(this._bestEverFitness,this.vecGenomes[0].fitness.score()),this.vecBestGenomes.length=0;for(let t=0;t<l.numBestElites;++t)this.vecBestGenomes.push(this.vecGenomes[t])}epoch(t){i.assert(t.length==this.vecGenomes.length,"NeatGA::Epoch(scores/ genomes mismatch)!"),this.resetAndKill(),this.sortAndRecord(t),this.speciateAndCalculateSpawnLevels();let e,r=[],n=0;if(this.vecSpecies.forEach(t=>{if(n<this.popSize){let s=!1,o=i.rounded(t.numToSpawn());for(;o--;){if(s){if(1==t.numMembers())e=t.spawn();else{let s,r=5,n=t.spawn();if(i.rand()<l.crossOverRate){for(s=t.spawn();n.id()==s.id()&&r--;)s=t.spawn();e=n.id()!=s.id()?this.crossOver(n,s):n}else e=n}e.setID(this.nextGID()),e.numNeurons()<l.maxPermittedNeurons&&e.addNeuron(l.chanceAddNode,this.innovHistory,l.numTrysToFindOldLink),e.addLink(l.chanceAddLink,l.chanceAddRecurrentLink,this.innovHistory,l.numTrysToFindLoopedLink,l.numAddLinkAttempts),e.mutateWeights(l.mutationRate,l.probabilityWeightReplaced,l.maxWeightPerturbation),e.mutateActivation(l.activationMutationRate,l.maxActivationPerturbation)}else s=!0,e=t.leader().clone();r.push(e.sortGenes()),++n==this.popSize&&(o=0)}}}),n<this.popSize){let t=this.popSize-n;for(;t--;)r.push(this.tournamentSelection(s(this.popSize/5)).clone())}return this.vecGenomes=r,++this.generation,this.createPhenotypes()}createPhenotypes(){return this.vecGenomes.map(t=>t.createPhenotype(this.calculateNetDepth(t)))}renderSpeciesInfo(){}numSpecies(){return this.vecSpecies.length}bestEverFitness(){return this._bestEverFitness}getBestPhenotypesFromLastGeneration(){return this.vecBestGenomes.map((t,e)=>{t.createPhenotype(this.calculateNetDepth(t))})}},NeuralNet:m,Genome:y,NeuronGene:c,LinkGene:u,NLink:g,NNeuron:p,Species:w,NumFitness:a,InnovHistory:f,NeuronType:n,InnovType:o,RunType:h,configParams:t=>i.inject(l,t)}}"object"==typeof module&&module.exports?module.exports=e(require("../main/core")):t["io/czlab/mcfud/algo/NEAT"]=e}(this),function(t){"use strict";function e(e,s){if(e||(e=t["io/czlab/mcfud/core"]()),!s)throw"Fatal: No Colors!";const{is:i,u:r}=e;function n(t,e){let s="";for(;t>0;)s+=e,--t;return s}function o(t,e){let s=c;return e&&(i.str(t)?s="any"===t||t===e?u:c:t instanceof e&&(s=u)),s}function h(t,e,s){return new Promise((i,r)=>{let n;try{n=s.call(t),n instanceof Promise?n.then((function(t){i(`${t?u:c}: ${e}`)})):(n=n?709394===n?a:u:c,i(`${n}: ${e}`))}catch(t){n=c,i(`${n}: ${e}`)}})}function l(t,e,s,i){return new Promise((r,n)=>{let h;try{h=s.call(t),h=709394===h?u:o(i,null)}catch(t){h=o(i,t)}r(`${h}: ${e}`)})}const[a,c,u]=["Skippd","Failed","Passed"];return{prn(t){const e=t.passed.length,i=t.total,o=e/i*100;console.log(s.white(n(78,"+"))),console.log(s.white.bold(t.title)),console.log(s.white(t.date)),console.log(s.white(n(78,"+"))),t.passed.length>0&&console.log(s.green(t.passed.join("\n"))),t.skippd.length>0&&console.log(s.grey(t.skippd.join("\n"))),t.failed.length>0&&console.log(s.magenta(t.failed.join("\n"))),console.log(s.white(n(78,"="))),console.log(s.yellow(["Passed: ",e,"/",i," [",0|o,"%]"].join(""))),console.log(s.magenta("Failed: "+(i-e))),console.log(s.white(["cpu-time: ",r.prettyMillis(t.duration)].join(""))),console.log(s.white(n(78,"=")))},deftest(t){let[e,s,i,r]=[null,null,null,null];const n={ensure:(t,e)=>(i.push([1,t,e]),n),eerror:(t,e)=>(i.push([911,t,e]),n),begin:t=>(r={},i=[],e=t,n),end(n){s=n;let o=function(){return new Promise((t,n)=>{e&&e(r);let o,a=[];for(let t,e,s=0;s<i.length;++s){switch(e=i[s],e[0]){case 1:t=h(r,e[1],e[2]);break;case 911:t=l(r,e[1],e[2],"any")}o=o?o.then((function(e){return a.push(e),t})):t}o&&o.then((function(e){a.push(e),i.length=0,s&&s(r),t(a)}))})};return(o.title=t)&&o}};return n},_run:t=>new Promise((e,s)=>{t().then((function(t){e(t)}))}),runtest(t,e){const s=Date.now();return this._run(t).then((function(i){const r=Date.now(),n={title:e||t.title,date:(new Date).toString(),total:i.length,duration:r-s,passed:i.filter(t=>"P"===t[0]),skippd:i.filter(t=>"S"===t[0]),failed:i.filter(t=>"F"===t[0])};return new Promise(t=>{t(n)})}))}}}"object"==typeof module&&module.exports?module.exports=e(require("./core"),require("colors/safe")):t["io/czlab/mcfud/test"]=e}(this);